#!/usr/bin/env node
const { spawnSync } = require("child_process");
const fs = require("fs");
const os = require("os");
const path = require("path");
const pc = require("picocolors");

// Color helper functions for consistent output
const success = (msg) => console.log(pc.green(msg));
const error = (msg) => console.error(pc.red(msg));
const info = (msg) => console.log(pc.cyan(msg));
const dim = (msg) => console.log(pc.dim(msg));
const warn = (msg) => console.log(pc.yellow(msg));

const rawArgs = process.argv.slice(2);
const args = [];
const cwd = process.cwd();
const repoRoot = path.resolve(__dirname, "..");
const globalDir = path.join(repoRoot, ".agents", "ralph");
const localDir = path.join(cwd, ".agents", "ralph");
const skillsRoot = path.join(repoRoot, "skills");
let agentOverride = null;
let installSkills = false;
let installForce = false;
let prdPath = null;
let prdNumber = null;  // PRD number for folder-based storage (e.g., --prd=1 uses PRD-1)
let planPath = null;
let progressPath = null;
let prdOutPath = null;

function exists(p) {
  try {
    fs.accessSync(p);
    return true;
  } catch {
    return false;
  }
}

function usage() {
  console.log(`${pc.bold("ralph")} ${pc.dim("<command>")}

${pc.bold(pc.cyan("Commands:"))}
  ${pc.green("install")} ${pc.dim("[--skills] [--force]")}        Copy .agents/ralph into the current repo
  ${pc.green("prd")} ${pc.dim("[\"<request>\"] [--out path]")}      Generate a PRD via agent
  ${pc.green("ping")}                                Minimal agent health check
  ${pc.green("log")} ${pc.dim("\"<message>\"")}                     Append to .ralph/activity.log
  ${pc.green("build")} ${pc.dim("[n] [--no-commit]")}             Run build loop (default)
  ${pc.green("plan")} ${pc.dim("[n]")}                            Run planning loop
  ${pc.green("stream")} ${pc.dim("<subcmd>")}                     Multi-stream parallel execution
  ${pc.green("eval")} ${pc.dim("[run-id] [--all]")}               Evaluate run quality and generate reports
  ${pc.green("improve")} ${pc.dim("[--generate] [--apply]")}       Review and apply guardrail candidates
  ${pc.green("help")}                                Show this message

${pc.bold(pc.cyan("Stream commands:"))}
  ${pc.green("stream new")}                          Create new stream (prd-1, prd-2, ...)
  ${pc.green("stream list")}                         List all streams
  ${pc.green("stream status")}                       Show detailed status
  ${pc.green("stream init")} ${pc.dim("<N>")}                     Initialize worktree for parallel execution
  ${pc.green("stream build")} ${pc.dim("<N> [n]")}                Run n build iterations in stream
  ${pc.green("stream merge")} ${pc.dim("<N>")}                    Merge completed stream to main
  ${pc.green("stream cleanup")} ${pc.dim("<N>")}                  Remove stream worktree

${pc.bold(pc.cyan("Options:"))}
  ${pc.yellow("--prd")} ${pc.dim("<N|path>")}                      Use PRD-N folder (e.g., --prd=1) or custom path
  ${pc.yellow("--out")} ${pc.dim("<path>")}                        Override PRD output path (prd command)
  ${pc.yellow("--plan")} ${pc.dim("<path>")}                       Override plan path
  ${pc.yellow("--progress")} ${pc.dim("<path>")}                   Override progress log path
  ${pc.yellow("--agent")} ${pc.dim("<codex|claude|droid>")}        Override agent runner

${pc.bold(pc.cyan("Notes:"))}
${pc.dim("- Uses local .agents/ralph if present; otherwise uses bundled defaults.")}
${pc.dim("- State and logs are written to .ralph/ in the project.")}
`);
}

for (let i = 0; i < rawArgs.length; i += 1) {
  const arg = rawArgs[i];
  if (arg.startsWith("--agent=")) {
    agentOverride = arg.split("=").slice(1).join("=");
    continue;
  }
  if (arg === "--agent") {
    agentOverride = rawArgs[i + 1];
    i += 1;
    continue;
  }
  if (arg === "--skills") {
    installSkills = true;
    continue;
  }
  if (arg === "--force") {
    installForce = true;
    continue;
  }
  if (arg.startsWith("--prd=")) {
    const prdValue = arg.split("=").slice(1).join("=");
    // Check if it's a number (PRD folder) or a path
    if (/^\d+$/.test(prdValue)) {
      prdNumber = prdValue;
    } else {
      prdPath = prdValue;
    }
    continue;
  }
  if (arg.startsWith("--out=")) {
    prdOutPath = arg.split("=").slice(1).join("=");
    continue;
  }
  if (arg === "--prd") {
    const prdValue = rawArgs[i + 1];
    // Check if it's a number (PRD folder) or a path
    if (/^\d+$/.test(prdValue)) {
      prdNumber = prdValue;
    } else {
      prdPath = prdValue;
    }
    i += 1;
    continue;
  }
  if (arg === "--out") {
    prdOutPath = rawArgs[i + 1];
    i += 1;
    continue;
  }
  if (arg.startsWith("--plan=")) {
    planPath = arg.split("=").slice(1).join("=");
    continue;
  }
  if (arg === "--plan") {
    planPath = rawArgs[i + 1];
    i += 1;
    continue;
  }
  if (arg.startsWith("--progress=")) {
    progressPath = arg.split("=").slice(1).join("=");
    continue;
  }
  if (arg === "--progress") {
    progressPath = rawArgs[i + 1];
    i += 1;
    continue;
  }
  args.push(arg);
}

const cmd = args[0];
if (cmd === "help" || cmd === "-h" || cmd === "--help") {
  usage();
  process.exit(0);
}

async function runInstallSkills() {
  const { intro, outro, select, isCancel } = await import("@clack/prompts");
  intro("Ralph skills install");

  const agent = await select({
    message: "Which agent are you using?",
    options: [
      { value: "codex", label: "codex" },
      { value: "claude", label: "claude" },
      { value: "droid", label: "droid" },
    ],
    initialValue: agentOverride || "codex",
  });
  if (isCancel(agent)) {
    outro("Cancelled.");
    process.exit(0);
  }

  const scope = await select({
    message: "Where should skills be installed?",
    options: [
      { value: "local", label: "Local (project)" },
      { value: "global", label: "Global (home directory)" },
    ],
    initialValue: "local",
  });
  if (isCancel(scope)) {
    outro("Cancelled.");
    process.exit(0);
  }

  const home = os.homedir();
  const targetRoot =
    agent === "codex"
      ? scope === "global"
        ? path.join(home, ".codex", "skills")
        : path.join(cwd, ".codex", "skills")
      : agent === "claude"
        ? scope === "global"
          ? path.join(home, ".claude", "skills")
          : path.join(cwd, ".claude", "skills")
        : scope === "global"
          ? path.join(home, ".factory", "skills")
          : path.join(cwd, ".factory", "skills");

  const skillsToInstall = ["commit", "dev-browser", "prd"];
  fs.mkdirSync(targetRoot, { recursive: true });
  const installed = [];
  const skipped = [];

  for (const skill of skillsToInstall) {
    const source = path.join(skillsRoot, skill);
    const target = path.join(targetRoot, skill);
    if (!exists(source)) {
      skipped.push(`${skill} (missing in repo)`);
      continue;
    }
    if (exists(target) && !installForce) {
      skipped.push(`${skill} (already exists)`);
      continue;
    }
    fs.cpSync(source, target, { recursive: true, force: true });
    installed.push(skill);
  }

  if (installed.length) {
    success(`Installed skills to ${pc.cyan(targetRoot)}: ${installed.join(", ")}`);
  }
  if (skipped.length) {
    dim(`Skipped: ${skipped.join(", ")}`);
  }
  outro("Done.");
}

async function main() {
  if (cmd === "install") {
    if (exists(localDir) && !installForce) {
      dim(`.agents/ralph already exists at ${pc.cyan(localDir)}. Skipping templates.`);
    } else {
      if (!exists(globalDir)) {
        error(`Bundled templates not found at ${pc.cyan(globalDir)}.`);
        process.exit(1);
      }
      fs.mkdirSync(path.dirname(localDir), { recursive: true });
      fs.cpSync(globalDir, localDir, { recursive: true, force: true });
      success(`Installed .agents/ralph to ${pc.cyan(localDir)}`);
    }
    const readmeSrc = path.join(repoRoot, "README.md");
    const diagramSrc = path.join(repoRoot, "diagram.svg");
    const imageSrc = path.join(repoRoot, "ralph.webp");
    if (exists(localDir)) {
      const readmeDst = path.join(localDir, "README.md");
      const diagramDst = path.join(localDir, "diagram.svg");
      const imageDst = path.join(localDir, "ralph.webp");
      if (exists(readmeSrc)) fs.copyFileSync(readmeSrc, readmeDst);
      if (exists(diagramSrc)) fs.copyFileSync(diagramSrc, diagramDst);
      if (exists(imageSrc)) fs.copyFileSync(imageSrc, imageDst);
    }
    if (installSkills) {
      await runInstallSkills();
    } else {
      const { confirm, isCancel } = await import("@clack/prompts");
      const wantsSkills = await confirm({
        message: "Install skills (commit + dev-browser + prd)?",
        initialValue: true,
      });
      if (isCancel(wantsSkills)) {
        dim("Skipped skills install.");
      } else if (wantsSkills) {
        await runInstallSkills();
      }
    }
    process.exit(0);
  }

  const templateDir = exists(localDir) ? localDir : globalDir;
  if (!exists(templateDir)) {
    error("No .agents/ralph found locally and no bundled defaults available.");
    process.exit(1);
  }
  if (templateDir === localDir) {
    info(`Using local templates: ${pc.dim(localDir)}`);
  } else {
    info(`Using bundled templates: ${pc.dim(globalDir)}`);
  }

  const loopPath = path.join(templateDir, "loop.sh");
  if (!exists(loopPath)) {
    error(`loop.sh not found at ${pc.cyan(loopPath)}`);
    process.exit(1);
  }

  const loopArgs = args.length ? args : ["build"];
  const loadAgentMap = () => {
    const defaults = {
      codex: "codex exec --yolo --skip-git-repo-check -",
      claude: "claude -p --dangerously-skip-permissions \"$(cat {prompt})\"",
      droid: "droid exec --skip-permissions-unsafe -f {prompt}",
    };
    const interactiveDefaults = {
      codex: "codex --yolo {prompt}",
      claude: "claude --dangerously-skip-permissions {prompt}",
      droid: "droid --skip-permissions-unsafe {prompt}",
    };
    const agentsPath = path.join(templateDir, "agents.sh");
    if (!exists(agentsPath)) {
      return {
        headless: defaults,
        interactive: interactiveDefaults,
        defaultAgent: "codex",
      };
    }
    const safePath = agentsPath.replace(/'/g, "'\\''");
    const bashCmd = [
      `source '${safePath}'`,
      'printf "DEFAULT_AGENT=%s\\n" "${DEFAULT_AGENT:-}"',
      'printf "AGENT_CODEX_CMD=%s\\n" "${AGENT_CODEX_CMD:-}"',
      'printf "AGENT_CLAUDE_CMD=%s\\n" "${AGENT_CLAUDE_CMD:-}"',
      'printf "AGENT_DROID_CMD=%s\\n" "${AGENT_DROID_CMD:-}"',
      'printf "AGENT_CODEX_INTERACTIVE_CMD=%s\\n" "${AGENT_CODEX_INTERACTIVE_CMD:-}"',
      'printf "AGENT_CLAUDE_INTERACTIVE_CMD=%s\\n" "${AGENT_CLAUDE_INTERACTIVE_CMD:-}"',
      'printf "AGENT_DROID_INTERACTIVE_CMD=%s\\n" "${AGENT_DROID_INTERACTIVE_CMD:-}"',
    ].join("; ");
    const result = spawnSync("bash", ["-lc", bashCmd], { encoding: "utf-8" });
    if (result.status !== 0) {
      return {
        headless: defaults,
        interactive: interactiveDefaults,
        defaultAgent: "codex",
      };
    }
    const parsed = new Map();
    for (const line of String(result.stdout || "").split("\n")) {
      if (!line) continue;
      const idx = line.indexOf("=");
      if (idx === -1) continue;
      parsed.set(line.slice(0, idx), line.slice(idx + 1));
    }
    const readVar = (name) => parsed.get(name) || null;
    return {
      headless: {
        codex: readVar("AGENT_CODEX_CMD") || defaults.codex,
        claude: readVar("AGENT_CLAUDE_CMD") || defaults.claude,
        droid: readVar("AGENT_DROID_CMD") || defaults.droid,
      },
      interactive: {
        codex: readVar("AGENT_CODEX_INTERACTIVE_CMD") || interactiveDefaults.codex,
        claude: readVar("AGENT_CLAUDE_INTERACTIVE_CMD") || interactiveDefaults.claude,
        droid: readVar("AGENT_DROID_INTERACTIVE_CMD") || interactiveDefaults.droid,
      },
      defaultAgent: readVar("DEFAULT_AGENT") || "codex",
    };
  };
  const agentDefs = loadAgentMap();
  const agentMap = agentDefs.headless;
  const agentInteractiveMap = agentDefs.interactive;
  const defaultAgent = agentDefs.defaultAgent || "codex";
  if (agentOverride) {
    const mapped = agentMap[agentOverride];
    if (!mapped) {
      error(`Unknown agent: ${pc.bold(agentOverride)}`);
      error(`Valid values: ${pc.cyan("codex")}, ${pc.cyan("claude")}, ${pc.cyan("droid")}`);
      process.exit(1);
    }
    process.env.AGENT_CMD = mapped;
  }
  const env = { ...process.env, RALPH_ROOT: cwd };
  if (!env.ACTIVITY_CMD) {
    env.ACTIVITY_CMD = "ralph log";
  }
  // PRD number takes precedence - sets paths to use PRD-N folder
  if (prdNumber) {
    env.PRD_NUMBER = prdNumber;
  }
  const resolvedPrdPath = prdOutPath || prdPath;
  if (resolvedPrdPath) env.PRD_PATH = resolvedPrdPath;
  if (planPath) env.PLAN_PATH = planPath;
  if (progressPath) env.PROGRESS_PATH = progressPath;
  if (templateDir === globalDir) {
    env.PROMPT_PLAN = path.join(templateDir, "PROMPT_plan.md");
    env.PROMPT_BUILD = path.join(templateDir, "PROMPT_build.md");
    env.GUARDRAILS_REF = path.join(templateDir, "references", "GUARDRAILS.md");
    env.CONTEXT_REF = path.join(templateDir, "references", "CONTEXT_ENGINEERING.md");
  }

  if (cmd === "ping") {
    const agentName = agentOverride || defaultAgent;
    const agentCmd = agentMap[agentName];
    if (!agentCmd) {
      error("Unknown agent for ping.");
      process.exit(1);
    }
    const agentBin = agentCmd.split(" ")[0];
    const existsResult = spawnSync(`command -v ${agentBin}`, { shell: true, stdio: "ignore" });
    if (existsResult.status !== 0) {
      error(`Agent command not found: ${pc.bold(agentBin)}`);
      process.exit(1);
    }
    const promptFile = path.join(os.tmpdir(), `ralph-ping-${Date.now()}.txt`);
    fs.writeFileSync(promptFile, "Reply with <end>pong</end> only.");
    const escapePath = (value) => `'${String(value).replace(/'/g, "'\\''")}'`;
    const rendered = agentCmd.includes("{prompt}")
      ? agentCmd.replace(/\{prompt\}/g, escapePath(promptFile))
      : `cat ${escapePath(promptFile)} | ${agentCmd}`;
    const result = spawnSync(rendered, { shell: true, encoding: "utf-8" });
    const output = `${result.stdout || ""}${result.stderr || ""}`;
    if (!output.includes("<end>pong</end>")) {
      error(`Ping failed: missing ${pc.bold("<end>pong</end>")}.`);
      process.exit(1);
    }
    success("Ping OK.");
    process.exit(0);
  }

  if (cmd === "log") {
    const message = args.slice(1).join(" ").trim();
    if (!message) {
      error(`Usage: ${pc.cyan('ralph log "message"')}`);
      process.exit(1);
    }
    const activityLog = path.join(cwd, ".ralph", "activity.log");
    fs.mkdirSync(path.dirname(activityLog), { recursive: true });
    const now = new Date();
    const pad = (n) => String(n).padStart(2, "0");
    const stamp = `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())} ${pad(now.getHours())}:${pad(now.getMinutes())}:${pad(now.getSeconds())}`;
    fs.appendFileSync(activityLog, `[${stamp}] ${message}\n`);
    process.exit(0);
  }

  if (cmd === "prd") {
    let request = args.slice(1).join(" ").trim();
    if (!request) {
      const { intro, outro, text, isCancel } = await import("@clack/prompts");
      intro("Ralph PRD");
      const response = await text({
        message: "Describe the feature you want a PRD for",
        placeholder: "Example: A lightweight uptime monitor with email alerts",
      });
      if (isCancel(response)) {
        outro("Cancelled.");
        process.exit(0);
      }
      request = String(response || "").trim();
      if (!request) {
        outro("No description provided.");
        process.exit(1);
      }
      outro("Generating PRD...");
    }
    const requestFile = path.join(os.tmpdir(), `ralph-prd-${Date.now()}.md`);
    fs.writeFileSync(requestFile, `${request}\n`);
    const agentName = agentOverride || defaultAgent;
    const prdAgent = agentInteractiveMap[agentName] || agentMap[agentName];
    if (prdAgent) {
      env.PRD_AGENT_CMD = prdAgent;
    }
    const prdArgs = ["prd", "--prompt", requestFile];
    const result = spawnSync(loopPath, prdArgs, {
      stdio: "inherit",
      env,
    });
    process.exit(result.status ?? 1);
  }

  if (cmd === "stream") {
    const streamPath = path.join(templateDir, "stream.sh");
    if (!exists(streamPath)) {
      error("stream.sh not found. Make sure Ralph is up to date.");
      process.exit(1);
    }
    const streamArgs = args.slice(1);
    const result = spawnSync(streamPath, streamArgs, {
      stdio: "inherit",
      env,
    });
    process.exit(result.status ?? 1);
  }

  if (cmd === "eval") {
    const evalModule = require("../lib/eval");
    const runsDir = path.join(cwd, ".ralph", "runs");
    const evalDir = path.join(cwd, ".ralph", "evaluations");

    // Check for --all flag
    const evalAll = args.includes("--all");
    const runIdArg = args.slice(1).find((a) => !a.startsWith("--"));

    if (!evalAll && !runIdArg) {
      error(`Usage: ${pc.cyan("ralph eval <run-id>")} or ${pc.cyan("ralph eval --all")}`);
      process.exit(1);
    }

    if (!exists(runsDir)) {
      error(`No runs found at ${pc.cyan(runsDir)}`);
      process.exit(1);
    }

    if (evalAll) {
      // Evaluate all runs
      info("Evaluating all runs...");
      const summaries = evalModule.listRunSummaries(runsDir);
      if (summaries.length === 0) {
        warn("No run summaries found.");
        process.exit(0);
      }

      const scores = [];
      for (const summaryPath of summaries) {
        const score = evalModule.scoreRun(summaryPath);
        if (score) {
          scores.push(score);

          // Generate individual report
          const report = evalModule.generateRunReport(score);
          const outputPath = path.join(evalDir, `eval-${score.runId}.md`);
          evalModule.saveReport(report, outputPath);
        }
      }

      // Generate and display summary
      const aggregate = evalModule.aggregateScores(scores);
      if (aggregate) {
        console.log("");
        console.log(pc.bold("Evaluation Summary"));
        console.log(pc.dim("─".repeat(50)));
        console.log(`Total Runs:      ${pc.bold(aggregate.totalRuns)}`);
        console.log(`Successful:      ${pc.green(aggregate.successCount)} (${aggregate.successRate}%)`);
        console.log(`Failed:          ${pc.red(aggregate.errorCount)}`);
        console.log(`Average Score:   ${pc.bold(aggregate.avgOverall)}/100 (${aggregate.grade})`);
        console.log(`Avg Duration:    ${evalModule.formatDuration(aggregate.avgDuration)}`);
        console.log(pc.dim("─".repeat(50)));
        console.log("");

        // Score breakdown
        console.log(pc.bold("Score Breakdown"));
        console.log(`  Success:       ${evalModule.scoreBar(aggregate.avgSuccess)}`);
        console.log(`  Verification:  ${evalModule.scoreBar(aggregate.avgVerification)}`);
        console.log(`  Commit:        ${evalModule.scoreBar(aggregate.avgCommit)}`);
        console.log(`  Efficiency:    ${evalModule.scoreBar(aggregate.avgEfficiency)}`);
        console.log("");

        // Common failure patterns
        if (aggregate.failurePatterns && aggregate.failurePatterns.length > 0) {
          console.log(pc.bold("Common Failure Patterns"));
          for (const { pattern, count } of aggregate.failurePatterns) {
            const readable = pattern.replace(/_/g, " ").replace(/errors (\d+)/, "$1 errors");
            console.log(`  - ${readable}: ${pc.yellow(count)}`);
          }
          console.log("");
        }

        // Save summary report
        const summaryReport = evalModule.generateSummaryReport(scores, aggregate);
        const summaryPath = path.join(evalDir, "summary.md");
        evalModule.saveReport(summaryReport, summaryPath);
        success(`Summary report saved to ${pc.cyan(summaryPath)}`);
      }
    } else {
      // Evaluate single run
      // Find matching run files
      const summaries = evalModule.listRunSummaries(runsDir);
      const matchingSummaries = summaries.filter((s) => s.includes(runIdArg));

      if (matchingSummaries.length === 0) {
        error(`No runs found matching "${pc.bold(runIdArg)}"`);
        process.exit(1);
      }

      if (matchingSummaries.length > 1) {
        warn(`Multiple runs match "${runIdArg}":`);
        for (const s of matchingSummaries) {
          console.log(`  - ${path.basename(s)}`);
        }
        info("Please provide a more specific run ID.");
        process.exit(1);
      }

      const summaryPath = matchingSummaries[0];
      const score = evalModule.scoreRun(summaryPath);

      if (!score) {
        error(`Failed to evaluate run at ${pc.cyan(summaryPath)}`);
        process.exit(1);
      }

      // Display results
      const grade = evalModule.gradeScore(score.overall);
      const gradeColor = grade === "A" ? pc.green : grade === "B" ? pc.blue : grade === "C" ? pc.yellow : grade === "D" ? pc.magenta : pc.red;

      console.log("");
      console.log(pc.bold(`Evaluation: ${score.runId}`));
      console.log(pc.dim("─".repeat(50)));
      console.log(`Grade:           ${gradeColor(pc.bold(grade))} (${score.overall}/100)`);
      console.log(`Status:          ${score.status === "success" ? pc.green(score.status) : pc.red(score.status)}`);
      console.log(`Mode:            ${score.mode || "N/A"}`);
      console.log(`Story:           ${score.story || "N/A"}`);
      console.log(`Duration:        ${evalModule.formatDuration(score.duration)}`);
      console.log(pc.dim("─".repeat(50)));
      console.log("");

      console.log(pc.bold("Scores"));
      console.log(`  Success:       ${evalModule.scoreBar(score.successScore)}`);
      console.log(`  Verification:  ${evalModule.scoreBar(score.verificationScore)}`);
      console.log(`  Commit:        ${evalModule.scoreBar(score.commitScore)}`);
      console.log(`  Efficiency:    ${evalModule.scoreBar(score.efficiencyScore)}`);
      console.log("");

      console.log(pc.bold("Details"));
      console.log(`  Commits:       ${score.details.commitCount}`);
      console.log(`  Files changed: ${score.details.changedFilesCount}`);
      console.log(`  Clean tree:    ${score.details.hasUncommittedChanges ? pc.yellow("No") : pc.green("Yes")}`);
      console.log(`  Tests passed:  ${score.details.verificationsPassed}`);
      console.log(`  Tests failed:  ${score.details.verificationsFailed}`);
      console.log(`  Errors:        ${score.details.errorCount}`);
      console.log("");

      // Generate and save report
      const report = evalModule.generateRunReport(score);
      const outputPath = path.join(evalDir, `eval-${score.runId}.md`);
      evalModule.saveReport(report, outputPath);
      success(`Report saved to ${pc.cyan(outputPath)}`);
    }

    process.exit(0);
  }

  if (cmd === "improve") {
    const improveModule = require("../lib/improve");
    const runsDir = path.join(cwd, ".ralph", "runs");
    const errorsLog = path.join(cwd, ".ralph", "errors.log");
    const candidatesDir = path.join(cwd, ".ralph", "candidates");
    const pendingPath = path.join(candidatesDir, "guardrails-pending.md");
    const guardrailsPath = path.join(cwd, ".ralph", "guardrails.md");

    const generateFlag = args.includes("--generate");
    const applyFlag = args.includes("--apply");

    // If --generate flag, regenerate candidates
    if (generateFlag) {
      info("Analyzing runs for failure patterns...");

      if (!exists(runsDir)) {
        warn("No runs directory found. Run some iterations first.");
        process.exit(0);
      }

      const candidates = improveModule.analyzeAndGenerate(runsDir, errorsLog, {
        minOccurrences: 1,
      });

      if (candidates.length === 0) {
        success("No significant failure patterns detected.");
        process.exit(0);
      }

      improveModule.saveCandidates(candidates, pendingPath);
      success(`Generated ${pc.bold(candidates.length)} guardrail candidates.`);
      info(`Candidates saved to ${pc.cyan(pendingPath)}`);
      console.log("");
      console.log("Run " + pc.cyan("ralph improve") + " to review and apply them.");
      process.exit(0);
    }

    // Check for existing candidates
    let candidates = improveModule.loadCandidates(pendingPath);

    if (candidates.length === 0 && !applyFlag) {
      // Auto-generate candidates if none exist
      info("No pending candidates. Analyzing runs for failure patterns...");

      if (!exists(runsDir)) {
        warn("No runs directory found. Run some iterations first.");
        process.exit(0);
      }

      candidates = improveModule.analyzeAndGenerate(runsDir, errorsLog, {
        minOccurrences: 1,
      });

      if (candidates.length === 0) {
        success("No significant failure patterns detected.");
        process.exit(0);
      }

      improveModule.saveCandidates(candidates, pendingPath);
      info(`Generated ${pc.bold(candidates.length)} guardrail candidates.`);
    }

    if (candidates.length === 0) {
      success("No pending guardrail candidates to review.");
      process.exit(0);
    }

    // Interactive review
    const { intro, outro, select, confirm, isCancel } = await import("@clack/prompts");
    intro("Ralph Guardrail Review");

    console.log("");
    console.log(pc.bold(`Found ${candidates.length} guardrail candidate(s) to review.`));
    console.log("");

    const accepted = [];
    const rejected = [];

    for (const candidate of candidates) {
      console.log(pc.dim("─".repeat(60)));
      console.log(pc.bold(pc.cyan(`Candidate: ${candidate.title}`)));
      console.log("");
      console.log(`  ${pc.yellow("Trigger:")}     ${candidate.trigger}`);
      console.log(`  ${pc.yellow("Instruction:")} ${candidate.instruction}`);
      console.log(`  ${pc.yellow("Context:")}     ${candidate.context}`);
      console.log("");
      console.log(pc.dim(`  Occurrences: ${candidate.occurrences}`));
      console.log(pc.dim(`  Affected runs: ${candidate.affectedRuns.slice(0, 3).join(", ")}${candidate.affectedRuns.length > 3 ? "..." : ""}`));
      console.log("");

      const action = await select({
        message: "Apply this guardrail?",
        options: [
          { value: "accept", label: "Yes, add to guardrails.md" },
          { value: "skip", label: "Skip for now" },
          { value: "reject", label: "Reject (remove from candidates)" },
        ],
      });

      if (isCancel(action)) {
        outro("Cancelled. Progress saved.");
        // Save remaining candidates
        const remaining = candidates.filter(
          (c) => !accepted.find((a) => a.id === c.id) && !rejected.find((r) => r.id === c.id)
        );
        improveModule.saveCandidates(remaining, pendingPath);
        process.exit(0);
      }

      if (action === "accept") {
        accepted.push(candidate);
        success(`  ✓ Accepted: ${candidate.title}`);
      } else if (action === "reject") {
        rejected.push(candidate);
        dim(`  ✗ Rejected: ${candidate.title}`);
      } else {
        dim(`  ○ Skipped: ${candidate.title}`);
      }
    }

    // Apply accepted guardrails
    if (accepted.length > 0) {
      console.log("");
      info(`Applying ${accepted.length} guardrail(s) to ${pc.cyan(guardrailsPath)}...`);

      // Ensure guardrails file exists
      if (!exists(guardrailsPath)) {
        fs.mkdirSync(path.dirname(guardrailsPath), { recursive: true });
        fs.writeFileSync(guardrailsPath, `# Guardrails (Signs)\n\n> Lessons learned from failures. Read before acting.\n\n## Learned Signs\n\n`);
      }

      const acceptedAt = new Date().toISOString();
      let guardrailsContent = fs.readFileSync(guardrailsPath, "utf-8");

      for (const candidate of accepted) {
        const entry = improveModule.formatGuardrailEntry(candidate, acceptedAt);
        guardrailsContent += "\n" + entry;
      }

      fs.writeFileSync(guardrailsPath, guardrailsContent);
      success(`Added ${accepted.length} guardrail(s) to ${pc.cyan("guardrails.md")}`);
    }

    // Update pending candidates (remove accepted and rejected)
    const remaining = candidates.filter(
      (c) => !accepted.find((a) => a.id === c.id) && !rejected.find((r) => r.id === c.id)
    );
    improveModule.saveCandidates(remaining, pendingPath);

    console.log("");
    outro(`Done. ${accepted.length} applied, ${rejected.length} rejected, ${remaining.length} pending.`);
    process.exit(0);
  }

  const result = spawnSync(loopPath, loopArgs, {
    stdio: "inherit",
    env,
  });

  process.exit(result.status ?? 1);
}

main().catch((err) => {
  error(err.message || err);
  process.exit(1);
});
