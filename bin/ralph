#!/usr/bin/env node
const { spawnSync } = require("child_process");
const fs = require("fs");
const os = require("os");
const path = require("path");
const pc = require("picocolors");

// Color helper functions for consistent output
const success = (msg) => console.log(pc.green(msg));
const error = (msg) => console.error(pc.red(msg));
const info = (msg) => console.log(pc.cyan(msg));
const dim = (msg) => console.log(pc.dim(msg));
const warn = (msg) => console.log(pc.yellow(msg));

const rawArgs = process.argv.slice(2);
const args = [];
const cwd = process.cwd();
const repoRoot = path.resolve(__dirname, "..");
const globalDir = path.join(repoRoot, ".agents", "ralph");
const localDir = path.join(cwd, ".agents", "ralph");
const skillsRoot = path.join(repoRoot, "skills");
let agentOverride = null;
let installSkills = false;
let installForce = false;
let importFromProject = null;  // For --import-from flag in install command
let prdPath = null;
let prdNumber = null;  // PRD number for folder-based storage (e.g., --prd=1 uses PRD-1)
let planPath = null;
let progressPath = null;
let prdOutPath = null;
let uiOpenBrowser = false;  // For --open flag in ui command
let estimatePricing = null;  // For --pricing flag in estimate command (format: "input:X,output:Y")
let estimateModel = null;  // For --model flag in estimate command
let noRetry = false;  // For --no-retry flag to disable automatic retries

function exists(p) {
  try {
    fs.accessSync(p);
    return true;
  } catch {
    return false;
  }
}

function usage() {
  console.log(`${pc.bold("ralph")} ${pc.dim("<command>")}

${pc.bold(pc.cyan("Commands:"))}
  ${pc.green("install")} ${pc.dim("[--skills] [--import-from]")}   Copy .agents/ralph into the current repo
  ${pc.green("init")}                                 Interactive setup wizard for new projects
  ${pc.green("prd")} ${pc.dim("[\"<request>\"] [--out path]")}      Generate a PRD via agent
  ${pc.green("ping")}                                Minimal agent health check
  ${pc.green("log")} ${pc.dim("\"<message>\"")}                     Append to .ralph/activity.log
  ${pc.green("build")} ${pc.dim("[n] [--no-commit] [--no-retry]")} Run build loop (default)
  ${pc.green("plan")} ${pc.dim("[n]")}                            Run planning loop
  ${pc.green("stream")} ${pc.dim("<subcmd>")}                     Multi-stream parallel execution
  ${pc.green("eval")} ${pc.dim("[run-id] [--all]")}               Evaluate run quality and generate reports
  ${pc.green("estimate")} ${pc.dim("[--prd=N] [--json] [--pricing] [--accuracy]")}  Estimate time and cost for a PRD build
  ${pc.green("improve")} ${pc.dim("[--generate] [--apply]")}       Review and apply guardrail candidates
  ${pc.green("registry")} ${pc.dim("<subcmd>")}                    Cross-project knowledge registry
  ${pc.green("search")} ${pc.dim("<query> [--filters]")}           Search across all registered projects
  ${pc.green("import")} ${pc.dim("<type> [--from project]")}       Import knowledge from another project
  ${pc.green("stats")} ${pc.dim("[--global] [--json]")}            Performance metrics dashboard
  ${pc.green("optimize")} ${pc.dim("<type> [--apply]")}            Analyze and improve prompt templates
  ${pc.green("diagnose")} ${pc.dim("[--run id] [--json]")}         Detect failure patterns and suggest fixes
  ${pc.green("doctor")} ${pc.dim("[--verbose] [--json] [--fix]")}  Environment and setup diagnostics
  ${pc.green("ui")} ${pc.dim("[port] [--open]")}                   Start the Ralph UI server
  ${pc.green("experiment")} ${pc.dim("<subcmd>")}                  A/B testing framework for agents
  ${pc.green("help")}                                Show this message

${pc.bold(pc.cyan("Registry commands:"))}
  ${pc.green("registry add")} ${pc.dim("[--tags t1,t2]")}          Register current project
  ${pc.green("registry list")} ${pc.dim("[--tags t1,t2]")}         List registered projects
  ${pc.green("registry remove")}                      Remove current project from registry
  ${pc.green("registry update")}                      Update project metadata and stats

${pc.bold(pc.cyan("Import commands:"))}
  ${pc.green("import guardrails")} ${pc.dim("[--from project]")}   Import guardrails from another project
  ${pc.green("import guardrails")} ${pc.dim("--all")}              Import all guardrails from selected project

${pc.bold(pc.cyan("Optimize commands:"))}
  ${pc.green("optimize prompts")}                    Analyze prompt effectiveness and generate suggestions
  ${pc.green("optimize prompts")} ${pc.dim("--apply")}           Apply selected suggestions to templates
  ${pc.green("optimize prompts")} ${pc.dim("--versions")}        Show prompt version effectiveness comparison

${pc.bold(pc.cyan("Stats options:"))}
  ${pc.yellow("--global")} ${pc.dim("(-g)")}                       Show metrics across all registered projects
  ${pc.yellow("--json")}                             Output metrics as JSON for tooling
  ${pc.yellow("--no-cache")}                         Regenerate metrics (ignore cache)
  ${pc.yellow("--tokens")}                           Show token usage and cost metrics

${pc.bold(pc.cyan("Search options:"))}
  ${pc.yellow("--project")} ${pc.dim("<name>")}                    Filter by project name
  ${pc.yellow("--type")} ${pc.dim("<type>")}                       Filter by type (guardrail|progress|evaluation|run)
  ${pc.yellow("--tags")} ${pc.dim("t1,t2")}                        Filter by project tags
  ${pc.yellow("--since")} ${pc.dim("<date|Nd|Nw|Nm>")}             Filter by date (e.g., 7d, 2w, 1m)
  ${pc.yellow("--limit")} ${pc.dim("<N>")}                         Max results (default 20)
  ${pc.yellow("--rebuild")}                           Rebuild search index before searching

${pc.bold(pc.cyan("Estimate options:"))}
  ${pc.yellow("--prd")} ${pc.dim("<N>")}                           Estimate specific PRD (default: active PRD)
  ${pc.yellow("--json")}                             Output as JSON for machine parsing
  ${pc.yellow("--pricing")} ${pc.dim("input:X,output:Y")}          Custom token pricing ($/1M tokens)
  ${pc.yellow("--model")} ${pc.dim("<opus|sonnet|haiku>")}         Model for cost calculation (default: sonnet)

${pc.bold(pc.cyan("Retry options:"))}
  ${pc.yellow("--no-retry")}                         Disable automatic retries on agent failure
  ${pc.dim("Environment variables (set in config.sh or shell):")}
  ${pc.dim("  RETRY_MAX_ATTEMPTS=3                Max retry attempts (default: 3)")}
  ${pc.dim("  RETRY_BASE_DELAY_MS=1000            Base delay for backoff (default: 1000ms)")}
  ${pc.dim("  RETRY_MAX_DELAY_MS=16000            Max delay cap (default: 16000ms)")}

${pc.bold(pc.cyan("Diagnose options:"))}
  ${pc.yellow("--run")} ${pc.dim("<run-id>")}                      Analyze a specific run only
  ${pc.yellow("--json")}                             Output results as JSON
  ${pc.yellow("--limit")} ${pc.dim("<N>")}                         Max errors to analyze (default 500)

${pc.bold(pc.cyan("Doctor options:"))}
  ${pc.yellow("--verbose")} ${pc.dim("(-v)")}                      Show detailed output with file paths
  ${pc.yellow("--json")}                             Output results as JSON
  ${pc.yellow("--fix")}                              Attempt automatic repairs

${pc.bold(pc.cyan("UI options:"))}
  ${pc.yellow("[port]")}                             Port number (default 3000)
  ${pc.yellow("--open")}                             Open browser automatically after starting

${pc.bold(pc.cyan("Stream commands:"))}
  ${pc.green("stream new")}                          Create new stream (prd-1, prd-2, ...)
  ${pc.green("stream list")}                         List all streams
  ${pc.green("stream status")}                       Show detailed status
  ${pc.green("stream init")} ${pc.dim("<N>")}                     Initialize worktree for parallel execution
  ${pc.green("stream build")} ${pc.dim("<N> [n]")}                Run n build iterations in stream
  ${pc.green("stream merge")} ${pc.dim("<N>")}                    Merge completed stream to main
  ${pc.green("stream cleanup")} ${pc.dim("<N>")}                  Remove stream worktree

${pc.bold(pc.cyan("Experiment commands:"))}
  ${pc.green("experiment create")} ${pc.dim("<name>")}            Create a new A/B experiment
  ${pc.green("experiment list")}                     List all experiments
  ${pc.green("experiment status")} ${pc.dim("<name>")}            Show experiment status and stats
  ${pc.green("experiment start")} ${pc.dim("<name>")}             Start an experiment
  ${pc.green("experiment pause")} ${pc.dim("<name>")}             Pause an experiment
  ${pc.green("experiment conclude")} ${pc.dim("<name>")}          Conclude an experiment
  ${pc.green("experiment analyze")} ${pc.dim("<name>")}           Analyze results with statistics

${pc.bold(pc.cyan("Analyze options:"))}
  ${pc.yellow("--json")}                             Export results as JSON
  ${pc.yellow("--csv")}                              Export results as CSV
  ${pc.yellow("--confidence")} ${pc.dim("<N>")}                   Min confidence % for winner (default: 95)

${pc.bold(pc.cyan("Options:"))}
  ${pc.yellow("--prd")} ${pc.dim("<N|path>")}                      Use PRD-N folder (e.g., --prd=1) or custom path
  ${pc.yellow("--out")} ${pc.dim("<path>")}                        Override PRD output path (prd command)
  ${pc.yellow("--plan")} ${pc.dim("<path>")}                       Override plan path
  ${pc.yellow("--progress")} ${pc.dim("<path>")}                   Override progress log path
  ${pc.yellow("--agent")} ${pc.dim("<codex|claude|droid>")}        Override agent runner
  ${pc.yellow("--import-from")} ${pc.dim("<project>")}             Import guardrails during install

${pc.bold(pc.cyan("Notes:"))}
${pc.dim("- Uses local .agents/ralph if present; otherwise uses bundled defaults.")}
${pc.dim("- State and logs are written to .ralph/ in the project.")}
`);
}

for (let i = 0; i < rawArgs.length; i += 1) {
  const arg = rawArgs[i];
  if (arg.startsWith("--agent=")) {
    agentOverride = arg.split("=").slice(1).join("=");
    continue;
  }
  if (arg === "--agent") {
    agentOverride = rawArgs[i + 1];
    i += 1;
    continue;
  }
  if (arg === "--skills") {
    installSkills = true;
    continue;
  }
  if (arg === "--force") {
    installForce = true;
    continue;
  }
  if (arg.startsWith("--import-from=")) {
    importFromProject = arg.split("=").slice(1).join("=");
    continue;
  }
  if (arg === "--import-from") {
    importFromProject = rawArgs[i + 1];
    i += 1;
    continue;
  }
  if (arg.startsWith("--prd=")) {
    const prdValue = arg.split("=").slice(1).join("=");
    // Check if it's a number (PRD folder) or a path
    if (/^\d+$/.test(prdValue)) {
      prdNumber = prdValue;
    } else {
      prdPath = prdValue;
    }
    continue;
  }
  if (arg.startsWith("--out=")) {
    prdOutPath = arg.split("=").slice(1).join("=");
    continue;
  }
  if (arg === "--prd") {
    const prdValue = rawArgs[i + 1];
    // Check if it's a number (PRD folder) or a path
    if (/^\d+$/.test(prdValue)) {
      prdNumber = prdValue;
    } else {
      prdPath = prdValue;
    }
    i += 1;
    continue;
  }
  if (arg === "--out") {
    prdOutPath = rawArgs[i + 1];
    i += 1;
    continue;
  }
  if (arg.startsWith("--plan=")) {
    planPath = arg.split("=").slice(1).join("=");
    continue;
  }
  if (arg === "--plan") {
    planPath = rawArgs[i + 1];
    i += 1;
    continue;
  }
  if (arg.startsWith("--progress=")) {
    progressPath = arg.split("=").slice(1).join("=");
    continue;
  }
  // Skip --tags and its value (handled per-command)
  if (arg.startsWith("--tags=")) {
    continue;
  }
  if (arg === "--tags") {
    i += 1; // Skip the value too
    continue;
  }
  if (arg === "--progress") {
    progressPath = rawArgs[i + 1];
    i += 1;
    continue;
  }
  if (arg === "--open") {
    uiOpenBrowser = true;
    continue;
  }
  // Parse --pricing flag for estimate command (format: "input:X,output:Y")
  if (arg.startsWith("--pricing=")) {
    estimatePricing = arg.split("=").slice(1).join("=");
    continue;
  }
  if (arg === "--pricing") {
    estimatePricing = rawArgs[i + 1];
    i += 1;
    continue;
  }
  // Parse --model flag for estimate command
  if (arg.startsWith("--model=")) {
    estimateModel = arg.split("=").slice(1).join("=");
    continue;
  }
  if (arg === "--model") {
    estimateModel = rawArgs[i + 1];
    i += 1;
    continue;
  }
  // Parse --no-retry flag to disable automatic retries
  if (arg === "--no-retry") {
    noRetry = true;
    continue;
  }
  args.push(arg);
}

const cmd = args[0];
if (cmd === "help" || cmd === "-h" || cmd === "--help") {
  usage();
  process.exit(0);
}

async function runInstallSkills() {
  const { intro, outro, select, isCancel } = await import("@clack/prompts");
  intro("Ralph skills install");

  const agent = await select({
    message: "Which agent are you using?",
    options: [
      { value: "codex", label: "codex" },
      { value: "claude", label: "claude" },
      { value: "droid", label: "droid" },
    ],
    initialValue: agentOverride || "codex",
  });
  if (isCancel(agent)) {
    outro("Cancelled.");
    process.exit(0);
  }

  const scope = await select({
    message: "Where should skills be installed?",
    options: [
      { value: "local", label: "Local (project)" },
      { value: "global", label: "Global (home directory)" },
    ],
    initialValue: "local",
  });
  if (isCancel(scope)) {
    outro("Cancelled.");
    process.exit(0);
  }

  const home = os.homedir();
  const targetRoot =
    agent === "codex"
      ? scope === "global"
        ? path.join(home, ".codex", "skills")
        : path.join(cwd, ".codex", "skills")
      : agent === "claude"
        ? scope === "global"
          ? path.join(home, ".claude", "skills")
          : path.join(cwd, ".claude", "skills")
        : scope === "global"
          ? path.join(home, ".factory", "skills")
          : path.join(cwd, ".factory", "skills");

  const skillsToInstall = ["commit", "dev-browser", "prd"];
  fs.mkdirSync(targetRoot, { recursive: true });
  const installed = [];
  const skipped = [];

  for (const skill of skillsToInstall) {
    const source = path.join(skillsRoot, skill);
    const target = path.join(targetRoot, skill);
    if (!exists(source)) {
      skipped.push(`${skill} (missing in repo)`);
      continue;
    }
    if (exists(target) && !installForce) {
      skipped.push(`${skill} (already exists)`);
      continue;
    }
    fs.cpSync(source, target, { recursive: true, force: true });
    installed.push(skill);
  }

  if (installed.length) {
    success(`Installed skills to ${pc.cyan(targetRoot)}: ${installed.join(", ")}`);
  }
  if (skipped.length) {
    dim(`Skipped: ${skipped.join(", ")}`);
  }
  outro("Done.");
}

async function main() {
  if (cmd === "install") {
    if (exists(localDir) && !installForce) {
      dim(`.agents/ralph already exists at ${pc.cyan(localDir)}. Skipping templates.`);
    } else {
      if (!exists(globalDir)) {
        error(`Bundled templates not found at ${pc.cyan(globalDir)}.`);
        process.exit(1);
      }
      fs.mkdirSync(path.dirname(localDir), { recursive: true });
      fs.cpSync(globalDir, localDir, { recursive: true, force: true });
      success(`Installed .agents/ralph to ${pc.cyan(localDir)}`);
    }
    const readmeSrc = path.join(repoRoot, "README.md");
    const diagramSrc = path.join(repoRoot, "diagram.svg");
    const imageSrc = path.join(repoRoot, "ralph.webp");
    if (exists(localDir)) {
      const readmeDst = path.join(localDir, "README.md");
      const diagramDst = path.join(localDir, "diagram.svg");
      const imageDst = path.join(localDir, "ralph.webp");
      if (exists(readmeSrc)) fs.copyFileSync(readmeSrc, readmeDst);
      if (exists(diagramSrc)) fs.copyFileSync(diagramSrc, diagramDst);
      if (exists(imageSrc)) fs.copyFileSync(imageSrc, imageDst);
    }
    if (installSkills) {
      await runInstallSkills();
    } else {
      // Try interactive prompt, skip if no TTY
      try {
        const { confirm, isCancel } = await import("@clack/prompts");
        const wantsSkills = await confirm({
          message: "Install skills (commit + dev-browser + prd)?",
          initialValue: true,
        });
        if (isCancel(wantsSkills)) {
          dim("Skipped skills install.");
        } else if (wantsSkills) {
          await runInstallSkills();
        }
      } catch {
        dim("Skipped skills install (non-interactive).");
      }
    }

    // Handle --import-from flag for guardrail import
    if (importFromProject) {
      const importModule = require("../lib/import");
      const registryModule = require("../lib/registry");

      // Ensure registry exists
      registryModule.ensureGlobalRegistry();

      // Find source project
      const projects = registryModule.listProjects();
      const sourceProject = projects.find(
        (p) =>
          p.name.toLowerCase() === importFromProject.toLowerCase() ||
          p.id === importFromProject
      );

      if (!sourceProject) {
        warn(`Project not found: ${pc.bold(importFromProject)}`);
        if (projects.length > 0) {
          info("Available projects:");
          for (const p of projects.slice(0, 5)) {
            dim(`  - ${p.name} (${p.id})`);
          }
        }
      } else {
        info(`Importing guardrails from ${pc.bold(sourceProject.name)}...`);
        const guardrails = importModule.getProjectGuardrails(sourceProject.path);

        if (guardrails.length === 0) {
          dim(`No guardrails found in ${sourceProject.name}.`);
        } else {
          const result = importModule.importGuardrails(guardrails, cwd, sourceProject.name);
          if (result.imported > 0) {
            success(`Imported ${pc.bold(result.imported)} guardrail(s) from ${pc.cyan(sourceProject.name)}`);
          }
          if (result.skipped > 0) {
            dim(`Skipped ${result.skipped} duplicate(s).`);
          }
        }
      }
    }

    process.exit(0);
  }

  if (cmd === "init") {
    const initModule = require("../lib/init");

    try {
      const result = await initModule.runWizard(cwd);
      if (result.cancelled) {
        process.exit(0);
      }
      process.exit(0);
    } catch (err) {
      // Handle non-TTY gracefully
      if (err.code === "ERR_USE_AFTER_CLOSE" || !process.stdin.isTTY) {
        error("init requires an interactive terminal.");
        dim("Run this command in a terminal that supports user input.");
        process.exit(1);
      }
      throw err;
    }
  }

  const templateDir = exists(localDir) ? localDir : globalDir;
  if (!exists(templateDir)) {
    error("No .agents/ralph found locally and no bundled defaults available.");
    process.exit(1);
  }
  if (templateDir === localDir) {
    info(`Using local templates: ${pc.dim(localDir)}`);
  } else {
    info(`Using bundled templates: ${pc.dim(globalDir)}`);
  }

  const loopPath = path.join(templateDir, "loop.sh");
  if (!exists(loopPath)) {
    error(`loop.sh not found at ${pc.cyan(loopPath)}`);
    process.exit(1);
  }

  const loopArgs = args.length ? args : ["build"];
  const loadAgentMap = () => {
    const defaults = {
      codex: "codex exec --yolo --skip-git-repo-check -",
      claude: "claude -p --dangerously-skip-permissions \"$(cat {prompt})\"",
      droid: "droid exec --skip-permissions-unsafe -f {prompt}",
    };
    const interactiveDefaults = {
      codex: "codex --yolo {prompt}",
      claude: "claude --dangerously-skip-permissions {prompt}",
      droid: "droid --skip-permissions-unsafe {prompt}",
    };
    const agentsPath = path.join(templateDir, "agents.sh");
    if (!exists(agentsPath)) {
      return {
        headless: defaults,
        interactive: interactiveDefaults,
        defaultAgent: "codex",
      };
    }
    const safePath = agentsPath.replace(/'/g, "'\\''");
    const bashCmd = [
      `source '${safePath}'`,
      'printf "DEFAULT_AGENT=%s\\n" "${DEFAULT_AGENT:-}"',
      'printf "AGENT_CODEX_CMD=%s\\n" "${AGENT_CODEX_CMD:-}"',
      'printf "AGENT_CLAUDE_CMD=%s\\n" "${AGENT_CLAUDE_CMD:-}"',
      'printf "AGENT_DROID_CMD=%s\\n" "${AGENT_DROID_CMD:-}"',
      'printf "AGENT_CODEX_INTERACTIVE_CMD=%s\\n" "${AGENT_CODEX_INTERACTIVE_CMD:-}"',
      'printf "AGENT_CLAUDE_INTERACTIVE_CMD=%s\\n" "${AGENT_CLAUDE_INTERACTIVE_CMD:-}"',
      'printf "AGENT_DROID_INTERACTIVE_CMD=%s\\n" "${AGENT_DROID_INTERACTIVE_CMD:-}"',
    ].join("; ");
    const result = spawnSync("bash", ["-lc", bashCmd], { encoding: "utf-8" });
    if (result.status !== 0) {
      return {
        headless: defaults,
        interactive: interactiveDefaults,
        defaultAgent: "codex",
      };
    }
    const parsed = new Map();
    for (const line of String(result.stdout || "").split("\n")) {
      if (!line) continue;
      const idx = line.indexOf("=");
      if (idx === -1) continue;
      parsed.set(line.slice(0, idx), line.slice(idx + 1));
    }
    const readVar = (name) => parsed.get(name) || null;
    return {
      headless: {
        codex: readVar("AGENT_CODEX_CMD") || defaults.codex,
        claude: readVar("AGENT_CLAUDE_CMD") || defaults.claude,
        droid: readVar("AGENT_DROID_CMD") || defaults.droid,
      },
      interactive: {
        codex: readVar("AGENT_CODEX_INTERACTIVE_CMD") || interactiveDefaults.codex,
        claude: readVar("AGENT_CLAUDE_INTERACTIVE_CMD") || interactiveDefaults.claude,
        droid: readVar("AGENT_DROID_INTERACTIVE_CMD") || interactiveDefaults.droid,
      },
      defaultAgent: readVar("DEFAULT_AGENT") || "codex",
    };
  };
  const agentDefs = loadAgentMap();
  const agentMap = agentDefs.headless;
  const agentInteractiveMap = agentDefs.interactive;
  const defaultAgent = agentDefs.defaultAgent || "codex";
  if (agentOverride) {
    const mapped = agentMap[agentOverride];
    if (!mapped) {
      error(`Unknown agent: ${pc.bold(agentOverride)}`);
      error(`Valid values: ${pc.cyan("codex")}, ${pc.cyan("claude")}, ${pc.cyan("droid")}`);
      process.exit(1);
    }
    process.env.AGENT_CMD = mapped;
  }
  const env = { ...process.env, RALPH_ROOT: cwd };
  if (!env.ACTIVITY_CMD) {
    env.ACTIVITY_CMD = "ralph log";
  }
  // PRD number takes precedence - sets paths to use PRD-N folder
  if (prdNumber) {
    env.PRD_NUMBER = prdNumber;
  }
  const resolvedPrdPath = prdOutPath || prdPath;
  if (resolvedPrdPath) env.PRD_PATH = resolvedPrdPath;
  if (planPath) env.PLAN_PATH = planPath;
  if (progressPath) env.PROGRESS_PATH = progressPath;
  // Pass --no-retry flag to disable automatic retries
  if (noRetry) env.NO_RETRY = "true";
  if (templateDir === globalDir) {
    env.PROMPT_PLAN = path.join(templateDir, "PROMPT_plan.md");
    env.PROMPT_BUILD = path.join(templateDir, "PROMPT_build.md");
    env.GUARDRAILS_REF = path.join(templateDir, "references", "GUARDRAILS.md");
    env.CONTEXT_REF = path.join(templateDir, "references", "CONTEXT_ENGINEERING.md");
  }

  if (cmd === "ping") {
    const agentName = agentOverride || defaultAgent;
    const agentCmd = agentMap[agentName];
    if (!agentCmd) {
      error("Unknown agent for ping.");
      process.exit(1);
    }
    const agentBin = agentCmd.split(" ")[0];
    const existsResult = spawnSync(`command -v ${agentBin}`, { shell: true, stdio: "ignore" });
    if (existsResult.status !== 0) {
      error(`Agent command not found: ${pc.bold(agentBin)}`);
      process.exit(1);
    }
    const promptFile = path.join(os.tmpdir(), `ralph-ping-${Date.now()}.txt`);
    fs.writeFileSync(promptFile, "Reply with <end>pong</end> only.");
    const escapePath = (value) => `'${String(value).replace(/'/g, "'\\''")}'`;
    const rendered = agentCmd.includes("{prompt}")
      ? agentCmd.replace(/\{prompt\}/g, escapePath(promptFile))
      : `cat ${escapePath(promptFile)} | ${agentCmd}`;
    const result = spawnSync(rendered, { shell: true, encoding: "utf-8" });
    const output = `${result.stdout || ""}${result.stderr || ""}`;
    if (!output.includes("<end>pong</end>")) {
      error(`Ping failed: missing ${pc.bold("<end>pong</end>")}.`);
      process.exit(1);
    }
    success("Ping OK.");
    process.exit(0);
  }

  if (cmd === "log") {
    const message = args.slice(1).join(" ").trim();
    if (!message) {
      error(`Usage: ${pc.cyan('ralph log "message"')}`);
      process.exit(1);
    }
    const activityLog = path.join(cwd, ".ralph", "activity.log");
    fs.mkdirSync(path.dirname(activityLog), { recursive: true });
    const now = new Date();
    const pad = (n) => String(n).padStart(2, "0");
    const stamp = `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())} ${pad(now.getHours())}:${pad(now.getMinutes())}:${pad(now.getSeconds())}`;
    fs.appendFileSync(activityLog, `[${stamp}] ${message}\n`);
    process.exit(0);
  }

  if (cmd === "prd") {
    let request = args.slice(1).join(" ").trim();
    if (!request) {
      const { intro, outro, text, isCancel } = await import("@clack/prompts");
      intro("Ralph PRD");
      const response = await text({
        message: "Describe the feature you want a PRD for",
        placeholder: "Example: A lightweight uptime monitor with email alerts",
      });
      if (isCancel(response)) {
        outro("Cancelled.");
        process.exit(0);
      }
      request = String(response || "").trim();
      if (!request) {
        outro("No description provided.");
        process.exit(1);
      }
      outro("Generating PRD...");
    }
    const requestFile = path.join(os.tmpdir(), `ralph-prd-${Date.now()}.md`);
    fs.writeFileSync(requestFile, `${request}\n`);
    const agentName = agentOverride || defaultAgent;
    const prdAgent = agentInteractiveMap[agentName] || agentMap[agentName];
    if (prdAgent) {
      env.PRD_AGENT_CMD = prdAgent;
    }
    const prdArgs = ["prd", "--prompt", requestFile];
    const result = spawnSync(loopPath, prdArgs, {
      stdio: "inherit",
      env,
    });
    process.exit(result.status ?? 1);
  }

  if (cmd === "stream") {
    const streamPath = path.join(templateDir, "stream.sh");
    if (!exists(streamPath)) {
      error("stream.sh not found. Make sure Ralph is up to date.");
      process.exit(1);
    }
    const streamArgs = args.slice(1);
    const result = spawnSync(streamPath, streamArgs, {
      stdio: "inherit",
      env,
    });
    process.exit(result.status ?? 1);
  }

  if (cmd === "eval") {
    const evalModule = require("../lib/eval");
    const runsDir = path.join(cwd, ".ralph", "runs");
    const evalDir = path.join(cwd, ".ralph", "evaluations");

    // Check for --all flag
    const evalAll = args.includes("--all");
    const runIdArg = args.slice(1).find((a) => !a.startsWith("--"));

    if (!evalAll && !runIdArg) {
      error(`Usage: ${pc.cyan("ralph eval <run-id>")} or ${pc.cyan("ralph eval --all")}`);
      process.exit(1);
    }

    if (!exists(runsDir)) {
      error(`No runs found at ${pc.cyan(runsDir)}`);
      process.exit(1);
    }

    if (evalAll) {
      // Evaluate all runs
      info("Evaluating all runs...");
      const summaries = evalModule.listRunSummaries(runsDir);
      if (summaries.length === 0) {
        warn("No run summaries found.");
        process.exit(0);
      }

      const scores = [];
      for (const summaryPath of summaries) {
        const score = evalModule.scoreRun(summaryPath);
        if (score) {
          scores.push(score);

          // Generate individual report
          const report = evalModule.generateRunReport(score);
          const outputPath = path.join(evalDir, `eval-${score.runId}.md`);
          evalModule.saveReport(report, outputPath);
        }
      }

      // Generate and display summary
      const aggregate = evalModule.aggregateScores(scores);
      if (aggregate) {
        console.log("");
        console.log(pc.bold("Evaluation Summary"));
        console.log(pc.dim("─".repeat(50)));
        console.log(`Total Runs:      ${pc.bold(aggregate.totalRuns)}`);
        console.log(`Successful:      ${pc.green(aggregate.successCount)} (${aggregate.successRate}%)`);
        console.log(`Failed:          ${pc.red(aggregate.errorCount)}`);
        console.log(`Average Score:   ${pc.bold(aggregate.avgOverall)}/100 (${aggregate.grade})`);
        console.log(`Avg Duration:    ${evalModule.formatDuration(aggregate.avgDuration)}`);
        console.log(pc.dim("─".repeat(50)));
        console.log("");

        // Score breakdown
        console.log(pc.bold("Score Breakdown"));
        console.log(`  Success:       ${evalModule.scoreBar(aggregate.avgSuccess)}`);
        console.log(`  Verification:  ${evalModule.scoreBar(aggregate.avgVerification)}`);
        console.log(`  Commit:        ${evalModule.scoreBar(aggregate.avgCommit)}`);
        console.log(`  Efficiency:    ${evalModule.scoreBar(aggregate.avgEfficiency)}`);
        console.log("");

        // Common failure patterns
        if (aggregate.failurePatterns && aggregate.failurePatterns.length > 0) {
          console.log(pc.bold("Common Failure Patterns"));
          for (const { pattern, count } of aggregate.failurePatterns) {
            const readable = pattern.replace(/_/g, " ").replace(/errors (\d+)/, "$1 errors");
            console.log(`  - ${readable}: ${pc.yellow(count)}`);
          }
          console.log("");
        }

        // Save summary report
        const summaryReport = evalModule.generateSummaryReport(scores, aggregate);
        const summaryPath = path.join(evalDir, "summary.md");
        evalModule.saveReport(summaryReport, summaryPath);
        success(`Summary report saved to ${pc.cyan(summaryPath)}`);
      }
    } else {
      // Evaluate single run
      // Find matching run files
      const summaries = evalModule.listRunSummaries(runsDir);
      const matchingSummaries = summaries.filter((s) => s.includes(runIdArg));

      if (matchingSummaries.length === 0) {
        error(`No runs found matching "${pc.bold(runIdArg)}"`);
        process.exit(1);
      }

      if (matchingSummaries.length > 1) {
        warn(`Multiple runs match "${runIdArg}":`);
        for (const s of matchingSummaries) {
          console.log(`  - ${path.basename(s)}`);
        }
        info("Please provide a more specific run ID.");
        process.exit(1);
      }

      const summaryPath = matchingSummaries[0];
      const score = evalModule.scoreRun(summaryPath);

      if (!score) {
        error(`Failed to evaluate run at ${pc.cyan(summaryPath)}`);
        process.exit(1);
      }

      // Display results
      const grade = evalModule.gradeScore(score.overall);
      const gradeColor = grade === "A" ? pc.green : grade === "B" ? pc.blue : grade === "C" ? pc.yellow : grade === "D" ? pc.magenta : pc.red;

      console.log("");
      console.log(pc.bold(`Evaluation: ${score.runId}`));
      console.log(pc.dim("─".repeat(50)));
      console.log(`Grade:           ${gradeColor(pc.bold(grade))} (${score.overall}/100)`);
      console.log(`Status:          ${score.status === "success" ? pc.green(score.status) : pc.red(score.status)}`);
      console.log(`Mode:            ${score.mode || "N/A"}`);
      console.log(`Story:           ${score.story || "N/A"}`);
      console.log(`Duration:        ${evalModule.formatDuration(score.duration)}`);
      console.log(pc.dim("─".repeat(50)));
      console.log("");

      console.log(pc.bold("Scores"));
      console.log(`  Success:       ${evalModule.scoreBar(score.successScore)}`);
      console.log(`  Verification:  ${evalModule.scoreBar(score.verificationScore)}`);
      console.log(`  Commit:        ${evalModule.scoreBar(score.commitScore)}`);
      console.log(`  Efficiency:    ${evalModule.scoreBar(score.efficiencyScore)}`);
      console.log("");

      console.log(pc.bold("Details"));
      console.log(`  Commits:       ${score.details.commitCount}`);
      console.log(`  Files changed: ${score.details.changedFilesCount}`);
      console.log(`  Clean tree:    ${score.details.hasUncommittedChanges ? pc.yellow("No") : pc.green("Yes")}`);
      console.log(`  Tests passed:  ${score.details.verificationsPassed}`);
      console.log(`  Tests failed:  ${score.details.verificationsFailed}`);
      console.log(`  Errors:        ${score.details.errorCount}`);
      console.log("");

      // Generate and save report
      const report = evalModule.generateRunReport(score);
      const outputPath = path.join(evalDir, `eval-${score.runId}.md`);
      evalModule.saveReport(report, outputPath);
      success(`Report saved to ${pc.cyan(outputPath)}`);
    }

    process.exit(0);
  }

  if (cmd === "estimate") {
    const estimateModule = require("../lib/estimate");
    const ralphDir = path.join(cwd, ".ralph");

    // Check for --json flag
    const jsonOutput = args.includes("--json");

    // Check for --accuracy flag
    const accuracyMode = args.includes("--accuracy");

    // If --accuracy mode, show accuracy report instead of estimate
    if (accuracyMode) {
      // Determine which PRD to analyze
      let prdFolder = null;

      if (prdNumber) {
        prdFolder = estimateModule.getPRDFolder(ralphDir, prdNumber);
        if (!prdFolder) {
          error(`PRD-${prdNumber} not found in ${pc.cyan(ralphDir)}`);
          process.exit(1);
        }
      } else {
        const activePRD = estimateModule.findActivePRD(ralphDir);
        if (!activePRD) {
          error(`No PRD found with plan.md. Run ${pc.cyan("ralph plan")} first.`);
          process.exit(1);
        }
        prdFolder = activePRD.folder;
        prdNumber = activePRD.number;
      }

      // Generate accuracy report
      const report = estimateModule.accuracy.generateAccuracyReport(prdFolder);

      if (!report.success) {
        error(report.error);
        process.exit(1);
      }

      // Output results
      if (jsonOutput) {
        console.log(estimateModule.accuracy.formatAccuracyJSON(report));
      } else {
        console.log("");
        console.log(pc.bold(`Estimation Accuracy Report for PRD-${prdNumber}`));
        console.log(pc.dim("─".repeat(80)));
        console.log("");

        if (!report.hasData) {
          warn(report.message);
          console.log("");
          dim("Tips to start tracking accuracy:");
          console.log("  1. Run `ralph estimate` before starting a build");
          console.log("  2. Complete builds to generate actual metrics");
          console.log("  3. Run `ralph estimate --accuracy` to compare");
          console.log("");
        } else {
          console.log(estimateModule.accuracy.formatAccuracyReport(report));
          console.log("");

          // Color-coded trend display
          if (report.trend) {
            const trendColor = report.trend.trend === "improving" ? pc.green
              : report.trend.trend === "degrading" ? pc.red
              : pc.yellow;
            console.log(trendColor(`Trend: ${report.trend.trendIndicator} ${report.trend.description}`));
          }
          console.log("");
        }
      }

      process.exit(0);
    }

    // Parse custom pricing if provided (format: "input:X,output:Y")
    let customPricing = null;
    if (estimatePricing) {
      const pricingParts = estimatePricing.split(",");
      customPricing = {};
      for (const part of pricingParts) {
        const [key, value] = part.split(":");
        if (key && value) {
          const numValue = parseFloat(value);
          if (!isNaN(numValue)) {
            customPricing[key.trim().toLowerCase()] = numValue;
          }
        }
      }
      // Validate that we have at least input or output
      if (!customPricing.input && !customPricing.output) {
        error(`Invalid --pricing format. Use: --pricing "input:X,output:Y" ($/1M tokens)`);
        process.exit(1);
      }
      // Fill in missing values with defaults
      if (!customPricing.input) customPricing.input = 3.0;  // Default Sonnet input
      if (!customPricing.output) customPricing.output = 15.0;  // Default Sonnet output
    }

    // Determine model to use for pricing (default: sonnet)
    const model = estimateModel || "sonnet";

    // Determine which PRD to analyze
    let prdFolder = null;

    if (prdNumber) {
      // --prd=N flag specified
      prdFolder = estimateModule.getPRDFolder(ralphDir, prdNumber);
      if (!prdFolder) {
        error(`PRD-${prdNumber} not found in ${pc.cyan(ralphDir)}`);
        process.exit(1);
      }
    } else {
      // Find active PRD
      const activePRD = estimateModule.findActivePRD(ralphDir);
      if (!activePRD) {
        error(`No PRD found with plan.md. Run ${pc.cyan("ralph plan")} first.`);
        process.exit(1);
      }
      prdFolder = activePRD.folder;
      prdNumber = activePRD.number;
    }

    // Run estimation
    const result = estimateModule.estimate({
      prdFolder,
      repoRoot: cwd,
      model: model,
      customPricing: customPricing,
    });

    if (!result.success) {
      error(result.error);
      process.exit(1);
    }

    // Save estimate for accuracy tracking (unless --json which is typically for piping)
    if (!jsonOutput) {
      const saveResult = estimateModule.accuracy.saveEstimate(prdFolder, result);
      if (!saveResult.success) {
        warn(`Could not save estimate for accuracy tracking: ${saveResult.error}`);
      }
    }

    // Output results
    if (jsonOutput) {
      // Add pricing info to JSON output
      const jsonResult = {
        ...result,
        pricing: customPricing || { model: model, source: "default" },
      };
      console.log(estimateModule.formatEstimate(jsonResult, { json: true }));
    } else {
      console.log("");
      console.log(pc.bold(`Build Estimate for PRD-${prdNumber}`));
      console.log(pc.dim("─".repeat(70)));
      console.log("");
      console.log(estimateModule.formatEstimate(result));
      console.log("");

      // Show pricing info
      if (customPricing) {
        info(`Using custom pricing: $${customPricing.input}/M input, $${customPricing.output}/M output`);
      } else {
        dim(`Using ${model} pricing (use --pricing to override)`);
      }

      // Show confidence note
      const conf = result.totals.confidence;
      if (conf === "low") {
        warn("Confidence: Low (no historical data). Estimates may vary significantly.");
      } else if (conf === "medium") {
        info("Confidence: Medium (limited historical data).");
      } else {
        success("Confidence: High (sufficient historical data).");
      }

      // Show range summary
      console.log("");
      console.log(pc.dim("Expected range for pending stories:"));
      console.log(pc.dim(`  Time: ${estimateModule.formatDuration(result.totals.durationOptimistic)} - ${estimateModule.formatDuration(result.totals.durationPessimistic)}`));
      console.log(pc.dim(`  Cost: ${estimateModule.formatter.formatCost(result.totals.costOptimistic)} - ${estimateModule.formatter.formatCost(result.totals.costPessimistic)}`));
      console.log("");
    }

    process.exit(0);
  }

  if (cmd === "improve") {
    const improveModule = require("../lib/improve");
    const runsDir = path.join(cwd, ".ralph", "runs");
    const errorsLog = path.join(cwd, ".ralph", "errors.log");
    const candidatesDir = path.join(cwd, ".ralph", "candidates");
    const pendingPath = path.join(candidatesDir, "guardrails-pending.md");
    const guardrailsPath = path.join(cwd, ".ralph", "guardrails.md");

    const generateFlag = args.includes("--generate");
    const applyFlag = args.includes("--apply");

    // If --generate flag, regenerate candidates
    if (generateFlag) {
      info("Analyzing runs for failure patterns...");

      if (!exists(runsDir)) {
        warn("No runs directory found. Run some iterations first.");
        process.exit(0);
      }

      const candidates = improveModule.analyzeAndGenerate(runsDir, errorsLog, {
        minOccurrences: 1,
      });

      if (candidates.length === 0) {
        success("No significant failure patterns detected.");
        process.exit(0);
      }

      improveModule.saveCandidates(candidates, pendingPath);
      success(`Generated ${pc.bold(candidates.length)} guardrail candidates.`);
      info(`Candidates saved to ${pc.cyan(pendingPath)}`);
      console.log("");
      console.log("Run " + pc.cyan("ralph improve") + " to review and apply them.");
      process.exit(0);
    }

    // Check for existing candidates
    let candidates = improveModule.loadCandidates(pendingPath);

    if (candidates.length === 0 && !applyFlag) {
      // Auto-generate candidates if none exist
      info("No pending candidates. Analyzing runs for failure patterns...");

      if (!exists(runsDir)) {
        warn("No runs directory found. Run some iterations first.");
        process.exit(0);
      }

      candidates = improveModule.analyzeAndGenerate(runsDir, errorsLog, {
        minOccurrences: 1,
      });

      if (candidates.length === 0) {
        success("No significant failure patterns detected.");
        process.exit(0);
      }

      improveModule.saveCandidates(candidates, pendingPath);
      info(`Generated ${pc.bold(candidates.length)} guardrail candidates.`);
    }

    if (candidates.length === 0) {
      success("No pending guardrail candidates to review.");
      process.exit(0);
    }

    // Interactive review
    const { intro, outro, select, confirm, isCancel } = await import("@clack/prompts");
    intro("Ralph Guardrail Review");

    console.log("");
    console.log(pc.bold(`Found ${candidates.length} guardrail candidate(s) to review.`));
    console.log("");

    const accepted = [];
    const rejected = [];

    for (const candidate of candidates) {
      console.log(pc.dim("─".repeat(60)));
      console.log(pc.bold(pc.cyan(`Candidate: ${candidate.title}`)));
      console.log("");
      console.log(`  ${pc.yellow("Trigger:")}     ${candidate.trigger}`);
      console.log(`  ${pc.yellow("Instruction:")} ${candidate.instruction}`);
      console.log(`  ${pc.yellow("Context:")}     ${candidate.context}`);
      console.log("");
      console.log(pc.dim(`  Occurrences: ${candidate.occurrences}`));
      console.log(pc.dim(`  Affected runs: ${candidate.affectedRuns.slice(0, 3).join(", ")}${candidate.affectedRuns.length > 3 ? "..." : ""}`));
      console.log("");

      const action = await select({
        message: "Apply this guardrail?",
        options: [
          { value: "accept", label: "Yes, add to guardrails.md" },
          { value: "skip", label: "Skip for now" },
          { value: "reject", label: "Reject (remove from candidates)" },
        ],
      });

      if (isCancel(action)) {
        outro("Cancelled. Progress saved.");
        // Save remaining candidates
        const remaining = candidates.filter(
          (c) => !accepted.find((a) => a.id === c.id) && !rejected.find((r) => r.id === c.id)
        );
        improveModule.saveCandidates(remaining, pendingPath);
        process.exit(0);
      }

      if (action === "accept") {
        accepted.push(candidate);
        success(`  ✓ Accepted: ${candidate.title}`);
      } else if (action === "reject") {
        rejected.push(candidate);
        dim(`  ✗ Rejected: ${candidate.title}`);
      } else {
        dim(`  ○ Skipped: ${candidate.title}`);
      }
    }

    // Apply accepted guardrails
    if (accepted.length > 0) {
      console.log("");
      info(`Applying ${accepted.length} guardrail(s) to ${pc.cyan(guardrailsPath)}...`);

      // Ensure guardrails file exists
      if (!exists(guardrailsPath)) {
        fs.mkdirSync(path.dirname(guardrailsPath), { recursive: true });
        fs.writeFileSync(guardrailsPath, `# Guardrails (Signs)\n\n> Lessons learned from failures. Read before acting.\n\n## Learned Signs\n\n`);
      }

      const acceptedAt = new Date().toISOString();
      let guardrailsContent = fs.readFileSync(guardrailsPath, "utf-8");

      for (const candidate of accepted) {
        const entry = improveModule.formatGuardrailEntry(candidate, acceptedAt);
        guardrailsContent += "\n" + entry;
      }

      fs.writeFileSync(guardrailsPath, guardrailsContent);
      success(`Added ${accepted.length} guardrail(s) to ${pc.cyan("guardrails.md")}`);
    }

    // Update pending candidates (remove accepted and rejected)
    const remaining = candidates.filter(
      (c) => !accepted.find((a) => a.id === c.id) && !rejected.find((r) => r.id === c.id)
    );
    improveModule.saveCandidates(remaining, pendingPath);

    console.log("");
    outro(`Done. ${accepted.length} applied, ${rejected.length} rejected, ${remaining.length} pending.`);
    process.exit(0);
  }

  if (cmd === "registry") {
    const registryModule = require("../lib/registry");
    const subCmd = args[1];

    // Parse --tags flag
    let tags = [];
    for (let i = 0; i < rawArgs.length; i++) {
      if (rawArgs[i].startsWith("--tags=")) {
        tags = rawArgs[i].split("=").slice(1).join("=").split(",").map((t) => t.trim().toLowerCase());
      } else if (rawArgs[i] === "--tags" && rawArgs[i + 1]) {
        tags = rawArgs[i + 1].split(",").map((t) => t.trim().toLowerCase());
      }
    }

    if (!subCmd || subCmd === "help") {
      console.log(`${pc.bold("ralph registry")} ${pc.dim("<command>")}

${pc.bold(pc.cyan("Commands:"))}
  ${pc.green("add")} ${pc.dim("[--tags t1,t2]")}     Register current project in global registry
  ${pc.green("list")} ${pc.dim("[--tags t1,t2]")}    List all registered projects
  ${pc.green("remove")}                 Remove current project from registry
  ${pc.green("update")}                 Update project metadata and stats

${pc.bold(pc.cyan("Options:"))}
  ${pc.yellow("--tags")} ${pc.dim("t1,t2,...")}        Tags for categorization (e.g., typescript, cli, api)

${pc.bold(pc.cyan("Examples:"))}
  ${pc.dim("ralph registry add --tags typescript,cli")}
  ${pc.dim("ralph registry list --tags typescript")}
`);
      process.exit(0);
    }

    // Ensure registry exists
    registryModule.ensureGlobalRegistry();

    if (subCmd === "add") {
      // Check if .ralph directory exists
      const ralphDir = path.join(cwd, ".ralph");
      if (!exists(ralphDir)) {
        warn(`No .ralph directory found at ${pc.cyan(cwd)}`);
        info("Run some Ralph loops first to generate data.");
      }

      // Check if already registered
      const existing = registryModule.findProjectByPath(cwd);
      if (existing) {
        info(`Project already registered: ${pc.bold(existing.name)}`);
        info("Updating metadata and stats...");
      }

      // Add or update project
      const project = registryModule.addProject(cwd, { tags });

      // Index the project
      const indexed = registryModule.indexProject(cwd);

      console.log("");
      console.log(pc.bold("Project Registered"));
      console.log(pc.dim("─".repeat(50)));
      console.log(`Name:         ${pc.bold(project.name)}`);
      console.log(`Path:         ${pc.dim(project.path)}`);
      console.log(`ID:           ${pc.dim(project.id)}`);
      console.log(`Tags:         ${project.tags.length > 0 ? pc.cyan(project.tags.join(", ")) : pc.dim("none")}`);
      console.log(pc.dim("─".repeat(50)));

      if (indexed) {
        console.log(pc.bold("Stats"));
        console.log(`  Guardrails:  ${indexed.stats.guardrailCount}`);
        console.log(`  Progress:    ${indexed.stats.progressCount}`);
        console.log(`  Runs:        ${indexed.stats.runCount}`);
        console.log(`  Success:     ${indexed.stats.successRate !== null ? indexed.stats.successRate + "%" : "N/A"}`);
        console.log("");
      }

      success(`Registered in ${pc.cyan("~/.ralph/registry.json")}`);
      process.exit(0);
    }

    if (subCmd === "list") {
      const projects = registryModule.listProjects({ tags });

      if (projects.length === 0) {
        if (tags.length > 0) {
          warn(`No projects found with tags: ${tags.join(", ")}`);
        } else {
          warn("No projects registered yet.");
          info(`Use ${pc.cyan("ralph registry add")} to register the current project.`);
        }
        process.exit(0);
      }

      console.log("");
      console.log(pc.bold(`Registered Projects (${projects.length})`));
      console.log(pc.dim("─".repeat(80)));

      // Table header
      console.log(
        pc.dim(
          `${"NAME".padEnd(20)} ${"RUNS".padStart(6)} ${"SUCCESS".padStart(8)} ${"GUARDRAILS".padStart(11)} ${"TAGS".padEnd(20)}`
        )
      );
      console.log(pc.dim("─".repeat(80)));

      for (const project of projects) {
        const name = project.name.length > 18 ? project.name.slice(0, 17) + "…" : project.name;
        const runs = String(project.stats.runCount || 0).padStart(6);
        const successRate = project.stats.successRate !== null ? `${project.stats.successRate}%`.padStart(8) : "N/A".padStart(8);
        const guardrails = String(project.stats.guardrailCount || 0).padStart(11);
        const tagsStr = project.tags.slice(0, 3).join(", ");
        const tagsDisplay = tagsStr.length > 18 ? tagsStr.slice(0, 17) + "…" : tagsStr;

        console.log(
          `${name.padEnd(20)} ${runs} ${project.stats.successRate !== null ? pc.green(successRate) : pc.dim(successRate)} ${guardrails} ${pc.cyan(tagsDisplay)}`
        );
      }

      console.log(pc.dim("─".repeat(80)));
      console.log("");

      if (tags.length > 0) {
        dim(`Filtered by tags: ${tags.join(", ")}`);
      }
      process.exit(0);
    }

    if (subCmd === "remove") {
      const existing = registryModule.findProjectByPath(cwd);
      if (!existing) {
        warn("Current project is not registered.");
        process.exit(0);
      }

      const removed = registryModule.removeProject(cwd);
      if (removed) {
        success(`Removed ${pc.bold(existing.name)} from registry.`);
      } else {
        error("Failed to remove project from registry.");
        process.exit(1);
      }
      process.exit(0);
    }

    if (subCmd === "update") {
      const existing = registryModule.findProjectByPath(cwd);
      if (!existing) {
        warn("Current project is not registered.");
        info(`Use ${pc.cyan("ralph registry add")} to register it first.`);
        process.exit(0);
      }

      info(`Updating ${pc.bold(existing.name)}...`);

      // Update tags if provided
      if (tags.length > 0) {
        registryModule.updateProject(cwd, { tags });
      }

      // Re-index the project
      const updated = registryModule.indexProject(cwd);

      if (updated) {
        console.log("");
        console.log(pc.bold("Updated Stats"));
        console.log(pc.dim("─".repeat(40)));
        console.log(`  Guardrails:  ${updated.stats.guardrailCount}`);
        console.log(`  Progress:    ${updated.stats.progressCount}`);
        console.log(`  Runs:        ${updated.stats.runCount}`);
        console.log(`  Success:     ${updated.stats.successRate !== null ? updated.stats.successRate + "%" : "N/A"}`);
        if (tags.length > 0) {
          console.log(`  Tags:        ${pc.cyan(updated.tags.join(", "))}`);
        }
        console.log("");
        success("Project metadata updated.");
      }
      process.exit(0);
    }

    error(`Unknown registry command: ${pc.bold(subCmd)}`);
    info(`Run ${pc.cyan("ralph registry help")} for usage.`);
    process.exit(1);
  }

  if (cmd === "search") {
    const searchModule = require("../lib/search");
    const registryModule = require("../lib/registry");

    // Parse search-specific flags
    let projectFilter = null;
    let typeFilter = null;
    let sinceFilter = null;
    let limitValue = 20;
    let rebuildFlag = false;
    const searchTags = [];
    const queryParts = [];

    // First parse --tags from rawArgs (since they're stripped earlier)
    for (let i = 0; i < rawArgs.length; i++) {
      if (rawArgs[i].startsWith("--tags=")) {
        const tagVal = rawArgs[i].split("=").slice(1).join("=");
        searchTags.push(...tagVal.split(",").map((t) => t.trim().toLowerCase()));
      } else if (rawArgs[i] === "--tags" && rawArgs[i + 1]) {
        searchTags.push(...rawArgs[i + 1].split(",").map((t) => t.trim().toLowerCase()));
        i++; // Skip the value too
      }
    }

    for (let i = 1; i < args.length; i++) {
      const arg = args[i];
      if (arg.startsWith("--project=")) {
        projectFilter = arg.split("=").slice(1).join("=");
      } else if (arg === "--project" && args[i + 1]) {
        projectFilter = args[++i];
      } else if (arg.startsWith("--type=")) {
        typeFilter = arg.split("=").slice(1).join("=");
      } else if (arg === "--type" && args[i + 1]) {
        typeFilter = args[++i];
      } else if (arg.startsWith("--since=")) {
        sinceFilter = arg.split("=").slice(1).join("=");
      } else if (arg === "--since" && args[i + 1]) {
        sinceFilter = args[++i];
      } else if (arg.startsWith("--limit=")) {
        limitValue = parseInt(arg.split("=")[1], 10) || 20;
      } else if (arg === "--limit" && args[i + 1]) {
        limitValue = parseInt(args[++i], 10) || 20;
      } else if (arg === "--rebuild") {
        rebuildFlag = true;
      } else if (!arg.startsWith("--")) {
        queryParts.push(arg);
      }
    }

    const query = queryParts.join(" ").trim();

    // Validate type filter
    const validTypes = ["guardrail", "progress", "evaluation", "run"];
    if (typeFilter && !validTypes.includes(typeFilter)) {
      error(`Invalid type: ${pc.bold(typeFilter)}`);
      info(`Valid types: ${validTypes.map((t) => pc.cyan(t)).join(", ")}`);
      process.exit(1);
    }

    // Ensure registry exists
    registryModule.ensureGlobalRegistry();

    // Check if any projects are registered
    const projects = registryModule.listProjects();
    if (projects.length === 0) {
      warn("No projects registered in the global registry.");
      info(`Use ${pc.cyan("ralph registry add")} to register projects first.`);
      process.exit(0);
    }

    // Rebuild index if requested or if it doesn't exist
    const indexPath = searchModule.getSearchIndexPath();
    if (rebuildFlag || !exists(indexPath)) {
      info("Building search index...");
      const stats = searchModule.buildIndex();
      dim(`Indexed ${stats.projects} projects: ${stats.guardrails} guardrails, ${stats.progress} progress entries, ${stats.evaluations} evaluations, ${stats.runs} runs`);
      console.log("");
    }

    // Perform search
    if (!query && !projectFilter && !typeFilter && searchTags.length === 0 && !sinceFilter) {
      // Show help if no query or filters
      console.log(`${pc.bold("ralph search")} ${pc.dim("<query>")} ${pc.dim("[options]")}

${pc.bold(pc.cyan("Usage:"))}
  ${pc.green("ralph search")} ${pc.dim("\"test before commit\"")}       Search for a phrase
  ${pc.green("ralph search")} ${pc.dim("error --type guardrail")}      Search guardrails for \"error\"
  ${pc.green("ralph search")} ${pc.dim("--project myapp")}             List all entries from a project
  ${pc.green("ralph search")} ${pc.dim("--tags typescript")}           Search in TypeScript projects
  ${pc.green("ralph search")} ${pc.dim("--since 7d")}                  Search recent entries (last 7 days)
  ${pc.green("ralph search")} ${pc.dim("--rebuild")}                   Rebuild index and list all

${pc.bold(pc.cyan("Options:"))}
  ${pc.yellow("--project")} ${pc.dim("<name>")}      Filter by project name or ID
  ${pc.yellow("--type")} ${pc.dim("<type>")}         Filter: guardrail, progress, evaluation, run
  ${pc.yellow("--tags")} ${pc.dim("t1,t2")}          Filter by project tags
  ${pc.yellow("--since")} ${pc.dim("<when>")}        Filter by date: 7d, 2w, 1m, or ISO date
  ${pc.yellow("--limit")} ${pc.dim("<N>")}           Max results (default 20)
  ${pc.yellow("--rebuild")}             Rebuild search index first

${pc.bold(pc.cyan("Examples:"))}
  ${pc.dim("ralph search \"missing dependency\" --type guardrail")}
  ${pc.dim("ralph search US-001 --project ralph-cli")}
  ${pc.dim("ralph search --tags typescript,cli --since 30d")}
`);
      process.exit(0);
    }

    const results = searchModule.search(query, {
      project: projectFilter,
      type: typeFilter,
      tags: searchTags.length > 0 ? searchTags : null,
      since: sinceFilter,
      limit: limitValue,
    });

    // Display results
    console.log("");
    if (query) {
      console.log(pc.bold(`Search: "${query}"`));
    } else {
      console.log(pc.bold("Search Results"));
    }

    // Show active filters
    const activeFilters = [];
    if (projectFilter) activeFilters.push(`project=${projectFilter}`);
    if (typeFilter) activeFilters.push(`type=${typeFilter}`);
    if (searchTags.length > 0) activeFilters.push(`tags=${searchTags.join(",")}`);
    if (sinceFilter) activeFilters.push(`since=${sinceFilter}`);
    if (activeFilters.length > 0) {
      dim(`Filters: ${activeFilters.join(", ")}`);
    }

    console.log(pc.dim("─".repeat(70)));
    console.log(`Found ${pc.bold(results.totalCount)} results${results.totalCount > results.returnedCount ? ` (showing ${results.returnedCount})` : ""}`);
    console.log("");

    if (results.results.length === 0) {
      dim("No matching entries found.");
      console.log("");
      info(`Tips:`);
      dim(`  - Try broader search terms`);
      dim(`  - Use ${pc.cyan("--rebuild")} to refresh the index`);
      dim(`  - Check registered projects with ${pc.cyan("ralph registry list")}`);
      process.exit(0);
    }

    for (const result of results.results) {
      // Type badge with color
      const typeBadge =
        result.type === "guardrail"
          ? pc.yellow(`[${result.type}]`)
          : result.type === "progress"
            ? pc.green(`[${result.type}]`)
            : result.type === "evaluation"
              ? pc.blue(`[${result.type}]`)
              : pc.magenta(`[${result.type}]`);

      // Relevance indicator
      const relevance = result.relevance >= 80 ? pc.green("●●●") : result.relevance >= 50 ? pc.yellow("●●○") : pc.dim("●○○");

      console.log(`${typeBadge} ${pc.bold(result.title)} ${relevance}`);
      dim(`   Project: ${result.projectName} | Score: ${result.relevance}/100`);

      // Show snippet with highlighting
      if (result.snippet && result.snippet.text) {
        let snippetText = result.snippet.text;
        // Apply highlighting for terminal display
        if (result.snippet.highlights && result.snippet.highlights.length > 0 && query) {
          // Highlight query terms in the snippet
          const lowerQuery = query.toLowerCase();
          const terms = [lowerQuery, ...query.toLowerCase().split(/\s+/).filter((t) => t.length >= 2)];
          for (const term of terms) {
            const regex = new RegExp(`(${term.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")})`, "gi");
            snippetText = snippetText.replace(regex, pc.bold(pc.cyan("$1")));
          }
        }
        // Clean up newlines for display
        snippetText = snippetText.replace(/\n+/g, " ").replace(/\s+/g, " ").trim();
        if (snippetText.length > 150) {
          snippetText = snippetText.slice(0, 147) + "...";
        }
        console.log(`   ${pc.dim(snippetText)}`);
      }

      // Show source file
      if (result.source) {
        const relSource = result.source.replace(result.projectPath, "").replace(/^\//, "");
        dim(`   Source: ${relSource}`);
      }

      console.log("");
    }

    console.log(pc.dim("─".repeat(70)));
    if (results.totalCount > results.returnedCount) {
      info(`Showing ${results.returnedCount} of ${results.totalCount} results. Use ${pc.cyan("--limit")} to see more.`);
    }
    process.exit(0);
  }

  if (cmd === "import") {
    const importModule = require("../lib/import");
    const registryModule = require("../lib/registry");
    const { detectTechStack } = require("../lib/registry/projects");

    const subCmd = args[1];

    // Parse --from flag
    let fromProject = null;
    let importAll = false;
    for (let i = 0; i < rawArgs.length; i++) {
      if (rawArgs[i].startsWith("--from=")) {
        fromProject = rawArgs[i].split("=").slice(1).join("=");
      } else if (rawArgs[i] === "--from" && rawArgs[i + 1]) {
        fromProject = rawArgs[i + 1];
        i++;
      } else if (rawArgs[i] === "--all") {
        importAll = true;
      }
    }

    if (!subCmd || subCmd === "help") {
      console.log(`${pc.bold("ralph import")} ${pc.dim("<type>")}

${pc.bold(pc.cyan("Commands:"))}
  ${pc.green("guardrails")} ${pc.dim("[--from project]")}   Import guardrails from another project

${pc.bold(pc.cyan("Options:"))}
  ${pc.yellow("--from")} ${pc.dim("<project>")}            Source project (name or ID)
  ${pc.yellow("--all")}                      Import all guardrails without selection

${pc.bold(pc.cyan("Examples:"))}
  ${pc.dim("ralph import guardrails")}                 Interactive project selection
  ${pc.dim("ralph import guardrails --from myapp")}   Import from specific project
  ${pc.dim("ralph import guardrails --all")}          Import all without prompting
`);
      process.exit(0);
    }

    if (subCmd === "guardrails") {
      // Ensure registry exists
      registryModule.ensureGlobalRegistry();

      // Get all registered projects
      let projects = registryModule.listProjects();

      if (projects.length === 0) {
        warn("No projects registered in the global registry.");
        info(`Use ${pc.cyan("ralph registry add")} in other projects first.`);
        process.exit(0);
      }

      // Exclude current project
      const currentProject = registryModule.findProjectByPath(cwd);
      projects = projects.filter((p) => p.path !== cwd);

      if (projects.length === 0) {
        warn("No other projects available to import from.");
        info("Register other projects with Ralph first.");
        process.exit(0);
      }

      // Sort by tech stack relevance
      const targetStack = detectTechStack(cwd);
      const suggestedProjects = importModule.getSuggestedProjects(projects, targetStack);

      let selectedProject = null;

      // If --from specified, find that project
      if (fromProject) {
        selectedProject = suggestedProjects.find(
          (p) =>
            p.name.toLowerCase() === fromProject.toLowerCase() ||
            p.id === fromProject
        );
        if (!selectedProject) {
          error(`Project not found: ${pc.bold(fromProject)}`);
          info("Available projects:");
          for (const p of suggestedProjects.slice(0, 5)) {
            dim(`  - ${p.name} (${p.id})`);
          }
          process.exit(1);
        }
      } else {
        // Interactive project selection
        const { intro, outro, select, multiselect, confirm, isCancel } = await import("@clack/prompts");
        intro("Ralph Guardrails Import");

        console.log("");
        if (targetStack.length > 0) {
          info(`Detected tech stack: ${pc.cyan(targetStack.join(", "))}`);
          console.log("");
        }

        // Show suggested projects first
        const hasSuggested = suggestedProjects.some((p) => p.relevanceScore > 0);

        const projectOptions = suggestedProjects.map((p) => {
          const guardrailCount = p.stats?.guardrailCount || 0;
          const matchInfo = p.matchingTags?.length > 0 ? ` (${p.matchingTags.join(", ")})` : "";
          const recommended = p.relevanceScore > 0 ? pc.green(" [Recommended]") : "";
          return {
            value: p.id,
            label: `${p.name}${recommended}`,
            hint: `${guardrailCount} guardrails${matchInfo}`,
          };
        });

        if (projectOptions.length === 0) {
          outro("No projects with guardrails available.");
          process.exit(0);
        }

        const selectedId = await select({
          message: "Select a project to import guardrails from:",
          options: projectOptions,
        });

        if (isCancel(selectedId)) {
          outro("Cancelled.");
          process.exit(0);
        }

        selectedProject = suggestedProjects.find((p) => p.id === selectedId);
      }

      if (!selectedProject) {
        error("No project selected.");
        process.exit(1);
      }

      info(`Loading guardrails from ${pc.bold(selectedProject.name)}...`);

      // Get guardrails from selected project
      const guardrails = importModule.getProjectGuardrails(selectedProject.path);

      if (guardrails.length === 0) {
        warn(`No guardrails found in ${selectedProject.name}.`);
        process.exit(0);
      }

      let selectedGuardrails = guardrails;

      // If not --all, show preview and selection UI
      if (!importAll) {
        const { multiselect, isCancel, outro } = await import("@clack/prompts");

        console.log("");
        console.log(pc.bold(`Found ${guardrails.length} guardrail(s) in ${selectedProject.name}:`));
        console.log(pc.dim("─".repeat(60)));

        // Show preview of each guardrail
        for (const g of guardrails) {
          console.log(`  ${pc.cyan("•")} ${pc.bold(g.title)}`);
          if (g.trigger) {
            console.log(`    ${pc.dim("Trigger:")} ${g.trigger}`);
          }
          if (g.instruction) {
            console.log(`    ${pc.dim("Instruction:")} ${g.instruction}`);
          }
          console.log("");
        }
        console.log(pc.dim("─".repeat(60)));
        console.log("");

        const guardrailOptions = guardrails.map((g, idx) => ({
          value: idx,
          label: g.title,
          hint: g.trigger || g.instruction || "",
        }));

        const selectedIndices = await multiselect({
          message: "Select guardrails to import:",
          options: guardrailOptions,
          required: false,
        });

        if (isCancel(selectedIndices)) {
          outro("Cancelled.");
          process.exit(0);
        }

        if (!selectedIndices || selectedIndices.length === 0) {
          outro("No guardrails selected.");
          process.exit(0);
        }

        selectedGuardrails = selectedIndices.map((idx) => guardrails[idx]);
      }

      // Import the selected guardrails
      const result = importModule.importGuardrails(selectedGuardrails, cwd, selectedProject.name);

      console.log("");
      if (result.imported > 0) {
        success(`Imported ${pc.bold(result.imported)} guardrail(s) from ${pc.cyan(selectedProject.name)}`);
        info(`Guardrails saved to ${pc.cyan(".ralph/guardrails.md")}`);
      }
      if (result.skipped > 0) {
        dim(`Skipped ${result.skipped} duplicate(s).`);
      }

      const { outro } = await import("@clack/prompts");
      outro("Done.");
      process.exit(0);
    }

    error(`Unknown import type: ${pc.bold(subCmd)}`);
    info(`Run ${pc.cyan("ralph import help")} for usage.`);
    process.exit(1);
  }

  if (cmd === "stats") {
    const statsModule = require("../lib/stats");
    const registryModule = require("../lib/registry");
    const { formatDuration } = require("../lib/eval/reporter");

    // Parse flags
    let globalFlag = false;
    let jsonFlag = false;
    let noCache = false;
    let tokensFlag = false;

    for (const arg of args.slice(1)) {
      if (arg === "--global" || arg === "-g") {
        globalFlag = true;
      } else if (arg === "--json") {
        jsonFlag = true;
      } else if (arg === "--no-cache") {
        noCache = true;
      } else if (arg === "--tokens") {
        tokensFlag = true;
      }
    }

    // Handle --tokens flag - show token/cost metrics
    if (tokensFlag) {
      const tokensModule = require("../lib/tokens");
      const ralphDir = path.join(cwd, ".ralph");

      if (!exists(ralphDir)) {
        warn("No .ralph directory found. Run some build iterations first.");
        process.exit(0);
      }

      // Collect token data from all PRD-N folders
      const prdDirs = fs.readdirSync(ralphDir)
        .filter((dir) => /^PRD-\d+$/.test(dir))
        .map((dir) => ({
          id: dir.replace("PRD-", ""),
          path: path.join(ralphDir, dir),
        }));

      if (prdDirs.length === 0) {
        warn("No PRD directories found. Run some build iterations first.");
        process.exit(0);
      }

      // Aggregate token data across all streams
      let totalInputTokens = 0;
      let totalOutputTokens = 0;
      let totalCost = 0;
      let totalRuns = 0;
      let totalEstimated = 0;
      const byModel = {};
      const byStream = [];

      for (const prdDir of prdDirs) {
        const cache = tokensModule.loadTokenCache(prdDir.path);
        if (!cache || !cache.totals) continue;

        const streamCost = cache.totals.totalCost || 0;
        const streamInputTokens = cache.totals.totalInputTokens || 0;
        const streamOutputTokens = cache.totals.totalOutputTokens || 0;
        const streamRuns = cache.totals.runCount || 0;
        const streamEstimated = cache.totals.estimatedCount || 0;

        totalInputTokens += streamInputTokens;
        totalOutputTokens += streamOutputTokens;
        totalCost += streamCost;
        totalRuns += streamRuns;
        totalEstimated += streamEstimated;

        byStream.push({
          id: prdDir.id,
          inputTokens: streamInputTokens,
          outputTokens: streamOutputTokens,
          cost: streamCost,
          runs: streamRuns,
        });

        // Aggregate by model
        if (cache.byModel) {
          for (const [model, data] of Object.entries(cache.byModel)) {
            if (!byModel[model]) {
              byModel[model] = { inputTokens: 0, outputTokens: 0, cost: 0, runs: 0 };
            }
            byModel[model].inputTokens += data.inputTokens || 0;
            byModel[model].outputTokens += data.outputTokens || 0;
            byModel[model].cost += data.totalCost || 0;
            byModel[model].runs += data.runs || 0;
          }
        }
      }

      // Format cost for display
      const formatCost = (cost) => {
        if (cost >= 1) return `$${cost.toFixed(2)}`;
        if (cost >= 0.01) return `$${cost.toFixed(3)}`;
        if (cost > 0) return `$${cost.toFixed(4)}`;
        return "$0.00";
      };

      // Format tokens with K/M suffix
      const formatTokens = (num) => {
        if (num >= 1000000) return (num / 1000000).toFixed(1) + "M";
        if (num >= 1000) return (num / 1000).toFixed(1) + "K";
        return num.toString();
      };

      if (jsonFlag) {
        console.log(JSON.stringify({
          totalInputTokens,
          totalOutputTokens,
          totalCost,
          totalRuns,
          totalEstimated,
          avgCostPerRun: totalRuns > 0 ? totalCost / totalRuns : 0,
          byModel,
          byStream,
        }, null, 2));
        process.exit(0);
      }

      console.log("");
      console.log(pc.bold("Token Usage & Cost Metrics"));
      console.log(pc.dim("=".repeat(60)));
      console.log("");

      // Overview
      console.log(pc.bold(pc.cyan("Overview")));
      console.log(pc.dim("-".repeat(40)));
      console.log(`Input Tokens:    ${pc.bold(formatTokens(totalInputTokens))}`);
      console.log(`Output Tokens:   ${pc.bold(formatTokens(totalOutputTokens))}`);
      console.log(`Total Tokens:    ${pc.bold(formatTokens(totalInputTokens + totalOutputTokens))}`);
      console.log(`Total Cost:      ${pc.green(formatCost(totalCost))}`);
      console.log(`Total Runs:      ${pc.bold(totalRuns)}`);
      console.log(`Avg Cost/Run:    ${formatCost(totalRuns > 0 ? totalCost / totalRuns : 0)}`);
      if (totalEstimated > 0) {
        console.log(`Estimated Runs:  ${pc.yellow(totalEstimated)} (${Math.round((totalEstimated / totalRuns) * 100)}%)`);
      }
      console.log("");

      // By Model
      const models = Object.keys(byModel);
      if (models.length > 0) {
        console.log(pc.bold(pc.cyan("By Model")));
        console.log(pc.dim("-".repeat(60)));
        console.log(
          pc.dim(
            `${"MODEL".padEnd(15)} ${"TOKENS".padStart(12)} ${"COST".padStart(10)} ${"RUNS".padStart(6)}`
          )
        );
        console.log(pc.dim("-".repeat(60)));

        for (const model of models) {
          const data = byModel[model];
          const tokens = formatTokens(data.inputTokens + data.outputTokens);
          const cost = formatCost(data.cost);
          const runs = String(data.runs).padStart(6);
          console.log(
            `${model.padEnd(15)} ${tokens.padStart(12)} ${cost.padStart(10)} ${runs}`
          );
        }
        console.log("");
      }

      // By Stream
      if (byStream.length > 0) {
        console.log(pc.bold(pc.cyan("By Stream")));
        console.log(pc.dim("-".repeat(60)));
        console.log(
          pc.dim(
            `${"STREAM".padEnd(10)} ${"TOKENS".padStart(12)} ${"COST".padStart(10)} ${"RUNS".padStart(6)}`
          )
        );
        console.log(pc.dim("-".repeat(60)));

        for (const stream of byStream.slice(0, 10)) {
          const name = `PRD-${stream.id}`;
          const tokens = formatTokens(stream.inputTokens + stream.outputTokens);
          const cost = formatCost(stream.cost);
          const runs = String(stream.runs).padStart(6);
          console.log(
            `${name.padEnd(10)} ${tokens.padStart(12)} ${cost.padStart(10)} ${runs}`
          );
        }
        if (byStream.length > 10) {
          console.log(pc.dim(`  ... and ${byStream.length - 10} more streams`));
        }
        console.log("");
      }

      console.log(pc.dim("=".repeat(60)));
      success("Token stats generated.");
      process.exit(0);
    }

    // Trend arrow helper with color
    const trendArrow = (trend, positiveIsGood = true) => {
      if (!trend || trend.direction === "stable") return pc.dim("-");
      const isGood = (positiveIsGood && trend.direction === "up") || (!positiveIsGood && trend.direction === "down");
      const color = isGood ? pc.green : pc.red;
      return color(`${trend.arrow} ${trend.change}%`);
    };

    if (globalFlag) {
      // Cross-project metrics
      registryModule.ensureGlobalRegistry();
      const projects = registryModule.listProjects();

      if (projects.length === 0) {
        warn("No projects registered in the global registry.");
        info(`Use ${pc.cyan("ralph registry add")} to register projects first.`);
        process.exit(0);
      }

      info(`Aggregating metrics across ${pc.bold(projects.length)} projects...`);
      const metrics = statsModule.aggregateGlobalMetrics(projects);

      if (jsonFlag) {
        console.log(JSON.stringify(metrics, null, 2));
        process.exit(0);
      }

      console.log("");
      console.log(pc.bold("Global Performance Metrics"));
      console.log(pc.dim("=".repeat(60)));
      console.log("");

      // Overview
      console.log(pc.bold(pc.cyan("Overview")));
      console.log(pc.dim("-".repeat(40)));
      console.log(`Projects:        ${pc.bold(metrics.projectCount)}`);
      console.log(`Total Runs:      ${pc.bold(metrics.totalRuns)}`);
      console.log(`Successful:      ${pc.green(metrics.successCount)} (${metrics.successRate || 0}%)`);
      console.log(`Failed:          ${pc.red(metrics.failedCount)}`);
      console.log(`Avg Duration:    ${formatDuration(metrics.avgDuration)}`);
      console.log(`Total Guardrails:${pc.bold(metrics.totalGuardrails)}`);
      console.log("");

      // Top projects
      if (metrics.topProjects.length > 0) {
        console.log(pc.bold(pc.cyan("Top Projects by Activity")));
        console.log(pc.dim("-".repeat(60)));
        console.log(
          pc.dim(
            `${"PROJECT".padEnd(25)} ${"RUNS".padStart(6)} ${"SUCCESS".padStart(8)} ${"TREND".padStart(10)}`
          )
        );
        console.log(pc.dim("-".repeat(60)));

        for (const proj of metrics.topProjects.slice(0, 10)) {
          const name = proj.name.length > 23 ? proj.name.slice(0, 22) + "\u2026" : proj.name;
          const runs = String(proj.runs).padStart(6);
          const rate = proj.successRate !== null ? `${proj.successRate}%`.padStart(8) : "N/A".padStart(8);
          const trend = proj.successRateTrend ? trendArrow(proj.successRateTrend, true) : pc.dim("-");

          console.log(
            `${name.padEnd(25)} ${runs} ${proj.successRate !== null ? pc.green(rate) : pc.dim(rate)} ${trend.padStart(10)}`
          );
        }
        console.log("");
      }

      console.log(pc.dim("=".repeat(60)));
      success("Global stats generated.");
      process.exit(0);
    }

    // Single project metrics
    const ralphDir = path.join(cwd, ".ralph");
    const runsDir = path.join(ralphDir, "runs");

    if (!exists(runsDir)) {
      warn("No runs directory found. Run some build iterations first.");
      process.exit(0);
    }

    // Check cache
    let metrics;
    const cache = statsModule.loadMetricsCache(cwd);
    if (!noCache && cache && statsModule.isCacheValid(cwd, cache)) {
      metrics = cache;
      dim("Using cached metrics (use --no-cache to regenerate)");
    } else {
      metrics = statsModule.aggregateProjectMetrics(cwd);
      statsModule.saveMetricsCache(metrics, cwd);
    }

    if (jsonFlag) {
      console.log(JSON.stringify(metrics, null, 2));
      process.exit(0);
    }

    console.log("");
    console.log(pc.bold("Performance Metrics Dashboard"));
    console.log(pc.dim("=".repeat(60)));
    console.log("");

    // Overview section
    console.log(pc.bold(pc.cyan("Overview")));
    console.log(pc.dim("-".repeat(40)));
    console.log(`Total Runs:      ${pc.bold(metrics.totalRuns)}`);
    console.log(`Successful:      ${pc.green(metrics.successCount)} (${metrics.successRate || 0}%)`);
    console.log(`Failed:          ${pc.red(metrics.failedCount)}`);
    console.log(`Guardrails:      ${pc.bold(metrics.guardrailCount)}`);
    console.log("");

    // Duration section
    console.log(pc.bold(pc.cyan("Duration")));
    console.log(pc.dim("-".repeat(40)));
    console.log(`Average:         ${formatDuration(metrics.avgDuration)}`);
    console.log(`Min:             ${formatDuration(metrics.minDuration)}`);
    console.log(`Max:             ${formatDuration(metrics.maxDuration)}`);
    console.log(`Total:           ${formatDuration(metrics.totalDuration)}`);
    console.log("");

    // Trends section
    console.log(pc.bold(pc.cyan("Trends (Week over Week)")));
    console.log(pc.dim("-".repeat(40)));
    console.log(`Success Rate:    ${trendArrow(metrics.successRateTrend, true)}`);
    console.log(`Avg Duration:    ${trendArrow(metrics.durationTrend, false)}`);
    console.log(`Runs per Day:    ${pc.bold(metrics.runsPerDay)}`);
    console.log("");

    // Mode breakdown
    if (metrics.modeStats && Object.keys(metrics.modeStats).length > 0) {
      console.log(pc.bold(pc.cyan("By Mode")));
      console.log(pc.dim("-".repeat(40)));
      for (const [mode, stats] of Object.entries(metrics.modeStats)) {
        const rate = stats.total > 0 ? Math.round((stats.success / stats.total) * 100) : 0;
        console.log(`${mode.padEnd(15)} ${String(stats.total).padStart(4)} runs  ${pc.green(`${rate}%`)} success`);
      }
      console.log("");
    }

    // Guardrail impacts
    if (metrics.guardrailImpacts && metrics.guardrailImpacts.length > 0) {
      console.log(pc.bold(pc.cyan("Guardrail Impact Analysis")));
      console.log(pc.dim("-".repeat(60)));
      for (const impact of metrics.guardrailImpacts) {
        const arrow = impact.isPositive ? pc.green("\u2191") : pc.red("\u2193");
        const change = impact.isPositive ? pc.green(`+${impact.improvement}%`) : pc.red(`${impact.improvement}%`);
        const title = impact.title.length > 35 ? impact.title.slice(0, 34) + "\u2026" : impact.title;
        console.log(`${arrow} ${title}`);
        console.log(pc.dim(`   ${impact.rateBefore}% \u2192 ${impact.rateAfter}% (${change}) after ${impact.addedDate}`));
      }
      console.log("");
    }

    // Weekly activity summary (last 4 weeks)
    if (metrics.weeklyStats && metrics.weeklyStats.length > 0) {
      const recentWeeks = metrics.weeklyStats.slice(-4);
      console.log(pc.bold(pc.cyan("Weekly Activity (Last 4 Weeks)")));
      console.log(pc.dim("-".repeat(50)));
      console.log(pc.dim(`${"WEEK".padEnd(10)} ${"RUNS".padStart(6)} ${"SUCCESS".padStart(10)} ${"AVG DUR".padStart(10)}`));
      console.log(pc.dim("-".repeat(50)));
      for (const week of recentWeeks) {
        const runs = String(week.runs).padStart(6);
        const rate = week.successRate !== null ? `${week.successRate}%`.padStart(10) : "N/A".padStart(10);
        const dur = formatDuration(week.avgDuration).padStart(10);
        console.log(
          `${week.week.padEnd(10)} ${runs} ${week.successRate !== null ? pc.green(rate) : pc.dim(rate)} ${dur}`
        );
      }
      console.log("");
    }

    // Time range
    if (metrics.firstRun || metrics.lastRun) {
      console.log(pc.dim("-".repeat(40)));
      if (metrics.firstRun) {
        dim(`First run: ${metrics.firstRun}`);
      }
      if (metrics.lastRun) {
        dim(`Last run:  ${metrics.lastRun}`);
      }
    }

    console.log(pc.dim("=".repeat(60)));
    success(`Metrics cached to ${pc.cyan(".ralph/metrics/stats.json")}`);
    process.exit(0);
  }

  if (cmd === "optimize") {
    const optimizeModule = require("../lib/optimize");
    const subCmd = args[1];

    // Parse flags
    let applyFlag = false;
    let versionsFlag = false;
    let initFlag = false;

    for (const arg of args.slice(2)) {
      if (arg === "--apply") {
        applyFlag = true;
      } else if (arg === "--versions") {
        versionsFlag = true;
      } else if (arg === "--init") {
        initFlag = true;
      }
    }

    if (!subCmd || subCmd === "help") {
      console.log(`${pc.bold("ralph optimize")} ${pc.dim("<type>")}

${pc.bold(pc.cyan("Commands:"))}
  ${pc.green("prompts")}                    Analyze prompt effectiveness and generate suggestions
  ${pc.green("prompts")} ${pc.dim("--init")}           Initialize version tracking for prompt templates
  ${pc.green("prompts")} ${pc.dim("--versions")}       Show prompt version effectiveness comparison
  ${pc.green("prompts")} ${pc.dim("--apply")}          Review and apply suggestions interactively

${pc.bold(pc.cyan("Options:"))}
  ${pc.yellow("--init")}                     Initialize version tracking (adds version comments)
  ${pc.yellow("--versions")}                 Show effectiveness comparison by version
  ${pc.yellow("--apply")}                    Interactively review and apply suggestions

${pc.bold(pc.cyan("Examples:"))}
  ${pc.dim("ralph optimize prompts")}              Generate suggestions based on run analysis
  ${pc.dim("ralph optimize prompts --versions")}   Compare success rates across versions
  ${pc.dim("ralph optimize prompts --apply")}      Apply selected suggestions to templates
`);
      process.exit(0);
    }

    if (subCmd === "prompts") {
      const ralphDir = path.join(cwd, ".ralph");
      const runsDir = path.join(ralphDir, "runs");
      const templatePath = path.join(cwd, ".agents", "ralph", "PROMPT_build.md");
      const suggestionsPath = optimizeModule.getSuggestionsPath(cwd);

      // Initialize version tracking
      if (initFlag) {
        info("Initializing prompt template versions...");
        const templates = optimizeModule.initializeVersions(cwd);

        if (templates.length === 0) {
          warn("No prompt templates found in .agents/ralph/");
          info(`Run ${pc.cyan("ralph install")} first to set up templates.`);
          process.exit(0);
        }

        console.log("");
        console.log(pc.bold("Prompt Templates"));
        console.log(pc.dim("-".repeat(50)));
        for (const template of templates) {
          const status = template.action === "initialized" ? pc.green("initialized") : pc.dim("exists");
          console.log(`  ${template.name}: v${template.version} (${status})`);
        }
        console.log("");
        success("Version tracking initialized.");
        process.exit(0);
      }

      // Show version comparison
      if (versionsFlag) {
        const versions = optimizeModule.getVersionComparison(cwd);

        if (versions.length === 0) {
          warn("No version metrics found.");
          info(`Run ${pc.cyan("ralph optimize prompts --init")} to initialize version tracking.`);
          process.exit(0);
        }

        console.log("");
        console.log(pc.bold("Prompt Version Effectiveness"));
        console.log(pc.dim("=".repeat(60)));
        console.log("");
        console.log(pc.dim(`${"VERSION".padEnd(12)} ${"RUNS".padStart(6)} ${"SUCCESS".padStart(9)} ${"AVG DUR".padStart(10)} ${"STATUS".padEnd(10)}`));
        console.log(pc.dim("-".repeat(60)));

        for (const v of versions) {
          const version = v.version.padEnd(12);
          const runs = String(v.runs).padStart(6);
          const rate = v.successRate != null ? `${v.successRate}%`.padStart(9) : "N/A".padStart(9);
          const dur = v.avgDuration != null ? `${v.avgDuration}s`.padStart(10) : "N/A".padStart(10);
          const status = v.isCurrent ? pc.green("current") : pc.dim("previous");

          const rateColor = v.successRate >= 70 ? pc.green : v.successRate >= 50 ? pc.yellow : pc.red;
          console.log(`${version} ${runs} ${v.successRate != null ? rateColor(rate) : pc.dim(rate)} ${dur} ${status}`);
        }
        console.log(pc.dim("-".repeat(60)));
        console.log("");

        // Show best version recommendation
        if (versions.length > 1) {
          const best = versions[0];
          const current = versions.find((v) => v.isCurrent);
          if (current && best.version !== current.version && best.successRate > (current.successRate || 0)) {
            const improvement = (best.successRate || 0) - (current.successRate || 0);
            warn(`Version ${best.version} has ${improvement}% higher success rate than current.`);
            info("Consider reverting recent prompt changes.");
          }
        }
        process.exit(0);
      }

      // Check for runs
      if (!exists(runsDir)) {
        warn("No runs directory found. Run some build iterations first.");
        process.exit(0);
      }

      // Generate suggestions
      info("Analyzing prompt effectiveness...");
      const result = optimizeModule.generateAllSuggestions(cwd, templatePath);

      if (result.error) {
        error(result.error);
        process.exit(1);
      }

      const { suggestions, analysis, categories } = result;

      // Save suggestions to file
      optimizeModule.saveSuggestions(suggestions, analysis, suggestionsPath);

      // Display analysis summary
      console.log("");
      console.log(pc.bold("Prompt Analysis Summary"));
      console.log(pc.dim("=".repeat(60)));
      console.log(`Template:        ${pc.dim(path.basename(templatePath))}`);
      console.log(`Sections:        ${analysis.sectionCount}`);
      console.log(`Instructions:    ${analysis.instructionCount}`);
      console.log(`Runs analyzed:   ${analysis.runsAnalyzed}`);
      console.log(pc.dim("-".repeat(60)));
      console.log("");

      // Show categorized instructions
      if (categories) {
        if (categories.consistentlyFollowed.length > 0) {
          console.log(pc.bold(pc.green("Consistently Followed Instructions")));
          for (const c of categories.consistentlyFollowed.slice(0, 3)) {
            const text = c.text.length > 60 ? c.text.slice(0, 57) + "..." : c.text;
            console.log(`  ${pc.green("✓")} ${text}`);
            dim(`    Follow rate: ${c.followRate}%`);
          }
          console.log("");
        }

        if (categories.consistentlyIgnored.length > 0) {
          console.log(pc.bold(pc.yellow("Consistently Ignored Instructions")));
          for (const c of categories.consistentlyIgnored.slice(0, 3)) {
            const text = c.text.length > 60 ? c.text.slice(0, 57) + "..." : c.text;
            console.log(`  ${pc.yellow("○")} ${text}`);
            dim(`    Follow rate: ${c.followRate}%`);
          }
          console.log("");
        }
      }

      // Show suggestions summary
      if (suggestions.length === 0) {
        success("No significant improvement suggestions at this time.");
        dim("Continue running iterations to gather more data.");
      } else {
        console.log(pc.bold(`Generated ${suggestions.length} Suggestion(s)`));
        console.log(pc.dim("-".repeat(50)));

        const byPriority = {
          high: suggestions.filter((s) => s.priority === "high"),
          medium: suggestions.filter((s) => s.priority === "medium"),
          low: suggestions.filter((s) => s.priority === "low"),
        };

        if (byPriority.high.length > 0) {
          console.log(`  ${pc.red("●")} High priority:   ${byPriority.high.length}`);
        }
        if (byPriority.medium.length > 0) {
          console.log(`  ${pc.yellow("●")} Medium priority: ${byPriority.medium.length}`);
        }
        if (byPriority.low.length > 0) {
          console.log(`  ${pc.dim("●")} Low priority:    ${byPriority.low.length}`);
        }
        console.log("");

        success(`Suggestions saved to ${pc.cyan(".ralph/candidates/prompt-suggestions.md")}`);
        console.log("");
        info(`Run ${pc.cyan("ralph optimize prompts --apply")} to review and apply suggestions.`);
      }

      // Interactive apply mode
      if (applyFlag && suggestions.length > 0) {
        const { intro, outro, select, confirm, isCancel } = await import("@clack/prompts");

        console.log("");
        intro("Apply Prompt Suggestions");

        for (const suggestion of suggestions) {
          console.log("");
          console.log(pc.dim("-".repeat(60)));
          const priorityColor = suggestion.priority === "high" ? pc.red : suggestion.priority === "medium" ? pc.yellow : pc.dim;
          console.log(`${priorityColor(`[${suggestion.priority}]`)} ${pc.bold(suggestion.type)}: ${suggestion.section}`);
          console.log("");

          if (suggestion.instruction) {
            console.log(`${pc.cyan("Instruction:")} "${suggestion.instruction}"`);
          }
          console.log(`${pc.yellow("Why:")} ${suggestion.reason}`);
          console.log(`${pc.green("Suggestion:")} ${suggestion.suggestion}`);
          console.log("");

          if (suggestion.metrics) {
            dim("Metrics:");
            for (const [key, value] of Object.entries(suggestion.metrics)) {
              if (value != null) {
                const label = key.replace(/([A-Z])/g, " $1").trim();
                dim(`  ${label}: ${typeof value === "number" && key.includes("Rate") ? value + "%" : value}`);
              }
            }
          }
          console.log("");

          const action = await select({
            message: "What would you like to do?",
            options: [
              { value: "note", label: "Note for later (keep in suggestions)" },
              { value: "dismiss", label: "Dismiss (remove from suggestions)" },
              { value: "skip", label: "Skip for now" },
            ],
          });

          if (isCancel(action)) {
            outro("Review cancelled. Suggestions preserved.");
            process.exit(0);
          }

          if (action === "dismiss") {
            dim(`  Dismissed: ${suggestion.id}`);
            // Remove from suggestions (in memory, will be saved at end)
            const idx = suggestions.indexOf(suggestion);
            if (idx >= 0) {
              suggestions.splice(idx, 1);
            }
          } else if (action === "note") {
            success(`  Noted: ${suggestion.id}`);
          } else {
            dim(`  Skipped: ${suggestion.id}`);
          }
        }

        // Save updated suggestions
        optimizeModule.saveSuggestions(suggestions, analysis, suggestionsPath);
        outro(`Done. ${suggestions.length} suggestions remaining.`);
      }

      process.exit(0);
    }

    error(`Unknown optimize type: ${pc.bold(subCmd)}`);
    info(`Run ${pc.cyan("ralph optimize help")} for usage.`);
    process.exit(1);
  }

  if (cmd === "diagnose") {
    const diagnoseModule = require("../lib/diagnose");

    // Parse diagnose-specific flags
    let runIdFilter = null;
    let jsonFlag = false;
    let limitValue = 500;

    for (let i = 1; i < args.length; i++) {
      const arg = args[i];
      if (arg.startsWith("--run=")) {
        runIdFilter = arg.split("=").slice(1).join("=");
      } else if (arg === "--run" && args[i + 1]) {
        runIdFilter = args[++i];
      } else if (arg === "--json") {
        jsonFlag = true;
      } else if (arg.startsWith("--limit=")) {
        limitValue = parseInt(arg.split("=")[1], 10) || 500;
      } else if (arg === "--limit" && args[i + 1]) {
        limitValue = parseInt(args[++i], 10) || 500;
      }
    }

    // Run diagnosis
    const results = diagnoseModule.diagnose(cwd, {
      runId: runIdFilter,
      limit: limitValue,
    });

    if (!results.success) {
      error(results.error);
      process.exit(1);
    }

    // JSON output
    if (jsonFlag) {
      console.log(JSON.stringify(results, null, 2));
      process.exit(0);
    }

    // Console output
    console.log("");
    console.log(pc.bold("Failure Pattern Diagnosis"));
    console.log(pc.dim("=".repeat(70)));

    if (runIdFilter) {
      info(`Analyzing run: ${pc.bold(runIdFilter)}`);
    } else {
      info("Analyzing all runs");
    }
    console.log("");

    // Summary
    console.log(pc.bold(pc.cyan("Summary")));
    console.log(pc.dim("-".repeat(50)));
    console.log(`Total Errors:     ${pc.bold(results.summary.totalErrors)}`);
    console.log(`Unique Patterns:  ${pc.bold(results.summary.totalClusters)}`);
    console.log(`Affected Runs:    ${pc.bold(results.summary.uniqueRuns)}`);
    console.log("");

    if (results.patterns.length === 0) {
      success("No failure patterns detected. All systems operational.");
      process.exit(0);
    }

    // Type breakdown
    if (Object.keys(results.summary.typeBreakdown).length > 0) {
      console.log(pc.bold(pc.cyan("Error Type Breakdown")));
      console.log(pc.dim("-".repeat(50)));
      for (const [type, stats] of Object.entries(results.summary.typeBreakdown)) {
        const typeLabel = type.replace(/_/g, " ");
        console.log(`  ${typeLabel.padEnd(25)} ${String(stats.count).padStart(4)} errors in ${stats.clusters} patterns`);
      }
      console.log("");
    }

    // Top failure patterns
    console.log(pc.bold(pc.cyan("Top Failure Patterns")));
    console.log(pc.dim("-".repeat(70)));
    console.log(
      pc.dim(
        `${"ROOT CAUSE".padEnd(25)} ${"COUNT".padStart(6)} ${"RUNS".padStart(6)} ${"SEVERITY".padStart(10)}`
      )
    );
    console.log(pc.dim("-".repeat(70)));

    for (const pattern of results.patterns.slice(0, 10)) {
      const label = pattern.rootCauseLabel.length > 23
        ? pattern.rootCauseLabel.slice(0, 22) + "\u2026"
        : pattern.rootCauseLabel;
      const count = String(pattern.count).padStart(6);
      const runs = String(pattern.runs.length).padStart(6);

      // Color by severity
      const severityColor =
        pattern.severity === "critical" ? pc.red
          : pattern.severity === "high" ? pc.yellow
          : pattern.severity === "medium" ? pc.cyan
          : pc.dim;
      const severity = severityColor(pattern.severity.toUpperCase().padStart(10));

      console.log(`${label.padEnd(25)} ${count} ${runs} ${severity}`);

      // Show representative error
      const shortError = pattern.representative.length > 65
        ? pattern.representative.slice(0, 62) + "..."
        : pattern.representative;
      dim(`  ${pc.dim("→")} ${shortError}`);
    }

    console.log(pc.dim("-".repeat(70)));
    console.log("");

    // Remediation suggestions
    if (results.suggestions.length > 0) {
      console.log(pc.bold(pc.cyan("Recommended Actions")));
      console.log(pc.dim("-".repeat(70)));
      console.log("");

      for (const suggestion of results.suggestions.slice(0, 5)) {
        const severityColor =
          suggestion.severity === "critical" ? pc.red
            : suggestion.severity === "high" ? pc.yellow
            : suggestion.severity === "medium" ? pc.cyan
            : pc.dim;

        console.log(`${severityColor("●")} ${pc.bold(suggestion.label)} (${suggestion.totalOccurrences} occurrences)`);

        // Show top 2 remediation steps
        for (const step of suggestion.remediation.slice(0, 2)) {
          console.log(`  ${pc.dim("→")} ${step}`);
        }
        console.log("");
      }

      console.log(pc.dim("-".repeat(70)));
    }

    // Save report
    const reportPath = path.join(cwd, ".ralph", "diagnosis.md");
    diagnoseModule.saveDiagnosisReport(results, reportPath);
    success(`Full report saved to ${pc.cyan(reportPath)}`);

    process.exit(0);
  }

  if (cmd === "doctor") {
    const doctorModule = require("../lib/doctor");
    const reporter = require("../lib/doctor/reporter");

    // Parse doctor-specific flags
    let verboseFlag = false;
    let jsonFlag = false;
    let fixFlag = false;

    for (let i = 1; i < args.length; i++) {
      const arg = args[i];
      if (arg === "--verbose" || arg === "-v") {
        verboseFlag = true;
      } else if (arg === "--json") {
        jsonFlag = true;
      } else if (arg === "--fix") {
        fixFlag = true;
      }
    }

    // Run all diagnostics
    const results = doctorModule.runAllChecks(cwd);

    // Handle --fix flag
    if (fixFlag) {
      const fixResults = doctorModule.applyFixes(results, cwd);

      if (jsonFlag) {
        console.log(JSON.stringify({ diagnostics: results, fixes: fixResults }, null, 2));
      } else {
        // First show diagnostic results
        if (verboseFlag) {
          console.log(reporter.formatTerminalVerbose(results));
        } else {
          console.log(reporter.formatTerminal(results));
        }

        // Then show fix results
        console.log(reporter.formatFixResults(fixResults));
      }

      process.exit(0);
    }

    // Regular output (no --fix)
    if (jsonFlag) {
      console.log(reporter.formatJSON(results));
    } else if (verboseFlag) {
      console.log(reporter.formatTerminalVerbose(results));
    } else {
      console.log(reporter.formatTerminal(results));
    }

    // Exit with error code if there are errors
    const hasErrors = results.summary && results.summary.totalErrors > 0;
    process.exit(hasErrors ? 1 : 0);
  }

  if (cmd === "ui") {
    const { spawn } = require("child_process");

    // Parse port from arguments (first non-flag arg after "ui")
    let port = 3000;
    const portArg = args.slice(1).find((a) => !a.startsWith("--") && /^\d+$/.test(a));
    if (portArg) {
      port = parseInt(portArg, 10);
      if (port < 1 || port > 65535) {
        error(`Invalid port number: ${pc.bold(portArg)}`);
        info("Port must be between 1 and 65535.");
        process.exit(1);
      }
    }

    const uiDir = path.join(repoRoot, "ui");
    const serverPath = path.join(uiDir, "src", "server.ts");

    // Check that ui directory exists
    if (!exists(uiDir)) {
      error(`UI directory not found at ${pc.cyan(uiDir)}`);
      process.exit(1);
    }

    // Check that server.ts exists
    if (!exists(serverPath)) {
      error(`Server file not found at ${pc.cyan(serverPath)}`);
      process.exit(1);
    }

    info(`Starting Ralph UI server on port ${pc.bold(port)}...`);

    // Function to open browser based on platform
    const openBrowser = (url) => {
      const platform = os.platform();
      let openCmd;
      let openArgs;

      if (platform === "darwin") {
        openCmd = "open";
        openArgs = [url];
      } else if (platform === "win32") {
        openCmd = "cmd";
        openArgs = ["/c", "start", url];
      } else {
        // Linux and others
        openCmd = "xdg-open";
        openArgs = [url];
      }

      spawn(openCmd, openArgs, {
        detached: true,
        stdio: "ignore",
      }).unref();
    };

    // Spawn the server process
    const serverEnv = { ...process.env, PORT: String(port), RALPH_ROOT: cwd };

    // Use npx tsx to run TypeScript directly
    const serverProcess = spawn("npx", ["tsx", "src/server.ts"], {
      cwd: uiDir,
      env: serverEnv,
      stdio: ["ignore", "pipe", "pipe"],
    });

    let serverStarted = false;
    const serverUrl = `http://localhost:${port}`;

    serverProcess.stdout.on("data", (data) => {
      const output = data.toString();
      process.stdout.write(output);

      // Check if server has started (look for the "running at" message)
      if (!serverStarted && output.includes("running at")) {
        serverStarted = true;
        success(`Server running at ${pc.cyan(serverUrl)}`);

        if (uiOpenBrowser) {
          info("Opening browser...");
          openBrowser(serverUrl);
        }
      }
    });

    serverProcess.stderr.on("data", (data) => {
      const output = data.toString();

      // Check for EADDRINUSE (port in use) error
      if (output.includes("EADDRINUSE") || output.includes("address already in use")) {
        error(`Port ${pc.bold(port)} is already in use.`);
        info(`Try a different port: ${pc.cyan(`ralph ui ${port + 1}`)}`);
        info(`Or stop the process using port ${port} and try again.`);
        serverProcess.kill();
        process.exit(1);
      }

      process.stderr.write(output);
    });

    serverProcess.on("error", (err) => {
      if (err.code === "ENOENT") {
        error("npx command not found. Make sure Node.js is installed.");
      } else {
        error(`Failed to start server: ${err.message}`);
      }
      process.exit(1);
    });

    serverProcess.on("close", (code) => {
      if (code !== 0 && code !== null) {
        error(`Server exited with code ${code}`);
        process.exit(code);
      }
    });

    // Handle SIGINT/SIGTERM to gracefully stop the server
    const cleanup = () => {
      dim("\nStopping server...");
      serverProcess.kill();
      process.exit(0);
    };

    process.on("SIGINT", cleanup);
    process.on("SIGTERM", cleanup);

    // Keep the process running
    return;
  }

  if (cmd === "experiment") {
    const experimentModule = require("../lib/experiment");
    const subCmd = args[1];
    const experimentName = args[2];

    if (!subCmd || subCmd === "help") {
      console.log(`${pc.bold("ralph experiment")} ${pc.dim("<command>")}

${pc.bold(pc.cyan("Commands:"))}
  ${pc.green("create")} ${pc.dim("<name>")}                 Create a new A/B experiment
  ${pc.green("list")} ${pc.dim("[--status <status>]")}    List all experiments
  ${pc.green("status")} ${pc.dim("<name>")}                Show experiment details and statistics
  ${pc.green("start")} ${pc.dim("<name>")}                 Start an experiment (enable traffic split)
  ${pc.green("pause")} ${pc.dim("<name>")}                 Pause an experiment
  ${pc.green("conclude")} ${pc.dim("<name>")}              Conclude an experiment
  ${pc.green("analyze")} ${pc.dim("<name> [options]")}     Analyze results with statistics

${pc.bold(pc.cyan("Analyze Options:"))}
  ${pc.yellow("--json")}                     Export results as JSON
  ${pc.yellow("--csv")}                      Export results as CSV
  ${pc.yellow("--confidence")} ${pc.dim("<N>")}           Min confidence % for winner (default: 95)

${pc.bold(pc.cyan("Examples:"))}
  ${pc.dim("ralph experiment create claude-vs-codex")}
  ${pc.dim("ralph experiment start claude-vs-codex")}
  ${pc.dim("ralph experiment status claude-vs-codex")}
  ${pc.dim("ralph experiment analyze claude-vs-codex")}
  ${pc.dim("ralph experiment analyze claude-vs-codex --json > results.json")}
  ${pc.dim("ralph experiment list --status running")}
`);
      process.exit(0);
    }

    if (subCmd === "create") {
      if (!experimentName) {
        error("Experiment name is required.");
        info(`Usage: ${pc.cyan("ralph experiment create <name>")}`);
        process.exit(1);
      }

      // Interactive experiment creation
      const { intro, outro, text, select, isCancel } = await import("@clack/prompts");
      intro("Create A/B Experiment");

      // Select control agent
      const controlAgent = await select({
        message: "Select the control variant agent:",
        options: [
          { value: "claude", label: "Claude" },
          { value: "codex", label: "Codex" },
          { value: "droid", label: "Droid" },
        ],
        initialValue: "claude",
      });

      if (isCancel(controlAgent)) {
        outro("Cancelled.");
        process.exit(0);
      }

      // Select treatment agent
      const treatmentAgent = await select({
        message: "Select the treatment variant agent:",
        options: [
          { value: "codex", label: "Codex" },
          { value: "claude", label: "Claude" },
          { value: "droid", label: "Droid" },
        ].filter((o) => o.value !== controlAgent),
        initialValue: controlAgent === "claude" ? "codex" : "claude",
      });

      if (isCancel(treatmentAgent)) {
        outro("Cancelled.");
        process.exit(0);
      }

      // Select traffic split
      const trafficSplit = await select({
        message: "Select traffic split:",
        options: [
          { value: "50-50", label: "50/50 (equal split)" },
          { value: "80-20", label: "80/20 (control heavy)" },
          { value: "20-80", label: "20/80 (treatment heavy)" },
          { value: "70-30", label: "70/30" },
          { value: "30-70", label: "30/70" },
        ],
        initialValue: "50-50",
      });

      if (isCancel(trafficSplit)) {
        outro("Cancelled.");
        process.exit(0);
      }

      const [controlWeight, treatmentWeight] = trafficSplit.split("-").map(Number);

      // Get description (optional)
      const description = await text({
        message: "Description (optional):",
        placeholder: `Compare ${controlAgent} vs ${treatmentAgent} performance`,
        defaultValue: `Compare ${controlAgent} vs ${treatmentAgent} performance`,
      });

      if (isCancel(description)) {
        outro("Cancelled.");
        process.exit(0);
      }

      // Select minimum samples
      const minSamplesChoice = await select({
        message: "Minimum samples before analysis:",
        options: [
          { value: 30, label: "30 (quick test)" },
          { value: 50, label: "50 (small experiment)" },
          { value: 100, label: "100 (recommended)" },
          { value: 200, label: "200 (high confidence)" },
        ],
        initialValue: 100,
      });

      if (isCancel(minSamplesChoice)) {
        outro("Cancelled.");
        process.exit(0);
      }

      // Create the experiment
      const result = experimentModule.createQuickExperiment(
        cwd,
        experimentName,
        controlAgent,
        treatmentAgent,
        {
          description: description || `Compare ${controlAgent} vs ${treatmentAgent} performance`,
          controlWeight,
          treatmentWeight,
          minSamples: minSamplesChoice,
        }
      );

      if (!result.success) {
        error(result.error);
        process.exit(1);
      }

      console.log("");
      console.log(pc.bold("Experiment Created"));
      console.log(pc.dim("-".repeat(50)));
      console.log(`Name:           ${pc.bold(result.experiment.name)}`);
      console.log(`Status:         ${pc.yellow("draft")}`);
      console.log(`Control:        ${pc.cyan(controlAgent)} (${controlWeight}%)`);
      console.log(`Treatment:      ${pc.cyan(treatmentAgent)} (${treatmentWeight}%)`);
      console.log(`Min Samples:    ${minSamplesChoice}`);
      console.log(pc.dim("-".repeat(50)));
      console.log("");

      success(`Experiment saved to ${pc.cyan(result.path)}`);
      info(`Run ${pc.cyan(`ralph experiment start ${experimentName}`)} to begin.`);

      outro("Done.");
      process.exit(0);
    }

    if (subCmd === "list") {
      // Parse --status flag
      let statusFilter = null;
      for (let i = 2; i < args.length; i++) {
        if (args[i].startsWith("--status=")) {
          statusFilter = args[i].split("=").slice(1).join("=");
        } else if (args[i] === "--status" && args[i + 1]) {
          statusFilter = args[++i];
        }
      }

      const result = experimentModule.listExperiments(cwd, { status: statusFilter });

      if (!result.success) {
        error(result.error);
        process.exit(1);
      }

      if (result.experiments.length === 0) {
        if (statusFilter) {
          warn(`No experiments found with status: ${statusFilter}`);
        } else {
          warn("No experiments found.");
          info(`Create one with ${pc.cyan("ralph experiment create <name>")}`);
        }
        process.exit(0);
      }

      console.log("");
      console.log(pc.bold(`Experiments (${result.experiments.length})`));
      console.log(pc.dim("-".repeat(70)));
      console.log(
        pc.dim(
          `${"NAME".padEnd(25)} ${"STATUS".padEnd(12)} ${"VARIANTS".padEnd(20)} ${"MIN SAMPLES".padStart(12)}`
        )
      );
      console.log(pc.dim("-".repeat(70)));

      for (const exp of result.experiments) {
        const name = exp.name.length > 23 ? exp.name.slice(0, 22) + "\u2026" : exp.name;
        const statusColor =
          exp.status === "running" ? pc.green
            : exp.status === "paused" ? pc.yellow
            : exp.status === "concluded" ? pc.cyan
            : pc.dim;
        const status = statusColor(exp.status.padEnd(12));
        const variantNames = Object.keys(exp.variants).join(" vs ");
        const variants = variantNames.length > 18 ? variantNames.slice(0, 17) + "\u2026" : variantNames;
        const minSamples = String(exp.minSamples).padStart(12);

        console.log(`${name.padEnd(25)} ${status} ${variants.padEnd(20)} ${minSamples}`);
      }

      console.log(pc.dim("-".repeat(70)));
      console.log("");
      process.exit(0);
    }

    if (subCmd === "status") {
      if (!experimentName) {
        error("Experiment name is required.");
        info(`Usage: ${pc.cyan("ralph experiment status <name>")}`);
        process.exit(1);
      }

      const result = experimentModule.loadExperiment(cwd, experimentName);

      if (!result.success) {
        error(result.error);
        process.exit(1);
      }

      const exp = result.experiment;
      const statusColor =
        exp.status === "running" ? pc.green
          : exp.status === "paused" ? pc.yellow
          : exp.status === "concluded" ? pc.cyan
          : pc.dim;

      console.log("");
      console.log(pc.bold(`Experiment: ${exp.name}`));
      console.log(pc.dim("=".repeat(60)));
      console.log("");

      console.log(pc.bold(pc.cyan("Configuration")));
      console.log(pc.dim("-".repeat(40)));
      console.log(`Status:         ${statusColor(exp.status)}`);
      console.log(`Description:    ${exp.description || pc.dim("(none)")}`);
      console.log(`Min Samples:    ${exp.minSamples}`);
      console.log(`Max Samples:    ${exp.maxSamples || pc.dim("unlimited")}`);
      console.log(`Duration:       ${exp.duration ? `${exp.duration} days` : pc.dim("unlimited")}`);
      console.log(`Created:        ${exp.createdAt}`);
      console.log(`Updated:        ${exp.updatedAt}`);
      console.log("");

      console.log(pc.bold(pc.cyan("Variants")));
      console.log(pc.dim("-".repeat(40)));

      for (const [variantName, variant] of Object.entries(exp.variants)) {
        const agentColor = variant.agent === "claude" ? pc.cyan : variant.agent === "codex" ? pc.green : pc.yellow;
        console.log(`${variantName.padEnd(15)} ${agentColor(variant.agent.padEnd(10))} ${variant.weight}% weight`);
      }
      console.log("");

      console.log(pc.bold(pc.cyan("Metrics Tracked")));
      console.log(pc.dim("-".repeat(40)));
      console.log(`  ${exp.metrics.join(", ")}`);
      console.log("");

      if (exp.exclusions && exp.exclusions.length > 0) {
        console.log(pc.bold(pc.cyan("Exclusions")));
        console.log(pc.dim("-".repeat(40)));
        for (const pattern of exp.exclusions) {
          console.log(`  - ${pattern}`);
        }
        console.log("");
      }

      console.log(pc.dim("=".repeat(60)));
      process.exit(0);
    }

    if (subCmd === "start") {
      if (!experimentName) {
        error("Experiment name is required.");
        info(`Usage: ${pc.cyan("ralph experiment start <name>")}`);
        process.exit(1);
      }

      const result = experimentModule.startExperiment(cwd, experimentName);

      if (!result.success) {
        error(result.error);
        process.exit(1);
      }

      success(`Experiment ${pc.bold(experimentName)} is now ${pc.green("running")}.`);
      info("Stories will now be assigned to variants based on traffic split.");
      process.exit(0);
    }

    if (subCmd === "pause") {
      if (!experimentName) {
        error("Experiment name is required.");
        info(`Usage: ${pc.cyan("ralph experiment pause <name>")}`);
        process.exit(1);
      }

      const result = experimentModule.pauseExperiment(cwd, experimentName);

      if (!result.success) {
        error(result.error);
        process.exit(1);
      }

      success(`Experiment ${pc.bold(experimentName)} is now ${pc.yellow("paused")}.`);
      info("No new stories will be assigned to variants.");
      process.exit(0);
    }

    if (subCmd === "conclude") {
      if (!experimentName) {
        error("Experiment name is required.");
        info(`Usage: ${pc.cyan("ralph experiment conclude <name>")}`);
        process.exit(1);
      }

      const result = experimentModule.concludeExperiment(cwd, experimentName);

      if (!result.success) {
        error(result.error);
        process.exit(1);
      }

      success(`Experiment ${pc.bold(experimentName)} is now ${pc.cyan("concluded")}.`);
      info("No further assignments will be made. Results are final.");
      process.exit(0);
    }

    if (subCmd === "analyze") {
      if (!experimentName) {
        error("Experiment name is required.");
        info(`Usage: ${pc.cyan("ralph experiment analyze <name> [--json|--csv]")}`);
        process.exit(1);
      }

      // Parse options
      let outputFormat = "terminal"; // default
      let minConfidence = 95;

      for (let i = 3; i < args.length; i++) {
        if (args[i] === "--json") {
          outputFormat = "json";
        } else if (args[i] === "--csv") {
          outputFormat = "csv";
        } else if (args[i].startsWith("--confidence=")) {
          minConfidence = parseInt(args[i].split("=")[1], 10);
        } else if (args[i] === "--confidence" && args[i + 1]) {
          minConfidence = parseInt(args[++i], 10);
        }
      }

      // Run analysis
      const analysis = experimentModule.analyzeExperiment(cwd, experimentName, {
        minConfidence,
      });

      if (!analysis.success) {
        error(analysis.error);
        process.exit(1);
      }

      // Output based on format
      if (outputFormat === "json") {
        console.log(experimentModule.exportAsJSON(analysis));
      } else if (outputFormat === "csv") {
        console.log(experimentModule.exportAsCSV(analysis));
      } else {
        console.log(experimentModule.formatForTerminal(analysis));

        // Additional context for terminal output
        if (!analysis.minSamplesReached) {
          warn(`Minimum samples not reached (${analysis.totalSamples}/${analysis.minSamples}).`);
          info("Results may not be statistically valid yet.");
        }

        if (analysis.winner.winner) {
          success(`Winner: ${pc.bold(analysis.winner.winner)} at ${analysis.winner.confidence}% confidence`);
        } else if (analysis.winner.proposedWinner) {
          info(`Proposed winner: ${pc.bold(analysis.winner.proposedWinner)} (needs higher confidence)`);
        }
      }

      process.exit(0);
    }

    error(`Unknown experiment command: ${pc.bold(subCmd)}`);
    info(`Run ${pc.cyan("ralph experiment help")} for usage.`);
    process.exit(1);
  }

  const result = spawnSync(loopPath, loopArgs, {
    stdio: "inherit",
    env,
  });

  process.exit(result.status ?? 1);
}

main().catch((err) => {
  error(err.message || err);
  process.exit(1);
});
