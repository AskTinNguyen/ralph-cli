#!/usr/bin/env node
/**
 * Ralph CLI - Thin Dispatcher
 *
 * This is a refactored, minimal entry point that dispatches commands to
 * their respective modules in lib/commands/. This reduces context
 * consumption from ~31k tokens to ~2k tokens.
 *
 * Commands are loaded on demand to minimize startup time.
 */
const { spawnSync } = require("child_process");

// Helper to spawn bash scripts cross-platform (Windows needs explicit bash)
const spawnBashScript = (scriptPath, args, options) => {
  if (process.platform === "win32") {
    return spawnSync("bash", [scriptPath, ...args], options);
  }
  return spawnSync(scriptPath, args, options);
};

const fs = require("fs");
const os = require("os");
const path = require("path");
const pc = require("picocolors");

// ============================================================================
// Configuration
// ============================================================================
// Import path utilities for finding project root
const { getEffectiveCwd } = require("../lib/cli/paths");

// Use effective cwd that walks up to find .ralph directory
// This ensures commands work correctly from subdirectories (e.g., ui/)
const cwd = getEffectiveCwd(process.cwd());
const repoRoot = path.resolve(__dirname, "..");
const globalDir = path.join(repoRoot, ".agents", "ralph");
const localDir = path.join(cwd, ".agents", "ralph");

// ============================================================================
// Utility Functions
// ============================================================================
const _success = (msg) => console.log(pc.green(msg)); // Reserved for future use
const error = (msg) => console.error(pc.red(msg));
const info = (msg) => console.log(pc.cyan(msg));
const dim = (msg) => console.log(pc.dim(msg));
const warn = (msg) => console.warn(pc.yellow(msg));

function exists(p) {
  try {
    fs.accessSync(p);
    return true;
  } catch {
    return false;
  }
}

// ============================================================================
// Argument Parsing
// ============================================================================
const rawArgs = process.argv.slice(2);
const args = [];
const globalFlags = {
  agentOverride: null,
  prdNumber: null,
  prdPath: null,
  planPath: null,
  progressPath: null,
  prdOutPath: null,
  resumeMode: false,
  noRetry: false,
  modelOverride: null,
  autoFixMode: null,
  skipRiskCheck: false,
  parallelConcurrency: null,
  installSkills: false,
  installForce: false,
  importFromProject: null,
  uiOpenBrowser: false,
  watchBuildMode: false,
  estimatePricing: null,
  historyMode: null, // Historical log context: off, smart, full
};

// Parse global flags from rawArgs
for (let i = 0; i < rawArgs.length; i++) {
  const arg = rawArgs[i];

  // --agent flag
  if (arg.startsWith("--agent=")) {
    globalFlags.agentOverride = arg.split("=").slice(1).join("=");
    continue;
  }
  if (arg === "--agent") {
    globalFlags.agentOverride = rawArgs[++i];
    continue;
  }

  // --prd flag
  if (arg.startsWith("--prd=")) {
    const val = arg.split("=").slice(1).join("=");
    if (/^\d+$/.test(val)) {
      globalFlags.prdNumber = val;
    } else {
      globalFlags.prdPath = val;
    }
    continue;
  }
  if (arg === "--prd") {
    const val = rawArgs[++i];
    if (/^\d+$/.test(val)) {
      globalFlags.prdNumber = val;
    } else {
      globalFlags.prdPath = val;
    }
    continue;
  }

  // --out flag
  if (arg.startsWith("--out=")) {
    globalFlags.prdOutPath = arg.split("=").slice(1).join("=");
    continue;
  }
  if (arg === "--out") {
    globalFlags.prdOutPath = rawArgs[++i];
    continue;
  }

  // --plan flag
  if (arg.startsWith("--plan=")) {
    globalFlags.planPath = arg.split("=").slice(1).join("=");
    continue;
  }
  if (arg === "--plan") {
    globalFlags.planPath = rawArgs[++i];
    continue;
  }

  // --progress flag
  if (arg.startsWith("--progress=")) {
    globalFlags.progressPath = arg.split("=").slice(1).join("=");
    continue;
  }
  if (arg === "--progress") {
    globalFlags.progressPath = rawArgs[++i];
    continue;
  }

  // --tags flag (skip, handled per-command)
  if (arg.startsWith("--tags=") || arg === "--tags") {
    if (arg === "--tags") i++;
    continue;
  }

  // Boolean flags
  if (arg === "--skills") { globalFlags.installSkills = true; continue; }
  if (arg === "--force") { globalFlags.installForce = true; args.push(arg); continue; }
  if (arg === "--open") { globalFlags.uiOpenBrowser = true; continue; }
  if (arg === "--resume") { globalFlags.resumeMode = true; continue; }
  if (arg === "--no-retry") { globalFlags.noRetry = true; continue; }
  if (arg === "--build") { globalFlags.watchBuildMode = true; continue; }
  if (arg === "--skip-risk-check") { globalFlags.skipRiskCheck = true; continue; }
  if (arg === "--with-history") { globalFlags.historyMode = "smart"; continue; }
  if (arg === "--no-history") { globalFlags.historyMode = "off"; continue; }

  // --import-from flag
  if (arg.startsWith("--import-from=")) {
    globalFlags.importFromProject = arg.split("=").slice(1).join("=");
    continue;
  }
  if (arg === "--import-from") {
    globalFlags.importFromProject = rawArgs[++i];
    continue;
  }

  // --model flag
  if (arg.startsWith("--model=")) {
    globalFlags.modelOverride = arg.split("=").slice(1).join("=");
    continue;
  }
  if (arg === "--model") {
    globalFlags.modelOverride = rawArgs[++i];
    continue;
  }

  // --auto-fix flag
  if (arg.startsWith("--auto-fix=")) {
    globalFlags.autoFixMode = arg.split("=").slice(1).join("=");
    continue;
  }
  if (arg === "--auto-fix") {
    globalFlags.autoFixMode = rawArgs[++i];
    continue;
  }

  // --pricing flag
  if (arg.startsWith("--pricing=")) {
    globalFlags.estimatePricing = arg.split("=").slice(1).join("=");
    continue;
  }
  if (arg === "--pricing") {
    globalFlags.estimatePricing = rawArgs[++i];
    continue;
  }

  // --history-mode flag (Historical Log Context)
  if (arg.startsWith("--history-mode=")) {
    const mode = arg.split("=").slice(1).join("=");
    if (!["off", "smart", "full"].includes(mode)) {
      error(`Invalid --history-mode value: ${mode}. Must be: off, smart, or full`);
      process.exit(1);
    }
    globalFlags.historyMode = mode;
    continue;
  }
  if (arg === "--history-mode") {
    const mode = rawArgs[++i];
    if (!["off", "smart", "full"].includes(mode)) {
      error(`Invalid --history-mode value: ${mode}. Must be: off, smart, or full`);
      process.exit(1);
    }
    globalFlags.historyMode = mode;
    continue;
  }

  // --parallel flag
  if (arg.startsWith("--parallel=")) {
    const val = arg.split("=").slice(1).join("=");
    const num = parseInt(val, 10);
    if (isNaN(num) || num < 1) {
      error(`Invalid --parallel value: ${val}. Must be a positive integer.`);
      process.exit(1);
    }
    globalFlags.parallelConcurrency = num;
    continue;
  }
  if (arg === "--parallel") {
    const val = rawArgs[++i];
    const num = parseInt(val, 10);
    if (isNaN(num) || num < 1) {
      error(`Invalid --parallel value: ${val}. Must be a positive integer.`);
      process.exit(1);
    }
    globalFlags.parallelConcurrency = num;
    continue;
  }

  // Pass through other args
  args.push(arg);
}

const cmd = args[0];

// ============================================================================
// Version Shortcut
// ============================================================================
if (cmd === "--version" || cmd === "-v" || cmd === "version") {
  const { version } = require("../lib/commands/version");
  version();
  process.exit(0);
}

// ============================================================================
// Help Shortcut
// ============================================================================
if (cmd === "help" || cmd === "-h" || cmd === "--help" || !cmd) {
  const helpCmd = require("../lib/commands/help");
  helpCmd.run().then((code) => process.exit(code));
  return;
}

// ============================================================================
// Agent Configuration
// ============================================================================
const templateDir = exists(localDir) ? localDir : globalDir;

function loadAgentMap() {
  const defaults = {
    codex: "codex exec --yolo --skip-git-repo-check -",
    claude: 'claude -p --dangerously-skip-permissions "$(cat {prompt})"',
    droid: "droid exec --skip-permissions-unsafe -f {prompt}",
  };
  const interactiveDefaults = {
    codex: "codex --yolo {prompt}",
    claude: "claude --dangerously-skip-permissions {prompt}",
    droid: "droid --skip-permissions-unsafe {prompt}",
  };

  const agentsPath = path.join(templateDir, "agents.sh");
  if (!exists(agentsPath)) {
    return { headless: defaults, interactive: interactiveDefaults, defaultAgent: "claude" };
  }

  const safePath = agentsPath.replace(/'/g, "'\\''");
  const bashCmd = [
    `source '${safePath}'`,
    'printf "DEFAULT_AGENT=%s\\n" "${DEFAULT_AGENT:-}"',
    'printf "AGENT_CODEX_CMD=%s\\n" "${AGENT_CODEX_CMD:-}"',
    'printf "AGENT_CLAUDE_CMD=%s\\n" "${AGENT_CLAUDE_CMD:-}"',
    'printf "AGENT_DROID_CMD=%s\\n" "${AGENT_DROID_CMD:-}"',
    'printf "AGENT_CODEX_INTERACTIVE_CMD=%s\\n" "${AGENT_CODEX_INTERACTIVE_CMD:-}"',
    'printf "AGENT_CLAUDE_INTERACTIVE_CMD=%s\\n" "${AGENT_CLAUDE_INTERACTIVE_CMD:-}"',
    'printf "AGENT_DROID_INTERACTIVE_CMD=%s\\n" "${AGENT_DROID_INTERACTIVE_CMD:-}"',
  ].join("; ");

  const result = spawnSync("bash", ["-lc", bashCmd], { encoding: "utf-8" });
  if (result.status !== 0) {
    return { headless: defaults, interactive: interactiveDefaults, defaultAgent: "claude" };
  }

  const parsed = new Map();
  for (const line of String(result.stdout || "").split("\n")) {
    if (!line) continue;
    const idx = line.indexOf("=");
    if (idx === -1) continue;
    parsed.set(line.slice(0, idx), line.slice(idx + 1));
  }
  const readVar = (name) => parsed.get(name) || null;

  return {
    headless: {
      codex: readVar("AGENT_CODEX_CMD") || defaults.codex,
      claude: readVar("AGENT_CLAUDE_CMD") || defaults.claude,
      droid: readVar("AGENT_DROID_CMD") || defaults.droid,
    },
    interactive: {
      codex: readVar("AGENT_CODEX_INTERACTIVE_CMD") || interactiveDefaults.codex,
      claude: readVar("AGENT_CLAUDE_INTERACTIVE_CMD") || interactiveDefaults.claude,
      droid: readVar("AGENT_DROID_INTERACTIVE_CMD") || interactiveDefaults.droid,
    },
    defaultAgent: readVar("DEFAULT_AGENT") || "claude",
  };
}

// ============================================================================
// Environment Setup
// ============================================================================
const agentDefs = loadAgentMap();
const agentMap = agentDefs.headless;
const agentInteractiveMap = agentDefs.interactive;
const defaultAgent = agentDefs.defaultAgent;

// Validate agent override
if (globalFlags.agentOverride && !agentMap[globalFlags.agentOverride]) {
  error(`Unknown agent: ${pc.bold(globalFlags.agentOverride)}`);
  error(`Valid values: ${pc.cyan("codex")}, ${pc.cyan("claude")}, ${pc.cyan("droid")}`);
  process.exit(1);
}

// Build environment for shell scripts
const env = { ...process.env, RALPH_ROOT: cwd };
if (!env.ACTIVITY_CMD) env.ACTIVITY_CMD = "ralph log";
if (globalFlags.agentOverride) env.AGENT_CMD = agentMap[globalFlags.agentOverride];
if (globalFlags.prdNumber) env.PRD_NUMBER = globalFlags.prdNumber;
if (globalFlags.prdPath || globalFlags.prdOutPath) env.PRD_PATH = globalFlags.prdOutPath || globalFlags.prdPath;
if (globalFlags.planPath) env.PLAN_PATH = globalFlags.planPath;
if (globalFlags.progressPath) env.PROGRESS_PATH = globalFlags.progressPath;
if (globalFlags.noRetry) env.NO_RETRY = "true";
if (globalFlags.resumeMode) env.RALPH_RESUME = "1";
if (globalFlags.modelOverride) env.RALPH_MODEL_OVERRIDE = globalFlags.modelOverride;
if (globalFlags.autoFixMode) env.AUTO_FIX = globalFlags.autoFixMode;
if (globalFlags.skipRiskCheck) env.RALPH_SKIP_RISK = "1";
if (globalFlags.historyMode) env.RALPH_HISTORY_MODE = globalFlags.historyMode;

if (templateDir === globalDir) {
  env.PROMPT_PLAN = path.join(templateDir, "PROMPT_plan.md");
  env.PROMPT_BUILD = path.join(templateDir, "PROMPT_build.md");
  env.GUARDRAILS_REF = path.join(templateDir, "references", "GUARDRAILS.md");
  env.CONTEXT_REF = path.join(templateDir, "references", "CONTEXT_ENGINEERING.md");
}

// ============================================================================
// Command Options for Modules
// ============================================================================
const commandOptions = {
  cwd,
  repoRoot,
  templateDir,
  globalDir,
  localDir,
  agentMap,
  agentInteractiveMap,
  defaultAgent,
  agentOverride: globalFlags.agentOverride,
  prdNumber: globalFlags.prdNumber,
  prdPath: globalFlags.prdPath,
  rawArgs, // Pass raw args for commands that need special flag parsing
  ...globalFlags,
};

// ============================================================================
// Checkpoint Validation & Resume Helpers (US-005)
// ============================================================================

/**
 * Validate checkpoint state before resuming
 * Checks: git SHA match, plan.md hash unchanged
 * @param {string} prdFolder - Path to PRD folder
 * @param {Object} checkpoint - Loaded checkpoint data
 * @returns {Object} { valid: boolean, error?: string, warnings?: string[] }
 */
async function validateCheckpointState(prdFolder, checkpoint) {
  const crypto = require("crypto");
  const warnings = [];

  // 1. Validate git state matches checkpoint
  if (checkpoint.git_sha) {
    try {
      const { execSync } = require("child_process");
      const currentSha = execSync("git rev-parse HEAD", { encoding: "utf-8", cwd }).trim();
      if (currentSha !== checkpoint.git_sha) {
        // Git state has diverged - this is a warning, not an error in auto-detect mode
        warnings.push(`Git SHA changed: checkpoint=${checkpoint.git_sha.slice(0, 8)} current=${currentSha.slice(0, 8)}`);
      }
    } catch {
      warnings.push("Could not verify git state");
    }
  }

  // 2. Validate plan.md hash unchanged
  if (checkpoint.plan_hash) {
    try {
      const planPath = path.join(prdFolder, "plan.md");
      if (exists(planPath)) {
        const planContent = fs.readFileSync(planPath, "utf-8");
        const currentHash = crypto.createHash("sha256").update(planContent).digest("hex");
        if (currentHash !== checkpoint.plan_hash) {
          return {
            valid: false,
            error: "plan.md has changed since checkpoint was created",
          };
        }
      }
    } catch {
      warnings.push("Could not verify plan.md hash");
    }
  }

  return { valid: true, warnings };
}

/**
 * Prompt user to resume from checkpoint
 * @param {Object} checkpoint - Loaded checkpoint data
 * @param {string} agent - Agent name used in checkpoint
 * @param {string[]} warnings - Validation warnings to display
 * @returns {string} "resume" | "fresh" | "cancel"
 */
async function promptResumeCheckpoint(checkpoint, agent, warnings = []) {
  try {
    const { intro, select, isCancel } = await import("@clack/prompts");

    console.log("");
    intro(pc.cyan("Checkpoint Detected"));

    // Show checkpoint details
    console.log("");
    console.log(pc.dim("  Last iteration: ") + pc.bold(checkpoint.iteration));
    console.log(pc.dim("  Story ID:       ") + pc.bold(checkpoint.story_id || "unknown"));
    console.log(pc.dim("  Agent:          ") + pc.bold(agent));
    if (checkpoint.created_at) {
      const date = new Date(checkpoint.created_at);
      console.log(pc.dim("  Created:        ") + pc.bold(date.toLocaleString()));
    }

    // Show warnings if any
    if (warnings.length > 0) {
      console.log("");
      console.log(pc.yellow("  Warnings:"));
      for (const w of warnings) {
        console.log(pc.yellow(`    • ${w}`));
      }
    }
    console.log("");

    const response = await select({
      message: "Resume from checkpoint?",
      options: [
        { value: "resume", label: "Yes, resume from checkpoint", hint: "continue where you left off" },
        { value: "fresh", label: "No, start fresh", hint: "clears checkpoint and starts from iteration 1" },
        { value: "cancel", label: "Cancel", hint: "exit without building" },
      ],
    });

    if (isCancel(response)) {
      return "cancel";
    }

    return response;
  } catch (err) {
    // Fallback to simple prompt if @clack/prompts fails
    if (err.message && err.message.includes("uv_tty_init")) {
      // TTY not available - treat as non-interactive
      return "resume";
    }
    throw err;
  }
}

// ============================================================================
// Command Dispatch
// ============================================================================
async function main() {
  // Alias: gui -> ui (gui auto-opens browser)
  const isGuiCommand = cmd === "gui";
  const actualCmd = isGuiCommand ? "ui" : cmd;
  if (isGuiCommand) globalFlags.uiOpenBrowser = true;

  // Commands with dedicated modules (extracted to lib/commands/)
  const moduleCommands = [
    // Getting Started
    "help", "doctor", "log", "ping", "completions", "init", "install",
    // Analytics & Estimation
    "ui", "stats", "checkpoint", "eval", "estimate", "improve",
    // Budget Management (US-008)
    "budget",
    // Cost Audit (Token Cost Analysis)
    "audit",
    // Diagnostics & Experimentation
    "diagnose", "experiment", "watch", "optimize",
    // Project & Knowledge Management
    "registry", "search", "import", "routing",
    // Error Management
    "error",
    // Notifications (US-012)
    "notify",
    // Factory Mode (Meta-orchestration)
    "factory",
    // Automation (Executive Reporting - US-013)
    "automation",
    // Voice Control
    "voice",
    "speak",
    "recap",
    // Quality Review
    "review",
  ];

  if (moduleCommands.includes(actualCmd)) {
    try {
      const command = require(`../lib/commands/${actualCmd}`);
      const exitCode = await command.run(args, env, commandOptions);
      process.exit(exitCode ?? 0);
    } catch (err) {
      error(`Error in ${actualCmd}: ${err.message}`);
      if (process.env.DEBUG) console.error(err);
      process.exit(1);
    }
  }

  // Commands that delegate to loop.sh or stream.sh
  const loopPath = path.join(templateDir, "loop.sh");
  const streamPath = path.join(templateDir, "stream.sh");

  if (!exists(templateDir)) {
    error("No .agents/ralph found locally and no bundled defaults available.");
    process.exit(1);
  }

  // Log template location
  if (templateDir === localDir) {
    info(`Using local templates: ${pc.dim(localDir)}`);
  } else {
    info(`Using bundled templates: ${pc.dim(globalDir)}`);
  }

  // Stream command
  if (cmd === "stream") {
    if (!exists(streamPath)) {
      error("stream.sh not found. Make sure Ralph is up to date.");
      process.exit(1);
    }
    const streamArgs = args.slice(1);
    const result = spawnBashScript(streamPath, streamArgs, { stdio: "inherit", env });
    process.exit(result.status ?? 1);
  }

  // Budget command (US-008)
  if (cmd === "budget") {
    const budgetArgs = args.slice(1);
    const subCmd = budgetArgs[0] || "show";

    // Get active PRD folder
    const ralphDir = path.join(process.cwd(), ".ralph");
    let activePrd = null;
    let prdFolder = null;

    // Check for --prd flag
    const prdFlagIdx = budgetArgs.findIndex(a => a.startsWith("--prd="));
    if (prdFlagIdx !== -1) {
      activePrd = budgetArgs[prdFlagIdx].split("=")[1];
      budgetArgs.splice(prdFlagIdx, 1);
    }

    if (!activePrd) {
      // Find latest PRD
      if (exists(ralphDir)) {
        const dirs = fs.readdirSync(ralphDir)
          .filter(d => /^PRD-\d+$/i.test(d))
          .sort((a, b) => parseInt(b.split("-")[1]) - parseInt(a.split("-")[1]));
        if (dirs.length > 0) {
          activePrd = dirs[0].split("-")[1];
        }
      }
    }

    if (!activePrd) {
      error("No PRD found. Run 'ralph prd' first to create one.");
      process.exit(1);
    }

    prdFolder = path.join(ralphDir, `PRD-${activePrd}`);
    const budgetFile = path.join(prdFolder, ".budget.json");

    if (subCmd === "set") {
      const amount = parseFloat(budgetArgs[1]);
      if (isNaN(amount) || amount <= 0) {
        error("Invalid budget amount. Usage: ralph budget set <amount>");
        info(`Example: ${pc.cyan("ralph budget set 5.00")}`);
        process.exit(1);
      }

      // Check for --no-enforce flag
      const noEnforce = budgetArgs.includes("--no-enforce");
      const enforce = !noEnforce;

      const budgetConfig = {
        limit: amount,
        warnings: [0.75, 0.90],
        enforce: enforce,
        created_at: new Date().toISOString()
      };

      fs.writeFileSync(budgetFile, JSON.stringify(budgetConfig, null, 2));
      info(`Budget set: ${pc.green("$" + amount.toFixed(2))} for PRD-${activePrd}`);
      if (!enforce) {
        info(`Enforcement: ${pc.yellow("disabled")} (warnings only)`);
      }
      process.exit(0);
    }

    if (subCmd === "show" || subCmd === "status") {
      if (!exists(budgetFile)) {
        info(`No budget set for PRD-${activePrd}`);
        info(`Use ${pc.cyan("ralph budget set <amount>")} to set a budget`);
        process.exit(0);
      }

      const budget = JSON.parse(fs.readFileSync(budgetFile, "utf8"));
      const costFile = path.join(prdFolder, ".cost.json");
      let currentCost = 0;
      if (exists(costFile)) {
        const cost = JSON.parse(fs.readFileSync(costFile, "utf8"));
        currentCost = cost.total_cost || 0;
      }

      const percentage = budget.limit > 0 ? Math.round((currentCost / budget.limit) * 100) : 0;
      const color = percentage >= 100 ? pc.red : percentage >= 90 ? pc.yellow : percentage >= 75 ? pc.yellow : pc.green;

      console.log("");
      console.log(`  ${pc.bold("Budget Status")} - PRD-${activePrd}`);
      console.log(`  ${"─".repeat(30)}`);
      console.log(`  Limit:    ${pc.cyan("$" + budget.limit.toFixed(2))}`);
      console.log(`  Current:  ${color("$" + currentCost.toFixed(4))}`);
      console.log(`  Used:     ${color(percentage + "%")}`);
      console.log(`  Enforce:  ${budget.enforce ? pc.green("yes") : pc.yellow("no")}`);
      console.log("");
      process.exit(0);
    }

    if (subCmd === "clear" || subCmd === "remove") {
      if (exists(budgetFile)) {
        fs.unlinkSync(budgetFile);
        info(`Budget cleared for PRD-${activePrd}`);
      } else {
        info(`No budget set for PRD-${activePrd}`);
      }
      process.exit(0);
    }

    error(`Unknown budget command: ${subCmd}`);
    info(`Usage: ${pc.cyan("ralph budget set <amount>")}`);
    info(`       ${pc.cyan("ralph budget show")}`);
    info(`       ${pc.cyan("ralph budget clear")}`);
    process.exit(1);
  }

  // PRD command
  if (cmd === "prd") {
    if (!exists(loopPath)) {
      error(`loop.sh not found at ${pc.cyan(loopPath)}`);
      process.exit(1);
    }

    // Check for --headless flag (for non-interactive/server use)
    const prdArgs = args.slice(1);
    const headlessIndex = prdArgs.indexOf("--headless");
    const isHeadless = headlessIndex !== -1;
    if (isHeadless) prdArgs.splice(headlessIndex, 1);

    let request = prdArgs.join(" ").trim();
    if (!request) {
      if (!process.stdin.isTTY) {
        error("No request provided and stdin is not a TTY.");
        info(`Usage: ${pc.cyan('ralph prd "Your feature description"')}`);
        process.exit(1);
      }
      try {
        const { intro, outro, text, isCancel } = await import("@clack/prompts");
        intro("Ralph PRD");
        const response = await text({
          message: "Describe the feature you want a PRD for",
          placeholder: "Example: A lightweight uptime monitor with email alerts",
        });
        if (isCancel(response)) {
          outro("Cancelled.");
          process.exit(0);
        }
        request = String(response || "").trim();
        if (!request) {
          outro("No description provided.");
          process.exit(1);
        }
        outro("Generating PRD...");
      } catch (err) {
        if (err.message && err.message.includes("uv_tty_init")) {
          error("TTY initialization failed.");
          info(`Usage: ${pc.cyan('ralph prd "Your feature description"')}`);
          process.exit(1);
        }
        throw err;
      }
    }

    const requestFile = path.join(os.tmpdir(), `ralph-prd-${Date.now()}.md`);
    fs.writeFileSync(requestFile, `${request}\n`);

    const agentName = globalFlags.agentOverride || defaultAgent;
    // Use headless (piped) mode when --headless flag is set, otherwise interactive
    const prdAgent = isHeadless
      ? (agentMap[agentName] || agentInteractiveMap[agentName])
      : (agentInteractiveMap[agentName] || agentMap[agentName]);
    if (prdAgent) env.PRD_AGENT_CMD = prdAgent;
    if (isHeadless) env.PRD_HEADLESS = "1";

    const loopPrdArgs = ["prd", "--prompt", requestFile];
    const result = spawnBashScript(loopPath, loopPrdArgs, { stdio: "inherit", env });
    process.exit(result.status ?? 1);
  }

  // Build/Plan commands - delegate to loop.sh
  if (cmd === "build" || cmd === "plan" || !cmd) {
    if (!exists(loopPath)) {
      error(`loop.sh not found at ${pc.cyan(loopPath)}`);
      process.exit(1);
    }

    // Handle parallel execution
    if (globalFlags.parallelConcurrency && (cmd === "build" || !cmd)) {
      const _parallelModule = require("../lib/parallel"); // Reserved for future parallel execution
      // ... parallel execution logic (kept minimal in dispatcher)
      info(`Running parallel execution with ${pc.bold(globalFlags.parallelConcurrency)} concurrent agents...`);
      // This would need the full parallel setup - for now delegate to loop.sh
    }

    // Auto-detect checkpoint and prompt user (US-005)
    if ((cmd === "build" || !cmd) && !globalFlags.resumeMode) {
      const checkpointModule = require("../lib/checkpoint");
      const ralphDir = path.join(cwd, ".ralph");
      let prdFolderToCheck = null;

      if (globalFlags.prdNumber) {
        const upperPath = path.join(ralphDir, `PRD-${globalFlags.prdNumber}`);
        const lowerPath = path.join(ralphDir, `prd-${globalFlags.prdNumber}`);
        if (exists(upperPath)) prdFolderToCheck = upperPath;
        else if (exists(lowerPath)) prdFolderToCheck = lowerPath;
      } else if (exists(ralphDir)) {
        const entries = fs.readdirSync(ralphDir, { withFileTypes: true });
        const prdFolders = entries
          .filter((e) => e.isDirectory() && /^PRD-\d+$/i.test(e.name))
          .sort((a, b) => {
            const numA = parseInt(a.name.replace(/PRD-/i, ""), 10);
            const numB = parseInt(b.name.replace(/PRD-/i, ""), 10);
            return numB - numA;
          });
        if (prdFolders.length > 0) {
          prdFolderToCheck = path.join(ralphDir, prdFolders[0].name);
        }
      }

      if (prdFolderToCheck && checkpointModule.hasCheckpoint(prdFolderToCheck)) {
        const result = checkpointModule.loadCheckpoint(prdFolderToCheck);
        if (result.success && result.checkpoint) {
          const checkpoint = result.checkpoint;
          const agent = checkpoint.loop_state?.agent || "unknown";

          // Validate checkpoint before prompting (US-005)
          const validationResult = await validateCheckpointState(prdFolderToCheck, checkpoint);

          if (validationResult.valid) {
            // Check if we're in interactive mode
            if (process.stdin.isTTY) {
              // Interactive mode - prompt user
              const resumeChoice = await promptResumeCheckpoint(checkpoint, agent, validationResult.warnings);

              if (resumeChoice === "resume") {
                // User chose to resume - set resume mode
                globalFlags.resumeMode = true;
                env.RALPH_RESUME = "1";
                info(`Resuming from iteration ${pc.bold(checkpoint.iteration)}...`);
              } else if (resumeChoice === "fresh") {
                // User chose to start fresh - clear checkpoint
                checkpointModule.clearCheckpoint(prdFolderToCheck);
                info("Checkpoint cleared. Starting fresh build.");
              }
              // If cancelled, exit gracefully
              else if (resumeChoice === "cancel") {
                dim("Build cancelled.");
                process.exit(0);
              }
            } else {
              // Non-interactive mode (CI/CD) - auto-resume
              info(`Checkpoint detected at iteration ${pc.bold(checkpoint.iteration)} (story ${pc.bold(checkpoint.story_id || "unknown")}).`);
              info(`Non-interactive mode: auto-resuming from checkpoint.`);
              globalFlags.resumeMode = true;
              env.RALPH_RESUME = "1";
            }
          } else {
            // Checkpoint validation failed
            console.log("");
            error(`Checkpoint validation failed: ${validationResult.error}`);
            if (process.stdin.isTTY) {
              const { confirm, isCancel } = await import("@clack/prompts");
              const startFresh = await confirm({
                message: "Start fresh build instead?",
                initialValue: true,
              });
              if (isCancel(startFresh) || !startFresh) {
                dim("Build cancelled.");
                process.exit(0);
              }
              checkpointModule.clearCheckpoint(prdFolderToCheck);
              info("Checkpoint cleared. Starting fresh build.");
            } else {
              error("Cannot auto-resume: validation failed. Clear checkpoint manually or run interactively.");
              process.exit(1);
            }
          }
        }
      }
    }

    // Check for TypeScript executor opt-in (US-017)
    if (process.env.RALPH_EXECUTOR === "typescript" && cmd === "build") {
      try {
        info("Using TypeScript executor (RALPH_EXECUTOR=typescript)");
        const executorLoop = require("../lib/executor/loop");

        // Determine PRD paths
        const ralphDir = path.join(cwd, ".ralph");
        let prdFolder = null;

        if (globalFlags.prdNumber) {
          const upperPath = path.join(ralphDir, `PRD-${globalFlags.prdNumber}`);
          const lowerPath = path.join(ralphDir, `prd-${globalFlags.prdNumber}`);
          if (exists(upperPath)) prdFolder = upperPath;
          else if (exists(lowerPath)) prdFolder = lowerPath;
        } else if (exists(ralphDir)) {
          const entries = fs.readdirSync(ralphDir, { withFileTypes: true });
          const prdFolders = entries
            .filter((e) => e.isDirectory() && /^PRD-\d+$/i.test(e.name))
            .sort((a, b) => {
              const numA = parseInt(a.name.replace(/PRD-/i, ""), 10);
              const numB = parseInt(b.name.replace(/PRD-/i, ""), 10);
              return numB - numA;
            });
          if (prdFolders.length > 0) {
            prdFolder = path.join(ralphDir, prdFolders[0].name);
          }
        }

        if (!prdFolder) {
          error("No PRD folder found. Run `ralph prd` first.");
          process.exit(1);
        }

        const config = {
          prdPath: path.join(prdFolder, "prd.md"),
          planPath: path.join(prdFolder, "plan.md"),
          maxIterations: globalFlags.iterations || parseInt(args[0], 10) || 5,
          agent: globalFlags.agent || "claude",
          noCommit: globalFlags.noCommit,
          verbose: globalFlags.verbose,
          workDir: cwd,
          templatesPath: templateDir,
        };

        const result = await executorLoop.runBuild(config);
        process.exit(result.success ? 0 : 1);
      } catch (err) {
        // Graceful fallback to bash loop
        warn(`TypeScript executor failed: ${err.message}`);
        info("Falling back to bash loop...");
        // Continue to bash execution below
      }
    }

    const loopArgs = args.length ? args : ["build"];
    const result = spawnBashScript(loopPath, loopArgs, { stdio: "inherit", env });
    process.exit(result.status ?? 1);
  }

  // Unknown command
  error(`Unknown command: ${pc.bold(cmd)}`);
  info(`Run ${pc.cyan("ralph help")} for available commands.`);
  process.exit(1);
}

main().catch((err) => {
  error(err.message || err);
  process.exit(1);
});
