/**
 * Interactive setup wizard for ralph init
 *
 * Guides users through project configuration with @clack/prompts
 */
const { spawnSync } = require("child_process");
const fs = require("fs");
const path = require("path");
const { detectEnvironment } = require("./detect");

/**
 * Map detected project type to wizard option value
 * @param {string} detectedType - Type from detectEnvironment
 * @returns {string} - Wizard option value
 */
function mapProjectTypeToOption(detectedType) {
  const typeMap = {
    typescript: "nodejs",
    javascript: "nodejs",
    python: "python",
    go: "go",
    rust: "rust",
    ruby: "other",
    java: "other",
    php: "other",
    kotlin: "other",
    swift: "other",
    c: "other",
    cpp: "other",
    elixir: "other",
    dart: "other",
    unknown: "other",
  };
  return typeMap[detectedType] || "other";
}

/**
 * Detect project type from environment detection
 * @param {string} cwd - Current working directory
 * @returns {string} - Detected project type (nodejs, python, go, rust, other)
 */
function detectProjectType(cwd) {
  const env = detectEnvironment(cwd);
  return mapProjectTypeToOption(env.projectType);
}

/**
 * Check if an agent command is available
 * @param {string} agentName - Agent name (claude, codex, droid)
 * @returns {{ installed: boolean, path: string | null, installCmd: string }}
 */
function checkAgentInstalled(agentName) {
  const binName = agentName === "droid" ? "factory" : agentName;

  // Check if command exists
  const result = spawnSync("command", ["-v", binName], {
    shell: true,
    encoding: "utf-8",
  });

  const installed = result.status === 0;
  const agentPath = installed ? (result.stdout || "").trim() : null;

  // Install commands
  const installCommands = {
    claude: "npm install -g @anthropic-ai/claude-code",
    codex: "npm install -g @openai/codex",
    droid: "npm install -g @anthropic-ai/droid",
  };

  return {
    installed,
    path: agentPath,
    installCmd: installCommands[agentName] || `npm install -g ${agentName}`,
  };
}

/**
 * Create initial configuration file
 * @param {string} cwd - Project root directory
 * @param {Object} config - Configuration options
 * @param {string} config.agent - Selected agent (claude, codex, droid)
 * @param {string} config.projectType - Project type
 * @returns {{ created: boolean, path: string }}
 */
function createConfig(cwd, config) {
  const configDir = path.join(cwd, ".agents", "ralph");
  const configPath = path.join(configDir, "config.sh");

  // Ensure directory exists
  fs.mkdirSync(configDir, { recursive: true });

  // Generate config content
  const content = `# Ralph configuration
# Generated by ralph init

# ─────────────────────────────────────────────────────────────────────────────
# Agent Configuration
# ─────────────────────────────────────────────────────────────────────────────
# Default AI agent for build iterations
DEFAULT_AGENT="${config.agent}"

# ─────────────────────────────────────────────────────────────────────────────
# Project Configuration
# ─────────────────────────────────────────────────────────────────────────────
# Project type detected during init
PROJECT_TYPE="${config.projectType}"

# ─────────────────────────────────────────────────────────────────────────────
# Budget Configuration
# ─────────────────────────────────────────────────────────────────────────────
# Set spending limits to control costs. Budget alerts are shown at 80%, 90%, 100%.
#
# Daily budget limit in USD (resets at midnight):
RALPH_BUDGET_DAILY=25.00

# Monthly budget limit in USD (resets on 1st of month):
RALPH_BUDGET_MONTHLY=500.00
`;

  fs.writeFileSync(configPath, content);

  return { created: true, path: configPath };
}

/**
 * Run the interactive setup wizard
 * @param {string} cwd - Current working directory
 * @returns {Promise<Object>} - Configuration result
 */
async function runWizard(cwd) {
  const { intro, outro, select, isCancel, spinner, note } = await import(
    "@clack/prompts"
  );
  const pc = (await import("picocolors")).default;

  intro(pc.cyan("Welcome to Ralph CLI!"));

  // Run environment detection first
  const s = spinner();
  s.start("Detecting environment...");

  const envDetection = detectEnvironment(cwd);
  const detectedType = mapProjectTypeToOption(envDetection.projectType);

  // Build environment summary
  const envSummary = [];
  if (envDetection.manifests.length > 0) {
    envSummary.push(`Manifests: ${envDetection.manifests.join(", ")}`);
  }
  if (envDetection.hasGit) {
    const branch = envDetection.gitBranch ? ` (${envDetection.gitBranch})` : "";
    envSummary.push(`Git: detected${branch}`);
  }
  if (envDetection.hasCICD) {
    envSummary.push(`CI/CD: ${envDetection.ciType}`);
  }

  s.stop(pc.green("Environment detected"));

  // Show detected environment info
  if (envSummary.length > 0) {
    note(envSummary.join("\n"), "Detected Environment");
  }

  // Step 1: Project type selection
  const projectTypeOptions = [
    { value: "nodejs", label: "Node.js / TypeScript" },
    { value: "python", label: "Python" },
    { value: "go", label: "Go" },
    { value: "rust", label: "Rust" },
    { value: "other", label: "Other" },
  ];

  // Move detected type to first position with indicator
  const reorderedOptions = projectTypeOptions.map((opt) => ({
    ...opt,
    label:
      opt.value === detectedType
        ? `${opt.label} ${pc.dim("(detected)")}`
        : opt.label,
  }));

  const projectType = await select({
    message: "What type of project is this?",
    options: reorderedOptions,
    initialValue: detectedType,
  });

  if (isCancel(projectType)) {
    outro("Setup cancelled.");
    return { cancelled: true };
  }

  // Step 2: Agent selection
  const agentType = await select({
    message: "Which AI agent would you like to use?",
    options: [
      {
        value: "claude",
        label: "Claude Code",
        hint: "recommended",
      },
      { value: "codex", label: "Codex" },
      { value: "droid", label: "Droid" },
    ],
    initialValue: "claude",
  });

  if (isCancel(agentType)) {
    outro("Setup cancelled.");
    return { cancelled: true };
  }

  // Step 3: Verify agent installation
  s.start(`Checking ${agentType} installation...`);

  const agentCheck = checkAgentInstalled(agentType);

  if (agentCheck.installed) {
    s.stop(pc.green(`${agentType} detected at ${pc.cyan(agentCheck.path)}`));
  } else {
    s.stop(pc.yellow(`${agentType} not found`));
    note(
      `To install ${agentType}, run:\n\n  ${pc.cyan(agentCheck.installCmd)}`,
      "Install Command"
    );
  }

  // Step 4: Create initial configuration
  s.start("Creating configuration...");

  const configResult = createConfig(cwd, {
    agent: agentType,
    projectType: projectType,
  });

  // Ensure .ralph directory exists
  const ralphDir = path.join(cwd, ".ralph");
  fs.mkdirSync(ralphDir, { recursive: true });

  s.stop(pc.green(`Created ${pc.cyan(configResult.path)}`));

  // Show suggested guardrails if any
  if (envDetection.suggestedGuardrails.length > 0) {
    const guardrailsList = envDetection.suggestedGuardrails
      .slice(0, 3) // Show top 3
      .map((g) => `• ${g.name}`)
      .join("\n");
    note(guardrailsList, "Suggested Guardrails");
  }

  // Summary
  const summaryLines = [
    `Project type: ${projectType}`,
    `Agent: ${agentType}`,
    `Config: ${configResult.path}`,
  ];
  if (envDetection.hasGit) {
    summaryLines.push(`Git: detected`);
  }
  if (envDetection.hasCICD) {
    summaryLines.push(`CI/CD: ${envDetection.ciType}`);
  }
  note(summaryLines.join("\n"), "Configuration");

  outro(
    pc.green("Ready to build!") +
      pc.dim(` Run: ${pc.cyan("ralph prd && ralph plan && ralph build 5")}`)
  );

  return {
    cancelled: false,
    projectType,
    agent: agentType,
    agentInstalled: agentCheck.installed,
    configPath: configResult.path,
    environment: envDetection,
  };
}

module.exports = {
  runWizard,
  detectProjectType,
  checkAgentInstalled,
  createConfig,
};
