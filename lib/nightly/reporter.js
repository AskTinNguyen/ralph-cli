/**
 * Nightly Reporter
 *
 * Generates reports and sends notifications:
 * - Markdown reports for git storage
 * - WhatsApp via Mudslide (primary)
 * - Email notifications
 * - Slack/Discord webhooks
 */

const fs = require("fs");
const path = require("path");
const { execSync, spawnSync } = require("child_process");
const nodemailer = require("nodemailer");

/**
 * Generate markdown report from analysis result
 *
 * @param {Object} analysisResult - Result from analyzer
 * @param {Object} options - Report options
 * @returns {string} Markdown content
 */
function generateMarkdownReport(analysisResult, options = {}) {
  const { recommendation, analysis, metadata, usage } = analysisResult;
  const timestamp = new Date().toISOString();
  const dateStr = new Date().toLocaleDateString("en-US", {
    weekday: "long",
    year: "numeric",
    month: "long",
    day: "numeric",
  });

  const priorityEmoji = {
    critical: "ðŸš¨",
    high: "âš¡",
    medium: "ðŸ’¡",
  };

  const effortEmoji = {
    small: "ðŸŸ¢",
    medium: "ðŸŸ¡",
    large: "ðŸ”´",
  };

  let md = `# AI Recommendation - ${dateStr}

> Generated at ${timestamp}

---

## ${priorityEmoji[recommendation?.priority] || "ðŸ’¡"} Recommendation

### ${recommendation?.title || "Action Item"}

**Priority:** ${recommendation?.priority?.toUpperCase() || "MEDIUM"}
**Effort:** ${effortEmoji[recommendation?.effort] || "ðŸŸ¡"} ${recommendation?.effort?.toUpperCase() || "MEDIUM"}

${recommendation?.summary || ""}

---

### Details

${recommendation?.details || "No details provided."}

---

### Expected Impact

${recommendation?.expectedImpact || "Impact assessment pending."}

---

### Key Data Points

${(recommendation?.dataPoints || []).map(d => `- ${d}`).join("\n") || "- No specific data points highlighted"}

---

### Next Steps

${(recommendation?.nextSteps || []).map((s, i) => `${i + 1}. ${s}`).join("\n") || "1. Review this recommendation\n2. Decide whether to implement"}

---

## Analysis Summary

### Key Insights

${(analysis?.keyInsights || []).map(i => `- ${i}`).join("\n") || "- No insights extracted"}

### Positive Signals

${(analysis?.positiveSignals || []).map(s => `- âœ… ${s}`).join("\n") || "- No positive signals noted"}

### Concerning Trends

${(analysis?.concerningTrends || []).map(t => `- âš ï¸ ${t}`).join("\n") || "- No concerning trends identified"}

---

## Metadata

| Metric | Value |
|--------|-------|
| Data Quality | ${metadata?.dataQuality || "unknown"} |
| Confidence | ${metadata?.confidence || "unknown"} |
| Model | ${usage?.model || "claude-opus-4-5-20251101"} |
| Input Tokens | ${usage?.inputTokens?.toLocaleString() || "N/A"} |
| Output Tokens | ${usage?.outputTokens?.toLocaleString() || "N/A"} |

`;

  if (metadata?.additionalDataNeeded?.length > 0) {
    md += `\n### Additional Data Recommended\n\n`;
    md += metadata.additionalDataNeeded.map(d => `- ${d}`).join("\n");
    md += "\n";
  }

  md += `\n---\n\n*This report was automatically generated by Ralph CLI's nightly recommendations system.*\n`;

  return md;
}

/**
 * Generate HTML email content from analysis result
 */
function generateHTMLEmail(analysisResult, options = {}) {
  const { recommendation, analysis } = analysisResult;
  const dateStr = new Date().toLocaleDateString("en-US", {
    weekday: "long",
    year: "numeric",
    month: "long",
    day: "numeric",
  });

  const priorityColors = {
    critical: "#dc3545",
    high: "#fd7e14",
    medium: "#0d6efd",
  };

  const priorityColor = priorityColors[recommendation?.priority] || priorityColors.medium;

  return `<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Recommendation - ${dateStr}</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f5f5f5;
    }
    .container {
      background: white;
      border-radius: 8px;
      padding: 30px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .header {
      border-bottom: 2px solid ${priorityColor};
      padding-bottom: 15px;
      margin-bottom: 20px;
    }
    .priority-badge {
      display: inline-block;
      background: ${priorityColor};
      color: white;
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: bold;
      text-transform: uppercase;
    }
    h1 {
      margin: 10px 0;
      font-size: 24px;
      color: #1a1a1a;
    }
    .summary {
      font-size: 16px;
      color: #666;
      margin-bottom: 20px;
    }
    .section {
      margin: 25px 0;
    }
    .section-title {
      font-size: 14px;
      font-weight: 600;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 10px;
    }
    .details {
      background: #f9f9f9;
      padding: 15px;
      border-radius: 6px;
      border-left: 4px solid ${priorityColor};
    }
    .data-points {
      list-style: none;
      padding: 0;
    }
    .data-points li {
      padding: 8px 0;
      border-bottom: 1px solid #eee;
    }
    .data-points li:last-child {
      border-bottom: none;
    }
    .next-steps {
      background: #e8f5e9;
      padding: 15px;
      border-radius: 6px;
    }
    .next-steps ol {
      margin: 0;
      padding-left: 20px;
    }
    .next-steps li {
      padding: 5px 0;
    }
    .insights {
      display: grid;
      gap: 10px;
    }
    .insight {
      padding: 10px;
      background: #f5f5f5;
      border-radius: 4px;
      font-size: 14px;
    }
    .footer {
      margin-top: 30px;
      padding-top: 15px;
      border-top: 1px solid #eee;
      font-size: 12px;
      color: #999;
      text-align: center;
    }
    .cta-button {
      display: inline-block;
      background: ${priorityColor};
      color: white;
      padding: 12px 24px;
      border-radius: 6px;
      text-decoration: none;
      font-weight: 600;
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <span class="priority-badge">${recommendation?.priority || "medium"} priority</span>
      <h1>${recommendation?.title || "Daily Recommendation"}</h1>
      <p class="summary">${recommendation?.summary || ""}</p>
    </div>

    <div class="section">
      <div class="section-title">Details</div>
      <div class="details">
        ${(recommendation?.details || "").split("\n").map(p => `<p>${p}</p>`).join("")}
      </div>
    </div>

    <div class="section">
      <div class="section-title">Key Data Points</div>
      <ul class="data-points">
        ${(recommendation?.dataPoints || ["No specific data points"]).map(d => `<li>ðŸ“Š ${d}</li>`).join("")}
      </ul>
    </div>

    <div class="section">
      <div class="section-title">Next Steps</div>
      <div class="next-steps">
        <ol>
          ${(recommendation?.nextSteps || ["Review this recommendation"]).map(s => `<li>${s}</li>`).join("")}
        </ol>
      </div>
    </div>

    ${analysis?.keyInsights?.length > 0 ? `
    <div class="section">
      <div class="section-title">Key Insights</div>
      <div class="insights">
        ${analysis.keyInsights.map(i => `<div class="insight">ðŸ’¡ ${i}</div>`).join("")}
      </div>
    </div>
    ` : ""}

    ${options.repoUrl ? `
    <div style="text-align: center;">
      <a href="${options.repoUrl}" class="cta-button">View Full Report</a>
    </div>
    ` : ""}

    <div class="footer">
      <p>Generated by Ralph CLI â€¢ ${dateStr}</p>
      <p>This is an automated AI recommendation. Review before taking action.</p>
    </div>
  </div>
</body>
</html>`;
}

/**
 * Generate plain text email content
 */
function generatePlainTextEmail(analysisResult) {
  const { recommendation, analysis } = analysisResult;
  const dateStr = new Date().toLocaleDateString("en-US", {
    weekday: "long",
    year: "numeric",
    month: "long",
    day: "numeric",
  });

  return `AI RECOMMENDATION - ${dateStr}
${"=".repeat(50)}

PRIORITY: ${recommendation?.priority?.toUpperCase() || "MEDIUM"}

${recommendation?.title || "Daily Recommendation"}

${recommendation?.summary || ""}

DETAILS
${"-".repeat(30)}
${recommendation?.details || "No details provided."}

KEY DATA POINTS
${"-".repeat(30)}
${(recommendation?.dataPoints || []).map(d => `â€¢ ${d}`).join("\n") || "â€¢ No specific data points"}

NEXT STEPS
${"-".repeat(30)}
${(recommendation?.nextSteps || []).map((s, i) => `${i + 1}. ${s}`).join("\n") || "1. Review this recommendation"}

KEY INSIGHTS
${"-".repeat(30)}
${(analysis?.keyInsights || []).map(i => `â€¢ ${i}`).join("\n") || "â€¢ No insights extracted"}

${"=".repeat(50)}
Generated by Ralph CLI
This is an automated AI recommendation. Review before taking action.
`;
}

/**
 * Send email notification
 *
 * @param {Object} analysisResult - Analysis result from analyzer
 * @param {Object} config - Email configuration
 * @returns {Promise<Object>} Send result
 */
async function sendEmail(analysisResult, config) {
  const {
    to,
    from = process.env.RALPH_EMAIL_FROM || "ralph@localhost",
    subject = null,
    smtp = null,
    repoUrl = null,
  } = config;

  if (!to) {
    return { success: false, error: "No recipient email specified" };
  }

  // Configure transport
  let transport;
  if (smtp) {
    transport = nodemailer.createTransport(smtp);
  } else if (process.env.SMTP_HOST) {
    transport = nodemailer.createTransport({
      host: process.env.SMTP_HOST,
      port: parseInt(process.env.SMTP_PORT || "587", 10),
      secure: process.env.SMTP_SECURE === "true",
      auth: process.env.SMTP_USER ? {
        user: process.env.SMTP_USER,
        pass: process.env.SMTP_PASS,
      } : undefined,
    });
  } else if (process.env.SENDGRID_API_KEY) {
    transport = nodemailer.createTransport({
      host: "smtp.sendgrid.net",
      port: 587,
      auth: {
        user: "apikey",
        pass: process.env.SENDGRID_API_KEY,
      },
    });
  } else if (process.env.MAILGUN_SMTP_LOGIN) {
    transport = nodemailer.createTransport({
      host: "smtp.mailgun.org",
      port: 587,
      auth: {
        user: process.env.MAILGUN_SMTP_LOGIN,
        pass: process.env.MAILGUN_SMTP_PASSWORD,
      },
    });
  } else {
    return {
      success: false,
      error: "No email transport configured. Set SMTP_HOST or SENDGRID_API_KEY.",
    };
  }

  // Generate subject
  const emailSubject = subject || generateEmailSubject(analysisResult.recommendation);

  // Generate content
  const htmlContent = generateHTMLEmail(analysisResult, { repoUrl });
  const textContent = generatePlainTextEmail(analysisResult);

  try {
    const info = await transport.sendMail({
      from,
      to,
      subject: emailSubject,
      text: textContent,
      html: htmlContent,
    });

    return {
      success: true,
      messageId: info.messageId,
      accepted: info.accepted,
    };
  } catch (err) {
    return {
      success: false,
      error: `Failed to send email: ${err.message}`,
    };
  }
}

/**
 * Generate email subject from recommendation
 */
function generateEmailSubject(recommendation) {
  if (!recommendation) return "Daily AI Recommendation";

  const priority = recommendation.priority?.toUpperCase() || "";
  const title = recommendation.title || "Action Item";

  if (priority === "CRITICAL") {
    return `ðŸš¨ [CRITICAL] ${title}`;
  } else if (priority === "HIGH") {
    return `âš¡ [HIGH] ${title}`;
  }
  return `ðŸ’¡ ${title}`;
}

/**
 * Save markdown report to file
 *
 * @param {string} content - Markdown content
 * @param {Object} options - Save options
 * @returns {Object} Save result
 */
function saveMarkdownReport(content, options = {}) {
  const {
    outputDir = ".ralph/recommendations",
    filename = null,
    cwd = process.cwd(),
  } = options;

  const fullOutputDir = path.isAbsolute(outputDir)
    ? outputDir
    : path.join(cwd, outputDir);

  // Ensure directory exists
  fs.mkdirSync(fullOutputDir, { recursive: true });

  // Generate filename
  const date = new Date();
  const dateStr = date.toISOString().split("T")[0];
  const finalFilename = filename || `recommendation-${dateStr}.md`;
  const filePath = path.join(fullOutputDir, finalFilename);

  // Check if file exists and add counter if needed
  let finalPath = filePath;
  let counter = 1;
  while (fs.existsSync(finalPath)) {
    const ext = path.extname(filePath);
    const base = path.basename(filePath, ext);
    finalPath = path.join(fullOutputDir, `${base}-${counter}${ext}`);
    counter++;
  }

  try {
    fs.writeFileSync(finalPath, content);
    return {
      success: true,
      path: finalPath,
      relativePath: path.relative(cwd, finalPath),
    };
  } catch (err) {
    return {
      success: false,
      error: `Failed to save report: ${err.message}`,
    };
  }
}

/**
 * Send Slack webhook notification
 */
async function sendSlackWebhook(analysisResult, webhookUrl) {
  const { recommendation } = analysisResult;

  const priorityEmoji = {
    critical: "ðŸš¨",
    high: "âš¡",
    medium: "ðŸ’¡",
  };

  const payload = {
    blocks: [
      {
        type: "header",
        text: {
          type: "plain_text",
          text: `${priorityEmoji[recommendation?.priority] || "ðŸ’¡"} ${recommendation?.title || "Daily Recommendation"}`,
        },
      },
      {
        type: "section",
        text: {
          type: "mrkdwn",
          text: `*Priority:* ${recommendation?.priority?.toUpperCase() || "MEDIUM"}\n*Effort:* ${recommendation?.effort || "medium"}\n\n${recommendation?.summary || ""}`,
        },
      },
      {
        type: "divider",
      },
      {
        type: "section",
        text: {
          type: "mrkdwn",
          text: `*Details*\n${recommendation?.details || "No details provided."}`,
        },
      },
    ],
  };

  if (recommendation?.nextSteps?.length > 0) {
    payload.blocks.push({
      type: "section",
      text: {
        type: "mrkdwn",
        text: `*Next Steps*\n${recommendation.nextSteps.map((s, i) => `${i + 1}. ${s}`).join("\n")}`,
      },
    });
  }

  try {
    const response = await fetch(webhookUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });

    if (!response.ok) {
      throw new Error(`Slack webhook returned ${response.status}`);
    }

    return { success: true };
  } catch (err) {
    return { success: false, error: err.message };
  }
}

/**
 * Send Discord webhook notification
 */
async function sendDiscordWebhook(analysisResult, webhookUrl) {
  const { recommendation } = analysisResult;

  const priorityColors = {
    critical: 0xdc3545,
    high: 0xfd7e14,
    medium: 0x0d6efd,
  };

  const payload = {
    embeds: [
      {
        title: recommendation?.title || "Daily Recommendation",
        description: recommendation?.summary || "",
        color: priorityColors[recommendation?.priority] || priorityColors.medium,
        fields: [
          {
            name: "Priority",
            value: recommendation?.priority?.toUpperCase() || "MEDIUM",
            inline: true,
          },
          {
            name: "Effort",
            value: recommendation?.effort?.toUpperCase() || "MEDIUM",
            inline: true,
          },
          {
            name: "Details",
            value: (recommendation?.details || "").slice(0, 1024) || "No details",
          },
          {
            name: "Next Steps",
            value: (recommendation?.nextSteps || []).map((s, i) => `${i + 1}. ${s}`).join("\n").slice(0, 1024) || "Review recommendation",
          },
        ],
        footer: {
          text: "Ralph CLI Nightly Recommendations",
        },
        timestamp: new Date().toISOString(),
      },
    ],
  };

  try {
    const response = await fetch(webhookUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });

    if (!response.ok) {
      throw new Error(`Discord webhook returned ${response.status}`);
    }

    return { success: true };
  } catch (err) {
    return { success: false, error: err.message };
  }
}

/**
 * Generate GitHub URL for a report file
 *
 * @param {string} relativePath - Relative path to the file
 * @param {Object} options - Options
 * @returns {string} GitHub URL
 */
function generateGitHubUrl(relativePath, options = {}) {
  const {
    owner = process.env.GITHUB_REPOSITORY_OWNER,
    repo = process.env.GITHUB_REPOSITORY?.split("/")[1],
    branch = "main",
  } = options;

  // Try to detect from git remote
  let repoOwner = owner;
  let repoName = repo;

  if (!repoOwner || !repoName) {
    try {
      const remoteUrl = execSync("git remote get-url origin", { encoding: "utf-8" }).trim();
      // Parse GitHub URL (handles both HTTPS and SSH)
      const match = remoteUrl.match(/github\.com[:/]([^/]+)\/([^/.]+)/);
      if (match) {
        repoOwner = repoOwner || match[1];
        repoName = repoName || match[2];
      }
    } catch {}
  }

  if (!repoOwner || !repoName) {
    return null;
  }

  // Clean the path
  const cleanPath = relativePath.replace(/^\//, "").replace(/\\/g, "/");

  return `https://github.com/${repoOwner}/${repoName}/blob/${branch}/${cleanPath}`;
}

/**
 * Generate WhatsApp message for recommendation
 */
function generateWhatsAppMessage(recommendation, reportUrl) {
  const priorityEmoji = {
    critical: "ðŸš¨",
    high: "âš¡",
    medium: "ðŸ’¡",
  };

  const emoji = priorityEmoji[recommendation?.priority] || "ðŸ’¡";
  const priority = recommendation?.priority?.toUpperCase() || "MEDIUM";
  const title = recommendation?.title || "Daily Recommendation";
  const summary = recommendation?.summary || "";

  let message = `${emoji} *AI Recommendation* [${priority}]\n\n`;
  message += `*${title}*\n\n`;
  message += `${summary}\n\n`;

  if (recommendation?.nextSteps?.length > 0) {
    message += `*Next Steps:*\n`;
    recommendation.nextSteps.forEach((step, i) => {
      message += `${i + 1}. ${step}\n`;
    });
    message += "\n";
  }

  if (reportUrl) {
    message += `ðŸ“„ *Full Report:*\n${reportUrl}\n\n`;
    message += `ðŸ’¬ Open in Claude Code to discuss and implement.`;
  }

  return message;
}

/**
 * Send WhatsApp message via Mudslide
 *
 * @param {Object} analysisResult - Analysis result from analyzer
 * @param {Object} config - WhatsApp configuration
 * @returns {Promise<Object>} Send result
 */
async function sendWhatsApp(analysisResult, config) {
  const {
    to,
    reportUrl = null,
    groupId = null,
  } = config;

  const recipient = groupId || to;

  if (!recipient) {
    return { success: false, error: "No WhatsApp recipient specified (set WHATSAPP_TO or WHATSAPP_GROUP_ID)" };
  }

  // Check if mudslide is available
  const mudslideCheck = spawnSync("which", ["mudslide"], { encoding: "utf-8" });
  if (mudslideCheck.status !== 0) {
    // Try npx
    const npxCheck = spawnSync("npx", ["mudslide", "--version"], { encoding: "utf-8", timeout: 10000 });
    if (npxCheck.status !== 0) {
      return {
        success: false,
        error: "Mudslide not found. Install with: npm install -g @nickytonline/mudslide",
      };
    }
  }

  const message = generateWhatsAppMessage(analysisResult.recommendation, reportUrl);

  try {
    // Use mudslide to send message
    const cmd = groupId ? "send-group" : "send";
    const args = [cmd, recipient, message];

    // Try global mudslide first, fall back to npx
    let result = spawnSync("mudslide", args, { encoding: "utf-8", timeout: 30000 });

    if (result.status !== 0) {
      result = spawnSync("npx", ["mudslide", ...args], { encoding: "utf-8", timeout: 60000 });
    }

    if (result.status !== 0) {
      return {
        success: false,
        error: result.stderr || "Failed to send WhatsApp message",
      };
    }

    return {
      success: true,
      message: "WhatsApp message sent",
      recipient,
    };
  } catch (err) {
    return {
      success: false,
      error: `WhatsApp send failed: ${err.message}`,
    };
  }
}

/**
 * Check if Mudslide is authenticated
 */
function checkMudslideAuth() {
  try {
    const result = spawnSync("mudslide", ["login", "--check"], { encoding: "utf-8", timeout: 10000 });
    return result.status === 0;
  } catch {
    return false;
  }
}

module.exports = {
  generateMarkdownReport,
  generateHTMLEmail,
  generatePlainTextEmail,
  sendEmail,
  saveMarkdownReport,
  sendSlackWebhook,
  sendDiscordWebhook,
  sendWhatsApp,
  generateEmailSubject,
  generateGitHubUrl,
  generateWhatsAppMessage,
  checkMudslideAuth,
};
