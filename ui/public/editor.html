<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/png" href="/favicon.png">
  <title>Ralph CLI - Editor</title>
  <link rel="stylesheet" href="/css/rams-ui.css">
  <script src="/js/htmx.min.js"></script>
  <script src="/js/marked.min.js"></script>
  <!-- Prism.js for syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markdown.min.js"></script>
  <!-- Mermaid.js for diagram rendering -->
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  <style>
    /* Editor-specific styles following Rams design system principles */

    /* Constrain main area to viewport height for proper flex distribution */
    .rams-main {
      height: 100vh;
      max-height: 100vh;
      overflow: hidden;
    }

    /* Make content area fill available vertical space */
    .rams-content {
      display: flex;
      flex-direction: column;
      padding-bottom: var(--rams-space-6); /* Suitable bottom padding */
      overflow: hidden; /* Prevent overflow, let children handle scroll */
    }

    /* Make section fill remaining space */
    .rams-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      margin-bottom: 0; /* Remove default margin since we're using padding on parent */
      min-height: 0; /* Allow flex child to shrink below content size */
    }

    .editor-container {
      display: flex;
      flex-direction: column;
      flex: 1; /* Fill available space in section */
      min-height: 0; /* Allow flex child to shrink */
    }
    .editor-pane, .preview-pane {
      display: flex;
      flex-direction: column;
      border: var(--rams-border-width) solid var(--rams-border-color);
      border-radius: var(--rams-radius-md);
      overflow: hidden;
      background: var(--rams-white);
      flex: 1; /* Fill available space in container */
      min-height: 0; /* Allow flex child to shrink */
    }
    .pane-hidden {
      display: none;
    }
    .pane-header {
      padding: var(--rams-space-3) var(--rams-space-4);
      background: var(--rams-gray-50);
      border-bottom: var(--rams-border-width) solid var(--rams-border-color);
      font-weight: 500;
      font-size: var(--rams-text-sm);
      color: var(--rams-gray-700);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .view-toggle {
      display: flex;
      gap: var(--rams-space-2);
      background: var(--rams-white);
      border: var(--rams-border-width) solid var(--rams-border-color);
      border-radius: var(--rams-radius-sm);
      padding: 2px;
    }
    .view-toggle-btn {
      padding: var(--rams-space-2) var(--rams-space-3);
      font-size: var(--rams-text-xs);
      font-weight: 500;
      background: transparent;
      border: none;
      border-radius: var(--rams-radius-sm);
      color: var(--rams-gray-600);
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .view-toggle-btn:hover {
      color: var(--rams-gray-900);
      background: var(--rams-gray-100);
    }
    .view-toggle-btn.active {
      background: var(--rams-accent);
      color: white;
    }
    .pane-header-right {
      display: flex;
      align-items: center;
      gap: var(--rams-space-3);
    }
    .pane-actions {
      display: flex;
      gap: var(--rams-space-2);
    }
    .rams-btn-sm {
      padding: var(--rams-space-2) var(--rams-space-3);
      font-size: var(--rams-text-xs);
    }
    .editor-textarea {
      flex: 1;
      min-height: 0; /* Allow flex child to shrink */
      border: none;
      padding: var(--rams-space-4);
      font-family: var(--rams-font-mono);
      font-size: var(--rams-text-sm);
      line-height: 1.6;
      resize: none;
      outline: none;
      background: var(--rams-white);
      color: var(--rams-gray-900);
    }
    .editor-textarea:focus {
      outline: none;
    }
    .editor-textarea:disabled {
      background: var(--rams-gray-50);
      color: var(--rams-gray-500);
      cursor: not-allowed;
    }
    .syntax-view {
      flex: 1;
      overflow-y: auto;
      background: #2d2d2d;
      padding: 0;
    }
    .syntax-view pre {
      margin: 0;
      padding: var(--rams-space-4);
      background: transparent;
      border: none;
      border-radius: 0;
    }
    .syntax-view code {
      font-family: var(--rams-font-mono);
      font-size: var(--rams-text-sm);
      line-height: 1.6;
    }
    .preview-content {
      flex: 1;
      min-height: 0; /* Allow flex child to shrink */
      padding: var(--rams-space-4);
      overflow-y: auto;
      line-height: var(--rams-leading-relaxed);
      color: var(--rams-gray-700);
    }
    .preview-content h1 {
      font-size: var(--rams-text-2xl);
      font-weight: 600;
      letter-spacing: var(--rams-tracking-tight);
      color: var(--rams-gray-900);
      margin-top: var(--rams-space-6);
      margin-bottom: var(--rams-space-3);
    }
    .preview-content h2 {
      font-size: var(--rams-text-xl);
      font-weight: 600;
      letter-spacing: var(--rams-tracking-tight);
      color: var(--rams-gray-900);
      margin-top: var(--rams-space-6);
      margin-bottom: var(--rams-space-3);
    }
    .preview-content h3 {
      font-size: var(--rams-text-lg);
      font-weight: 600;
      letter-spacing: var(--rams-tracking-tight);
      color: var(--rams-gray-900);
      margin-top: var(--rams-space-6);
      margin-bottom: var(--rams-space-3);
    }
    .preview-content h1:first-child,
    .preview-content h2:first-child,
    .preview-content h3:first-child {
      margin-top: 0;
    }
    .preview-content p {
      margin-bottom: var(--rams-space-4);
    }
    .preview-content ul, .preview-content ol {
      margin-bottom: var(--rams-space-4);
      padding-left: var(--rams-space-6);
    }
    .preview-content li {
      margin-bottom: var(--rams-space-2);
    }
    .preview-content code {
      background: var(--rams-gray-100);
      padding: 2px 6px;
      border-radius: var(--rams-radius-sm);
      font-family: var(--rams-font-mono);
      font-size: 0.9em;
      color: var(--rams-gray-900);
    }
    .preview-content pre {
      background: var(--rams-gray-900);
      padding: var(--rams-space-4);
      border-radius: var(--rams-radius-md);
      overflow-x: auto;
      margin-bottom: var(--rams-space-4);
      border: var(--rams-border-width) solid var(--rams-gray-800);
    }
    .preview-content pre code {
      background: none;
      padding: 0;
      color: var(--rams-gray-200);
    }
    .preview-content blockquote {
      border-left: 3px solid var(--rams-accent);
      padding-left: var(--rams-space-4);
      margin: var(--rams-space-4) 0;
      color: var(--rams-gray-600);
      font-style: italic;
    }
    .preview-content table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: var(--rams-space-4);
    }
    .preview-content table th {
      text-align: left;
      padding: var(--rams-space-3) var(--rams-space-4);
      font-size: var(--rams-text-xs);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--rams-gray-500);
      background: var(--rams-gray-50);
      border-bottom: var(--rams-border-width) solid var(--rams-border-color);
    }
    .preview-content table td {
      padding: var(--rams-space-3) var(--rams-space-4);
      border-bottom: var(--rams-border-width) solid var(--rams-gray-200);
    }
    .empty-state {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: var(--rams-gray-500);
      font-size: var(--rams-text-sm);
    }
    .mermaid-wrapper {
      margin: var(--rams-space-4) 0;
      padding: var(--rams-space-4);
      background: var(--rams-white);
      border: var(--rams-border-width) solid var(--rams-border-color);
      border-radius: var(--rams-radius-md);
      overflow-x: auto;
      display: flex;
      justify-content: center;
    }
    .mermaid-wrapper svg {
      max-width: 100%;
      height: auto;
    }

    /* Authorship tracking styles */
    .authorship-toggle {
      display: inline-flex;
      align-items: center;
      gap: var(--rams-space-2);
      padding: var(--rams-space-2) var(--rams-space-3);
      font-size: var(--rams-text-xs);
      font-weight: 500;
      background: var(--rams-white);
      border: var(--rams-border-width) solid var(--rams-border-color);
      border-radius: var(--rams-radius-sm);
      color: var(--rams-gray-600);
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .authorship-toggle:hover {
      color: var(--rams-gray-900);
      border-color: var(--rams-gray-300);
    }
    .authorship-toggle.active {
      background: var(--rams-accent);
      color: white;
      border-color: var(--rams-accent);
    }
    .authorship-toggle svg {
      width: 14px;
      height: 14px;
    }
    .authorship-stats-badge {
      font-size: var(--rams-text-xs);
      color: var(--rams-gray-500);
      font-family: var(--rams-font-mono);
    }
    .authorship-legend {
      display: none;
      padding: var(--rams-space-3) var(--rams-space-4);
      background: var(--rams-gray-50);
      border-bottom: var(--rams-border-width) solid var(--rams-border-color);
      gap: var(--rams-space-4);
      flex-wrap: wrap;
    }
    .authorship-legend.visible {
      display: flex;
    }
    .legend-item {
      display: inline-flex;
      align-items: center;
      gap: var(--rams-space-2);
      font-size: var(--rams-text-xs);
      font-weight: 500;
    }
    .legend-dot {
      width: 12px;
      height: 12px;
      border-radius: 2px;
    }
    .legend-item.human .legend-dot {
      background: rgba(220, 38, 38, 0.15);
      border-left: 3px solid #DC2626;
    }
    .legend-item.ai-claude .legend-dot {
      background: rgba(59, 130, 246, 0.15);
      border-left: 3px solid #3B82F6;
    }
    .legend-item.ai-codex .legend-dot {
      background: rgba(168, 85, 247, 0.15);
      border-left: 3px solid #A855F7;
    }
    .legend-item.ai-droid .legend-dot {
      background: rgba(245, 158, 11, 0.15);
      border-left: 3px solid #F59E0B;
    }
    .legend-item.unknown .legend-dot {
      background: rgba(209, 213, 219, 0.2);
      border-left: 3px solid #D1D5DB;
    }
    /* Edit pane authorship highlights - contenteditable overlay */
    .editor-with-authorship {
      flex: 1;
      min-height: 0;
      position: relative;
      display: flex;
    }
    .editor-with-authorship .editor-textarea {
      flex: 1;
      z-index: 1;
    }
    .editor-line-highlights {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      padding: var(--rams-space-4);
      overflow: hidden;
      font-family: var(--rams-font-mono);
      font-size: var(--rams-text-sm);
      line-height: 1.6;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    .editor-line-highlights.hidden {
      display: none;
    }
    .line-highlight {
      display: block;
      margin-left: -11px;
      padding-left: 8px;
    }
    .line-highlight.authorship-human {
      background: rgba(220, 38, 38, 0.12);
      border-left: 3px solid #DC2626;
    }
    .line-highlight.authorship-ai-claude {
      background: rgba(59, 130, 246, 0.08);
      border-left: 3px solid #3B82F6;
    }
    .line-highlight.authorship-ai-codex {
      background: rgba(168, 85, 247, 0.08);
      border-left: 3px solid #A855F7;
    }
    .line-highlight.authorship-ai-droid {
      background: rgba(245, 158, 11, 0.08);
      border-left: 3px solid #F59E0B;
    }
    .line-highlight.authorship-unknown {
      background: rgba(115, 115, 115, 0.08);
      border-left: 3px solid #737373;
    }
    /* Preview pane authorship highlights - block-level elements */
    .preview-content .authorship-human {
      background: rgba(220, 38, 38, 0.12);
      border-left: 3px solid #DC2626;
      padding-left: var(--rams-space-3);
      margin-left: -3px;
    }
    .preview-content .authorship-ai-claude {
      background: rgba(59, 130, 246, 0.08);
      border-left: 3px solid #3B82F6;
      padding-left: var(--rams-space-3);
      margin-left: -3px;
    }
    .preview-content .authorship-ai-codex {
      background: rgba(168, 85, 247, 0.08);
      border-left: 3px solid #A855F7;
      padding-left: var(--rams-space-3);
      margin-left: -3px;
    }
    .preview-content .authorship-ai-droid {
      background: rgba(245, 158, 11, 0.08);
      border-left: 3px solid #F59E0B;
      padding-left: var(--rams-space-3);
      margin-left: -3px;
    }
    .preview-content .authorship-unknown {
      background: rgba(115, 115, 115, 0.08);
      border-left: 3px solid #737373;
      padding-left: var(--rams-space-3);
      margin-left: -3px;
    }
  </style>
</head>
<body class="rams-page">

  <script src="/js/sidebar.js"></script>

  <!-- Persistent Sidebar -->
  <aside class="rams-sidebar" id="rams-sidebar">
    <div class="rams-sidebar-header">
      <div class="rams-logo">
        <div class="rams-logo-mark" onclick="toggleSidebar()" title="Toggle sidebar"></div>
        <span class="rams-logo-text">RALPH</span>
      </div>
    </div>

    <nav class="rams-nav">
      <div class="rams-nav-section">
        <div class="rams-nav-label">Main</div>
        <ul class="rams-nav-items">
          <li><a href="/" class="rams-nav-link">Home</a></li>
          <li><a href="/dashboard.html" class="rams-nav-link">Dashboard</a></li>
          <li><a href="/streams.html" class="rams-nav-link">Streams</a></li>
          <li><a href="/kanban.html" class="rams-nav-link">Mission Control</a></li>
          <li><a href="/docs/" class="rams-nav-link">Documentation</a></li>
        </ul>
      </div>

      <div class="rams-nav-section">
        <div class="rams-nav-label">Monitoring</div>
        <ul class="rams-nav-items">
          <li><a href="/logs.html" class="rams-nav-link">Logs</a></li>
          <li><a href="/tokens.html" class="rams-nav-link">Tokens</a></li>
          <li><a href="/trends.html" class="rams-nav-link">Trends</a></li>
        </ul>
      </div>

      <div class="rams-nav-section">
        <div class="rams-nav-label">Tools</div>
        <ul class="rams-nav-items">
          <li><a href="/editor.html" class="rams-nav-link active">Editor</a></li>
          <li><a href="/chat.html" class="rams-nav-link">Chat</a></li>
        </ul>
      </div>

      <div class="rams-nav-section">
        <div class="rams-nav-label">Advanced</div>
        <ul class="rams-nav-items">
          <li><a href="/docs/agent-guide.html" class="rams-nav-link">Agent Guide</a></li>
        </ul>
      </div>
    </nav>

    <div class="rams-sidebar-footer">
      <div class="rams-version">v1.0.0</div>
    </div>
  </aside>

  <!-- Main Content -->
  <main class="rams-main">

    <!-- Top Bar -->
    <div class="rams-topbar">
      <div class="rams-breadcrumb">
        <span class="rams-breadcrumb-current">Editor</span>
      </div>
      <div class="rams-topbar-actions">
        <select id="stream-selector" class="rams-select" style="width: auto; min-width: 150px;">
          <option value="">Select a stream...</option>
        </select>
        <select id="file-selector" class="rams-select" style="width: auto; min-width: 150px;" disabled>
          <option value="">Select a file...</option>
        </select>
        <button id="open-in-editor-btn" class="rams-btn rams-btn-secondary" disabled>
          Open in Editor
        </button>
      </div>
    </div>

    <!-- Content Area -->
    <article class="rams-content">

      <section class="rams-section">
        <div class="editor-container">
          <!-- Edit Pane -->
          <div id="edit-pane" class="editor-pane">
            <div class="pane-header">
              <span class="pane-title">Edit</span>
              <div class="pane-header-right">
                <span id="authorship-stats" class="authorship-stats-badge"></span>
                <button id="authorship-toggle" class="authorship-toggle" data-testid="authorship-toggle" onclick="toggleAuthorship()" title="Toggle authorship highlighting">
                  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                    <circle cx="12" cy="12" r="3"></circle>
                  </svg>
                  <span>Authorship</span>
                </button>
                <div class="view-toggle">
                  <button class="view-toggle-btn active" onclick="switchView('edit')">Edit</button>
                  <button class="view-toggle-btn" onclick="switchView('preview')">Preview</button>
                </div>
                <div class="pane-actions">
                  <button id="copy-btn" class="rams-btn rams-btn-secondary rams-btn-sm" onclick="copyContent()">Copy</button>
                  <button id="save-btn" class="rams-btn rams-btn-primary rams-btn-sm" onclick="saveFile()" disabled>Save</button>
                </div>
              </div>
            </div>
            <div id="authorship-legend" class="authorship-legend">
              <span class="legend-item human"><span class="legend-dot"></span>Human</span>
              <span class="legend-item ai-claude"><span class="legend-dot"></span>Claude</span>
              <span class="legend-item ai-codex"><span class="legend-dot"></span>Codex</span>
              <span class="legend-item ai-droid"><span class="legend-dot"></span>Droid</span>
              <span class="legend-item unknown"><span class="legend-dot"></span>Unknown</span>
            </div>
            <div class="editor-with-authorship">
              <div id="editor-line-highlights" class="editor-line-highlights hidden"></div>
              <textarea id="editor-textarea" class="editor-textarea" placeholder="Select a stream and file to edit..."></textarea>
            </div>
          </div>

          <!-- Preview Pane -->
          <div id="preview-pane" class="preview-pane pane-hidden">
            <div class="pane-header">
              <span class="pane-title">Preview</span>
              <div class="pane-header-right">
                <span id="authorship-stats-preview" class="authorship-stats-badge"></span>
                <button id="authorship-toggle-preview" class="authorship-toggle" data-testid="authorship-toggle-preview" onclick="toggleAuthorship()" title="Toggle authorship highlighting">
                  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                    <circle cx="12" cy="12" r="3"></circle>
                  </svg>
                  <span>Authorship</span>
                </button>
                <div class="view-toggle">
                  <button class="view-toggle-btn" onclick="switchView('edit')">Edit</button>
                  <button class="view-toggle-btn active" onclick="switchView('preview')">Preview</button>
                </div>
                <div class="pane-actions">
                  <button id="copy-btn-preview" class="rams-btn rams-btn-secondary rams-btn-sm" onclick="copyContent()">Copy</button>
                </div>
              </div>
            </div>
            <div id="authorship-legend-preview" class="authorship-legend">
              <span class="legend-item human"><span class="legend-dot"></span>Human</span>
              <span class="legend-item ai-claude"><span class="legend-dot"></span>Claude</span>
              <span class="legend-item ai-codex"><span class="legend-dot"></span>Codex</span>
              <span class="legend-item ai-droid"><span class="legend-dot"></span>Droid</span>
              <span class="legend-item unknown"><span class="legend-dot"></span>Unknown</span>
            </div>
            <div id="preview-content" class="preview-content">
              <div class="empty-state">
                <p>Markdown preview will appear here</p>
              </div>
            </div>
          </div>
        </div>
      </section>

    </article>

  </main>

  <script>
    let currentStreamId = "";
    let currentFile = "";
    let currentFilePath = "";
    let currentView = "edit"; // edit or preview
    let originalContent = "";
    let isReadOnly = false; // Whether the editor is in read-only mode

    // Authorship tracking state
    let authorshipEnabled = false;
    let currentAuthorship = null;

    if (typeof marked !== "undefined") {
      marked.setOptions({
        breaks: true,
        gfm: true,
      });
    }

    // Initialize Mermaid
    if (typeof mermaid !== "undefined") {
      mermaid.initialize({
        startOnLoad: false,
        theme: 'default',
        securityLevel: 'loose'
      });
    }

    document.addEventListener("DOMContentLoaded", () => {
      loadStreams();
      setInterval(() => loadStreams(true), 10000);

      // Track changes in textarea
      document.getElementById("editor-textarea").addEventListener("input", updateSaveButton);

      // Check for URL parameters to auto-load a PRD
      const urlParams = new URLSearchParams(window.location.search);
      const prdParam = urlParams.get('prd');
      const fileParam = urlParams.get('file') || 'prd';
      const readonlyParam = urlParams.get('readonly');

      // Set read-only mode based on URL parameter
      if (readonlyParam === 'true') {
        isReadOnly = true;
        applyReadOnlyMode();
      }

      if (prdParam) {
        // Wait for streams to load, then auto-select
        setTimeout(async () => {
          await loadPrdFromUrl(prdParam, fileParam);
        }, 500);
      }
    });

    // Apply read-only mode to the editor
    function applyReadOnlyMode() {
      const textarea = document.getElementById("editor-textarea");
      const saveBtn = document.getElementById("save-btn");
      const paneTitle = document.querySelector("#edit-pane .pane-title");

      // Disable textarea
      if (textarea) {
        textarea.disabled = true;
        textarea.style.cursor = "not-allowed";
      }

      // Hide save button
      if (saveBtn) {
        saveBtn.style.display = "none";
      }

      // Update pane title to indicate view-only mode
      if (paneTitle) {
        paneTitle.textContent = "View (Read Only)";
      }

      // Add a read-only indicator banner
      const editPane = document.getElementById("edit-pane");
      if (editPane) {
        const existingBanner = editPane.querySelector(".readonly-banner");
        if (!existingBanner) {
          const banner = document.createElement("div");
          banner.className = "readonly-banner";
          banner.style.cssText = "background: var(--rams-gray-100); color: var(--rams-gray-600); padding: var(--rams-space-2) var(--rams-space-4); font-size: var(--rams-text-sm); border-bottom: 1px solid var(--rams-border-color); display: flex; justify-content: space-between; align-items: center;";
          banner.innerHTML = '<span>This file is in read-only mode because the PRD is in progress or completed.</span><a href="/streams.html" style="color: var(--rams-accent); text-decoration: none;">Back to Streams</a>';
          const paneHeader = editPane.querySelector(".pane-header");
          if (paneHeader) {
            paneHeader.after(banner);
          }
        }
      }
    }

    async function loadPrdFromUrl(prdId, fileType) {
      try {
        // Set the stream selector
        const streamSelector = document.getElementById("stream-selector");
        streamSelector.value = prdId;
        currentStreamId = prdId;

        // Trigger stream change to load files
        const event = new Event('change');
        streamSelector.dispatchEvent(event);

        // Wait for files to load, then select the file
        setTimeout(() => {
          const fileSelector = document.getElementById("file-selector");
          const fileValue = fileType.endsWith('.md') ? fileType : `${fileType}.md`;
          fileSelector.value = fileValue;
          currentFile = fileValue;

          // Trigger file change to load content
          const fileEvent = new Event('change');
          fileSelector.dispatchEvent(fileEvent);
        }, 300);

        // Update breadcrumb to show we're editing/viewing a specific PRD
        const breadcrumb = document.querySelector('.rams-breadcrumb');
        if (breadcrumb) {
          const modeLabel = isReadOnly ? '(View Only)' : '';
          const fileLabel = fileType === 'plan' || fileType === 'plan.md' ? 'Plan' : 'PRD';
          breadcrumb.innerHTML = `
            <a href="/streams.html" style="color: var(--rams-gray-600); text-decoration: none;">Streams</a>
            <span style="color: var(--rams-gray-400); margin: 0 var(--rams-space-2);">/</span>
            <span style="color: var(--rams-gray-600);">PRD-${prdId}</span>
            <span style="color: var(--rams-gray-400); margin: 0 var(--rams-space-2);">/</span>
            <span class="rams-breadcrumb-current">${fileLabel} ${modeLabel}</span>
          `;
        }
      } catch (error) {
        console.error("Failed to load PRD from URL:", error);
      }
    }

    // Switch between edit and preview
    function switchView(view) {
      currentView = view;
      const editPane = document.getElementById("edit-pane");
      const previewPane = document.getElementById("preview-pane");

      if (view === "edit") {
        editPane.classList.remove("pane-hidden");
        previewPane.classList.add("pane-hidden");
      } else {
        editPane.classList.add("pane-hidden");
        previewPane.classList.remove("pane-hidden");
        // Update preview with current editor content
        const textarea = document.getElementById("editor-textarea");
        updatePreview(textarea.value);
      }

      // Update toggle button states in both panes
      document.querySelectorAll(".view-toggle-btn").forEach(btn => {
        const btnView = btn.textContent.toLowerCase();
        btn.classList.toggle("active", btnView === view);
      });
    }

    // Copy content to clipboard
    async function copyContent() {
      const textarea = document.getElementById("editor-textarea");
      const copyBtn = document.getElementById("copy-btn");

      try {
        await navigator.clipboard.writeText(textarea.value);
        copyBtn.textContent = "Copied!";
        setTimeout(() => copyBtn.textContent = "Copy", 1500);
      } catch (err) {
        console.error("Copy failed:", err);
        copyBtn.textContent = "Failed";
        setTimeout(() => copyBtn.textContent = "Copy", 1500);
      }
    }

    // Save file to server
    async function saveFile() {
      const textarea = document.getElementById("editor-textarea");
      const saveBtn = document.getElementById("save-btn");

      if (!currentFilePath) return;

      saveBtn.disabled = true;
      saveBtn.textContent = "Saving...";

      try {
        const response = await fetch(`/api/files/${encodeURIComponent(currentFilePath)}`, {
          method: "PUT",
          headers: { "Content-Type": "text/plain" },
          body: textarea.value
        });

        if (!response.ok) throw new Error("Failed to save");

        // Update authorship metadata (mark human as author of changes)
        await saveAuthorship(textarea.value);

        originalContent = textarea.value;
        saveBtn.textContent = "Saved!";

        setTimeout(() => {
          saveBtn.textContent = "Save";
          updateSaveButton();
        }, 1500);
      } catch (error) {
        console.error("Save failed:", error);
        saveBtn.textContent = "Failed";
        setTimeout(() => {
          saveBtn.textContent = "Save";
          saveBtn.disabled = false;
        }, 2000);
      }
    }

    // Enable/disable save button based on changes
    function updateSaveButton() {
      const textarea = document.getElementById("editor-textarea");
      const saveBtn = document.getElementById("save-btn");
      const hasChanges = textarea.value !== originalContent;
      // Disable save if read-only, no changes, or no file path
      saveBtn.disabled = isReadOnly || !hasChanges || !currentFilePath;
    }

    async function loadStreams(preserveSelection = false) {
      try {
        const response = await fetch("/api/streams");
        const data = await response.json();

        const selector = document.getElementById("stream-selector");
        const currentSelection = preserveSelection ? selector.value : "";

        if (!data.streams) {
          console.warn("No streams data received");
          return;
        }

        selector.innerHTML = '<option value="">Select a stream...</option>';

        if (data.streams.length > 0) {
          data.streams.forEach((stream) => {
            const option = document.createElement("option");
            option.value = stream.id;
            option.textContent = `PRD-${stream.id}: ${stream.name}`;
            selector.appendChild(option);
          });

          if (currentSelection && data.streams.some((s) => s.id === currentSelection)) {
            selector.value = currentSelection;
          }
        }
      } catch (error) {
        console.error("Failed to load streams:", error);
      }
    }

    document.getElementById("stream-selector").addEventListener("change", async (e) => {
      currentStreamId = e.target.value;
      currentFile = "";
      currentFilePath = "";
      originalContent = "";
      const fileSelector = document.getElementById("file-selector");
      const textarea = document.getElementById("editor-textarea");
      const preview = document.getElementById("preview-content");
      const openBtn = document.getElementById("open-in-editor-btn");

      if (!currentStreamId) {
        fileSelector.innerHTML = '<option value="">Select a file...</option>';
        fileSelector.disabled = true;
        textarea.value = "";
        textarea.placeholder = "Select a stream and file to edit...";
        preview.innerHTML = '<div class="empty-state"><p>Markdown preview will appear here</p></div>';
        openBtn.disabled = true;
        updateSaveButton();
        return;
      }

      try {
        const response = await fetch(`/api/streams/${currentStreamId}`);
        const data = await response.json();

        fileSelector.innerHTML = '<option value="">Select a file...</option>';

        const files = [];
        if (data.hasPrd) files.push({ value: "prd.md", label: "prd.md (Product Requirements)" });
        if (data.hasPlan) files.push({ value: "plan.md", label: "plan.md (Implementation Plan)" });
        if (data.hasProgress) files.push({ value: "progress.md", label: "progress.md (Progress Log)" });

        files.forEach((file) => {
          const option = document.createElement("option");
          option.value = file.value;
          option.textContent = file.label;
          fileSelector.appendChild(option);
        });

        fileSelector.disabled = files.length === 0;

        if (files.length === 0) {
          fileSelector.innerHTML = '<option value="">No files available</option>';
        } else if (files.length > 0) {
          fileSelector.value = files[0].value;
          fileSelector.dispatchEvent(new Event("change"));
        }
      } catch (error) {
        console.error("Failed to load stream details:", error);
        fileSelector.innerHTML = '<option value="">Error loading files</option>';
        fileSelector.disabled = true;
      }
    });

    document.getElementById("file-selector").addEventListener("change", async (e) => {
      currentFile = e.target.value;
      const textarea = document.getElementById("editor-textarea");
      const preview = document.getElementById("preview-content");
      const openBtn = document.getElementById("open-in-editor-btn");

      if (!currentFile || !currentStreamId) {
        textarea.value = "";
        textarea.placeholder = "Select a stream and file to edit...";
        preview.innerHTML = '<div class="empty-state"><p>Markdown preview will appear here</p></div>';
        openBtn.disabled = true;
        currentFilePath = "";
        originalContent = "";
        updateSaveButton();
        return;
      }

      try {
        const filePath = `PRD-${currentStreamId}/${currentFile}`;
        currentFilePath = filePath;
        const response = await fetch(`/api/files/${encodeURIComponent(filePath)}`);

        if (!response.ok) {
          throw new Error(`Failed to load file: ${response.status}`);
        }

        const content = await response.text();

        // Load into textarea
        textarea.value = content;
        originalContent = content;

        // Update preview
        updatePreview(content);

        // Load authorship metadata
        await loadAuthorship(filePath);

        openBtn.disabled = false;
        updateSaveButton();
      } catch (error) {
        console.error("Failed to load file:", error);
        textarea.value = "";
        textarea.placeholder = "Error loading file";
        preview.innerHTML = '<div class="empty-state"><p>Error loading file</p></div>';
        openBtn.disabled = true;
        currentFilePath = "";
        originalContent = "";
        currentAuthorship = null;
        updateAuthorshipUI();
        updateSaveButton();
      }
    });

    async function openInExternalEditor() {
      if (!currentFilePath) {
        return;
      }

      const openBtn = document.getElementById("open-in-editor-btn");
      openBtn.disabled = true;
      openBtn.textContent = "Opening...";

      try {
        const response = await fetch(`/api/files/${encodeURIComponent(currentFilePath)}/open`, {
          method: "POST",
        });

        if (!response.ok) {
          throw new Error("Failed to open file");
        }

        setTimeout(() => {
          openBtn.textContent = "Open in Editor";
          openBtn.disabled = false;
        }, 1000);
      } catch (error) {
        console.error("Failed to open file:", error);
        openBtn.textContent = "Open in Editor";
        openBtn.disabled = false;
      }
    }

    document.getElementById("open-in-editor-btn").addEventListener("click", openInExternalEditor);

    async function updatePreview(content) {
      const preview = document.getElementById("preview-content");

      if (!content || content.trim() === "") {
        preview.innerHTML = '<div class="empty-state"><p>Markdown preview will appear here</p></div>';
        return;
      }

      try {
        let html = "";
        if (typeof marked !== "undefined" && typeof marked.parse === "function") {
          html = marked.parse(content);
        } else {
          html = "<pre>" + escapeHtml(content) + "</pre>";
        }

        preview.innerHTML = html;

        // Render Mermaid diagrams
        if (typeof mermaid !== "undefined") {
          const mermaidBlocks = preview.querySelectorAll('code.language-mermaid');
          for (let i = 0; i < mermaidBlocks.length; i++) {
            const block = mermaidBlocks[i];
            const code = block.textContent;
            try {
              const { svg } = await mermaid.render(`mermaid-${Date.now()}-${i}`, code);
              const wrapper = document.createElement('div');
              wrapper.className = 'mermaid-wrapper';
              wrapper.innerHTML = svg;
              block.parentElement.replaceWith(wrapper);
            } catch (err) {
              console.error("Mermaid rendering error:", err);
              block.parentElement.innerHTML = `<pre style="color: red;">Mermaid Error: ${err.message}</pre>`;
            }
          }
        }
      } catch (error) {
        console.error("Markdown parsing error:", error);
        preview.innerHTML = "<pre>" + escapeHtml(content) + "</pre>";
      }
    }

    function escapeHtml(text) {
      const div = document.createElement("div");
      div.textContent = text;
      return div.innerHTML;
    }

    // ============================================
    // Authorship Tracking Functions
    // ============================================

    /**
     * Load authorship metadata for the current file
     */
    async function loadAuthorship(filePath) {
      try {
        const response = await fetch(`/api/authorship/${encodeURIComponent(filePath)}`);
        if (!response.ok) {
          currentAuthorship = null;
        } else {
          const data = await response.json();
          currentAuthorship = data.metadata;
        }
      } catch (error) {
        console.error("Failed to load authorship:", error);
        currentAuthorship = null;
      }
      updateAuthorshipUI();
    }

    /**
     * Save authorship metadata after file edit
     */
    async function saveAuthorship(content) {
      if (!currentFilePath) return;

      try {
        const response = await fetch(`/api/authorship/${encodeURIComponent(currentFilePath)}`, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            content: content,
            author: "human"
          })
        });

        if (response.ok) {
          const data = await response.json();
          currentAuthorship = data.metadata;
          updateAuthorshipUI();
        }
      } catch (error) {
        console.error("Failed to save authorship:", error);
      }
    }

    /**
     * Initialize authorship for files that don't have it
     */
    async function initializeAuthorship() {
      if (!currentFilePath) return;

      try {
        const response = await fetch(`/api/authorship/${encodeURIComponent(currentFilePath)}/initialize`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ defaultAuthor: "unknown" })
        });

        if (response.ok) {
          const data = await response.json();
          currentAuthorship = data.metadata;
          updateAuthorshipUI();
        }
      } catch (error) {
        console.error("Failed to initialize authorship:", error);
      }
    }

    /**
     * Toggle authorship highlighting on/off
     */
    function toggleAuthorship() {
      authorshipEnabled = !authorshipEnabled;

      // Update both edit and preview toggle buttons
      const toggleBtn = document.getElementById("authorship-toggle");
      const toggleBtnPreview = document.getElementById("authorship-toggle-preview");
      const legend = document.getElementById("authorship-legend");
      const legendPreview = document.getElementById("authorship-legend-preview");
      const lineHighlights = document.getElementById("editor-line-highlights");

      if (authorshipEnabled) {
        toggleBtn.classList.add("active");
        toggleBtnPreview.classList.add("active");
        legend.classList.add("visible");
        legendPreview.classList.add("visible");
        lineHighlights.classList.remove("hidden");

        // Initialize authorship if it doesn't exist
        if (!currentAuthorship && currentFilePath) {
          initializeAuthorship();
        } else {
          updateAuthorshipHighlights();
        }
      } else {
        toggleBtn.classList.remove("active");
        toggleBtnPreview.classList.remove("active");
        legend.classList.remove("visible");
        legendPreview.classList.remove("visible");
        lineHighlights.classList.add("hidden");
      }

      // Update preview with or without authorship classes
      if (currentView === "preview") {
        const textarea = document.getElementById("editor-textarea");
        updatePreview(textarea.value);
      }
    }

    /**
     * Update the authorship UI (stats badge and highlights)
     */
    function updateAuthorshipUI() {
      updateAuthorshipStats();
      if (authorshipEnabled) {
        updateAuthorshipHighlights();
      }
    }

    /**
     * Update the authorship stats badge
     */
    function updateAuthorshipStats() {
      const statsEl = document.getElementById("authorship-stats");
      const statsElPreview = document.getElementById("authorship-stats-preview");

      if (!currentAuthorship || !currentAuthorship.stats) {
        statsEl.textContent = "";
        statsElPreview.textContent = "";
        return;
      }

      const { aiPercentage, humanPercentage } = currentAuthorship.stats;
      const parts = [];
      if (aiPercentage > 0) parts.push(`${aiPercentage}% AI`);
      if (humanPercentage > 0) parts.push(`${humanPercentage}% Human`);

      const statsText = parts.length > 0 ? parts.join(" / ") : "100% Unknown";
      statsEl.textContent = statsText;
      statsElPreview.textContent = statsText;
    }

    /**
     * Update the line-by-line authorship highlights in the editor
     */
    function updateAuthorshipHighlights() {
      const highlightsEl = document.getElementById("editor-line-highlights");
      const textarea = document.getElementById("editor-textarea");

      if (!authorshipEnabled || !currentAuthorship) {
        highlightsEl.innerHTML = "";
        return;
      }

      const lines = textarea.value.split("\n");
      let html = "";

      for (let i = 0; i < lines.length; i++) {
        const lineNum = i + 1;
        const author = getAuthorForLine(lineNum);
        const cssClass = normalizeAuthorForCSS(author);
        // Use non-breaking space to preserve line height for empty lines
        const lineContent = lines[i] || "\u00A0";
        html += `<span class="line-highlight authorship-${cssClass}">${escapeHtml(lineContent)}</span>\n`;
      }

      highlightsEl.innerHTML = html;
    }

    /**
     * Get the author for a specific line number
     */
    function getAuthorForLine(lineNum) {
      if (!currentAuthorship || !currentAuthorship.blocks) {
        return currentAuthorship?.defaultAuthor || "unknown";
      }

      for (const block of currentAuthorship.blocks) {
        if (lineNum >= block.lineStart && lineNum <= block.lineEnd) {
          return block.modifiedBy || block.author;
        }
      }

      return currentAuthorship.defaultAuthor || "unknown";
    }

    /**
     * Normalize author type for CSS class naming
     */
    function normalizeAuthorForCSS(author) {
      if (author === "human") return "human";
      if (author === "unknown") return "unknown";
      if (author && author.startsWith("ai:claude")) return "ai-claude";
      if (author === "ai:codex") return "ai-codex";
      if (author === "ai:droid") return "ai-droid";
      return "unknown";
    }

    // Update the original updatePreview to support authorship highlighting
    const originalUpdatePreview = updatePreview;

    async function updatePreview(content) {
      const preview = document.getElementById("preview-content");

      if (!content || content.trim() === "") {
        preview.innerHTML = '<div class="empty-state"><p>Markdown preview will appear here</p></div>';
        return;
      }

      try {
        let html = "";
        if (typeof marked !== "undefined" && typeof marked.parse === "function") {
          // If authorship is enabled and we have metadata, use custom renderer
          if (authorshipEnabled && currentAuthorship) {
            html = parseMarkdownWithAuthorship(content);
          } else {
            html = marked.parse(content);
          }
        } else {
          html = "<pre>" + escapeHtml(content) + "</pre>";
        }

        preview.innerHTML = html;

        // Render Mermaid diagrams
        if (typeof mermaid !== "undefined") {
          const mermaidBlocks = preview.querySelectorAll('code.language-mermaid');
          for (let i = 0; i < mermaidBlocks.length; i++) {
            const block = mermaidBlocks[i];
            const code = block.textContent;
            try {
              const { svg } = await mermaid.render(`mermaid-${Date.now()}-${i}`, code);
              const wrapper = document.createElement('div');
              wrapper.className = 'mermaid-wrapper';
              wrapper.innerHTML = svg;
              block.parentElement.replaceWith(wrapper);
            } catch (err) {
              console.error("Mermaid rendering error:", err);
              block.parentElement.innerHTML = `<pre style="color: red;">Mermaid Error: ${err.message}</pre>`;
            }
          }
        }
      } catch (error) {
        console.error("Markdown parsing error:", error);
        preview.innerHTML = "<pre>" + escapeHtml(content) + "</pre>";
      }
    }

    /**
     * Parse markdown with authorship class annotations
     * Adds authorship-* classes to block elements based on line authorship
     */
    function parseMarkdownWithAuthorship(content) {
      const lines = content.split("\n");
      let html = "";
      let i = 0;

      while (i < lines.length) {
        const line = lines[i];
        const lineNum = i + 1;

        // Skip empty lines
        if (line.trim() === "") {
          i++;
          continue;
        }

        const author = getAuthorForLine(lineNum);
        const cssClass = normalizeAuthorForCSS(author);

        // Heading
        if (/^#{1,6}\s/.test(line)) {
          const level = line.match(/^(#{1,6})/)[1].length;
          const text = line.replace(/^#{1,6}\s*/, "");
          html += `<h${level} class="authorship-${cssClass}">${escapeHtml(text)}</h${level}>\n`;
          i++;
          continue;
        }

        // Code block
        if (line.startsWith("```")) {
          const blockStart = i;
          const codeLines = [line];
          i++;
          while (i < lines.length && !lines[i].startsWith("```")) {
            codeLines.push(lines[i]);
            i++;
          }
          if (i < lines.length) {
            codeLines.push(lines[i]);
            i++;
          }
          // For code blocks, use the authorship of the first line
          const codeContent = codeLines.slice(1, -1).join("\n");
          const lang = line.slice(3).trim();
          html += `<pre class="authorship-${cssClass}"><code class="${lang ? 'language-' + lang : ''}">${escapeHtml(codeContent)}</code></pre>\n`;
          continue;
        }

        // List item
        if (/^[\-\*\+]\s|^\d+\.\s/.test(line)) {
          const text = line.replace(/^[\-\*\+]\s+|^\d+\.\s+/, "");
          html += `<ul><li class="authorship-${cssClass}">${marked.parseInline ? marked.parseInline(text) : escapeHtml(text)}</li></ul>\n`;
          i++;
          continue;
        }

        // Paragraph (accumulate consecutive lines)
        const paragraphStart = i;
        const paragraphLines = [line];
        i++;
        while (i < lines.length && lines[i].trim() !== "" &&
               !/^#{1,6}\s/.test(lines[i]) &&
               !/^[\-\*\+]\s|^\d+\.\s/.test(lines[i]) &&
               !lines[i].startsWith("```")) {
          paragraphLines.push(lines[i]);
          i++;
        }
        const paragraphText = paragraphLines.join(" ");
        html += `<p class="authorship-${cssClass}">${marked.parseInline ? marked.parseInline(paragraphText) : escapeHtml(paragraphText)}</p>\n`;
      }

      return html;
    }

    // Update textarea scroll sync for highlights
    document.addEventListener("DOMContentLoaded", () => {
      const textarea = document.getElementById("editor-textarea");
      const highlights = document.getElementById("editor-line-highlights");

      if (textarea && highlights) {
        textarea.addEventListener("scroll", () => {
          highlights.scrollTop = textarea.scrollTop;
          highlights.scrollLeft = textarea.scrollLeft;
        });

        // Update highlights when content changes
        textarea.addEventListener("input", () => {
          if (authorshipEnabled) {
            // Debounce highlight updates
            clearTimeout(textarea._highlightTimeout);
            textarea._highlightTimeout = setTimeout(() => {
              updateAuthorshipHighlights();
            }, 100);
          }
        });
      }
    });
  </script>
</body>
</html>
