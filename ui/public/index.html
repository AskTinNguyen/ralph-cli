<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/png" href="/favicon.png">
  <title>Ralph CLI - From One to Many</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #ffffff;
      min-height: 100vh;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      overflow-x: hidden;
      overflow-y: auto;
      position: relative;
      scroll-behavior: smooth;
    }

    /* Grid container */
    .logo-grid {
      display: grid;
      grid-template-columns: repeat(var(--cols), 1fr);
      gap: 2px;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      perspective: 1000px;
      transform-style: preserve-3d;
    }

    /* Individual tile */
    .tile {
      width: 100%;
      aspect-ratio: 1;
      background: #fff;
      border: 1px solid #e0e0e0;
      display: flex;
      align-items: center;
      justify-content: center;
      transform-style: preserve-3d;
      transition: transform 0.3s ease-out, box-shadow 0.3s ease-out;
    }

    .tile img {
      width: 80%;
      height: 80%;
      object-fit: contain;
      filter: grayscale(100%);
      opacity: 0.7;
      transition: opacity 0.3s ease;
    }

    .tile.elevated {
      transform: translateZ(30px) scale(1.02);
      box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
      z-index: 10;
    }

    .tile.elevated img {
      opacity: 1;
    }

    .tile.slight-elevated {
      transform: translateZ(15px) scale(1.01);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
    }

    .tile.slight-elevated img {
      opacity: 0.85;
    }

    /* Hero section */
    .hero-section {
      position: relative;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }

    .hero-content {
      text-align: center;
      pointer-events: none;
    }

    .tagline {
      font-size: clamp(1.5rem, 4vw, 3rem);
      font-weight: 300;
      color: #1a1a1a;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      background: rgba(255, 255, 255, 0.95);
      padding: 1.5rem 3rem;
      border: 2px solid #1a1a1a;
      text-shadow: none;
      margin-bottom: 2rem;
    }

    .tagline strong {
      font-weight: 700;
    }

    .scroll-hint {
      font-size: 0.875rem;
      color: #666;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      background: rgba(255, 255, 255, 0.9);
      padding: 0.75rem 1.5rem;
      border: 1px solid #ccc;
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; transform: translateY(0); }
      50% { opacity: 0.6; transform: translateY(-5px); }
    }

    /* Philosophy section */
    .philosophy-section {
      position: relative;
      min-height: 100vh;
      background: rgba(255, 255, 255, 0.98);
      z-index: 100;
      padding: 4rem 2rem;
      border-top: 2px solid #1a1a1a;
    }

    .philosophy-content {
      max-width: 800px;
      margin: 0 auto;
      line-height: 1.8;
    }

    .philosophy-content h2 {
      font-size: clamp(2rem, 5vw, 3rem);
      font-weight: 300;
      letter-spacing: 0.05em;
      margin-bottom: 2rem;
      text-transform: uppercase;
      color: #1a1a1a;
    }

    .philosophy-content p {
      font-size: clamp(1rem, 2vw, 1.25rem);
      color: #333;
      margin-bottom: 1.5rem;
    }

    .philosophy-content strong {
      font-weight: 600;
      color: #1a1a1a;
    }

    .philosophy-content ul {
      list-style: none;
      margin: 2rem 0;
      padding-left: 1rem;
    }

    .philosophy-content li {
      font-size: clamp(1rem, 2vw, 1.125rem);
      color: #333;
      margin-bottom: 1rem;
      padding-left: 1.5rem;
      position: relative;
    }

    .philosophy-content li::before {
      content: "â†’";
      position: absolute;
      left: 0;
      color: #1a1a1a;
      font-weight: bold;
    }

    .philosophy-content code {
      background: #f5f5f5;
      padding: 0.2rem 0.4rem;
      border-radius: 3px;
      font-family: 'Monaco', 'Courier New', monospace;
      font-size: 0.9em;
      color: #d63384;
      border: 1px solid #e0e0e0;
    }

    /* Visual story section */
    .visual-story {
      text-align: center;
      margin: 0 0 4rem 0;
      padding: 2rem 0;
    }

    .hero-ralph {
      max-width: 300px;
      width: 100%;
      height: auto;
      margin: 0 auto 3rem;
      display: block;
      filter: drop-shadow(0 10px 30px rgba(0, 0, 0, 0.15));
    }

    .arrow-down {
      font-size: 2rem;
      color: #1a1a1a;
      margin: 1rem 0 2rem;
      animation: arrowBounce 2s ease-in-out infinite;
    }

    @keyframes arrowBounce {
      0%, 100% { transform: translateY(0); opacity: 1; }
      50% { transform: translateY(10px); opacity: 0.6; }
    }

    .agents-grid {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 1.5rem;
      max-width: 800px;
      margin: 0 auto;
      padding: 2rem;
      background: rgba(245, 245, 245, 0.5);
      border-radius: 8px;
      border: 2px dashed #ccc;
    }

    .agent-icon {
      width: 80px;
      height: 80px;
      margin: 0 auto;
      animation: agentVibrate 0.3s ease-in-out infinite;
      animation-delay: calc(var(--agent-index) * 0.1s);
      filter: grayscale(100%);
      opacity: 0.8;
      transition: all 0.3s ease;
    }

    .agent-icon:hover {
      filter: grayscale(0%);
      opacity: 1;
      transform: scale(1.1);
    }

    @keyframes agentVibrate {
      0%, 100% {
        transform: translate(0, 0) rotate(0deg);
      }
      25% {
        transform: translate(-2px, -1px) rotate(-1deg);
      }
      50% {
        transform: translate(2px, 1px) rotate(1deg);
      }
      75% {
        transform: translate(-1px, 2px) rotate(-0.5deg);
      }
    }

    @media (max-width: 600px) {
      .agents-grid {
        grid-template-columns: repeat(4, 1fr);
        gap: 1rem;
        padding: 1.5rem;
      }

      .agent-icon {
        width: 60px;
        height: 60px;
      }
    }

    /* Fixed CTA button - bottom right */
    .enter-btn {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      padding: 1rem 2rem;
      font-size: 0.875rem;
      font-weight: 500;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      color: #fff;
      background: #1a1a1a;
      border: 2px solid #1a1a1a;
      text-decoration: none;
      transition: all 0.3s ease;
      z-index: 200;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      cursor: pointer;
    }

    .enter-btn:hover {
      background: #fff;
      color: #1a1a1a;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
      transform: translateY(-2px);
    }

    .enter-btn-hint {
      display: block;
      font-size: 0.7rem;
      margin-top: 0.25rem;
      opacity: 0.7;
      letter-spacing: 0.1em;
    }

    /* Traversing color Ralph */
    .traverser {
      position: fixed;
      z-index: 50;
      pointer-events: none;
      will-change: transform;
      background: #fff;
      border-radius: 6px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.25);
      padding: 4px;
      overflow: hidden;
    }

    .traverser img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: block;
      background: #fff;
    }

    .traverser.bounce {
      animation: bounce 0.5s ease-in-out infinite alternate;
    }

    @keyframes bounce {
      from { transform: translateY(0); }
      to { transform: translateY(-10px); }
    }

    /* Responsive grid columns */
    @media (min-width: 1400px) {
      :root { --cols: 12; }
    }
    @media (min-width: 1000px) and (max-width: 1399px) {
      :root { --cols: 10; }
    }
    @media (min-width: 700px) and (max-width: 999px) {
      :root { --cols: 8; }
    }
    @media (max-width: 699px) {
      :root { --cols: 6; }
    }
  </style>
</head>
<body>
  <div class="logo-grid" id="grid"></div>
  <div id="traversers"></div>

  <!-- Hero Section -->
  <section class="hero-section">
    <div class="hero-content">
      <div class="tagline"><strong>Ralph</strong> &mdash; From One to Many</div>
      <div class="scroll-hint">â†“ Scroll to Explore â†“</div>
    </div>
  </section>

  <!-- Philosophy Section -->
  <section class="philosophy-section">
    <div class="philosophy-content">
      <!-- Visual Story -->
      <div class="visual-story">
        <img src="/ralph-hero.png" alt="Ralph - The One" class="hero-ralph">
        <div class="arrow-down">â†“</div>
        <div class="agents-grid" id="agents-grid">
          <!-- Agents generated by JavaScript -->
        </div>
      </div>

      <h2>ðŸš€ The Ralph Wiggum Technique</h2>

      <p>
        Named after the persistent (and often confused) Simpsons character, the <strong>Ralph Wiggum Loop</strong>
        is a methodology for autonomous software development that embraces a counterintuitive truth:
        <strong>"Iteration beats perfection."</strong>
      </p>

      <p>
        Instead of trying to coax a perfect result from an AI in one shot, you put the agent in an infinite loop.
        Feed it a prompt, let it write code and tests, and if it fails or tries to exit before the task is truly doneâ€”the
        loop re-injects the same prompt. Again. And again.
      </p>

      <p>
        <strong>Why it works:</strong> Large language models are probabilistic. They might fail spectacularly on iteration 1
        but nail it on iteration 10. By clearing the context window but preserving updated files and git history,
        the AI effectively "wakes up" freshâ€”seeing the progress made by its predecessor without the baggage of previous failures.
      </p>

      <p>
        <strong>Real-world proof:</strong> Huntley famously used this technique to build "Cursed Lang," a programming language
        featuring Gen Z slang keywords like <code>no_cap</code> and <code>fr</code>, by running a Ralph loop continuously
        for <strong>three consecutive months</strong>. The result? A fully functional, battle-tested language born from
        relentless iteration.
      </p>

      <h2>From One to Many</h2>

      <p>
        Ralph loops scale the technique horizontally. What starts as a single agent iterating on one task becomes
        <strong>many agents executing in parallel streams</strong>â€”each with its own isolated workspace, progress tracking,
        and autonomous decision-making.
      </p>

      <p>
        Traditional development is linear: one developer, one task, one outcome. Ralph loops are exponential:
        one specification multiplies into concurrent work streams, each progressing independently while maintaining coherence
        through shared learnings captured in guardrails.
      </p>

      <h2>Beyond Software</h2>

      <p>
        This implementation is the <strong>first iteration</strong> of a paradigm that extends far beyond code.
        Any domain requiring systematic execution, learning from failures, and relentless iteration can benefit:
      </p>

      <ul>
        <li><strong>Research & Development:</strong> Parallel hypothesis testing with autonomous learning from failures</li>
        <li><strong>Content Creation:</strong> Multi-stream narrative development with coherent convergence</li>
        <li><strong>Design Systems:</strong> Concurrent exploration of design spaces with automated constraint satisfaction</li>
        <li><strong>Business Strategy:</strong> Parallel scenario planning with adaptive resource allocation</li>
        <li><strong>Scientific Computing:</strong> Multi-parameter optimization with autonomous backtracking</li>
      </ul>

      <h2>The Vision</h2>

      <p>
        As large language models become more capable, the complexity and scope of what Ralph loops can autonomously
        accomplish will expand dramatically. This isn't about replacing human creativityâ€”it's about
        <strong>amplifying human intent</strong>.
      </p>

      <p>
        We define the vision. Ralph loops execute with machine precision and tireless iteration. The result?
        Productivity that scales not with headcount, but with the clarity of human goals and the boundless capacity
        of AI to pursue them relentlessly.
      </p>

      <p>
        <strong>This is just the beginning.</strong> Every iteration brings us closer to unlocking humanity's full
        productive potential.
      </p>
    </div>
  </section>

  <!-- Fixed CTA Button -->
  <a href="/dashboard.html" class="enter-btn">
    READY TO LOOP?
    <span class="enter-btn-hint">Press Enter â†µ</span>
  </a>

  <script>
    const grid = document.getElementById('grid');
    const logoSrc = '/ralph-logo-bw.png';

    // Calculate grid size based on viewport
    function getGridSize() {
      const width = window.innerWidth;
      let cols;
      if (width >= 1400) cols = 12;
      else if (width >= 1000) cols = 10;
      else if (width >= 700) cols = 8;
      else cols = 6;

      const tileSize = width / cols;
      const rows = Math.ceil(window.innerHeight / tileSize) + 1;
      return { cols, rows, total: cols * rows };
    }

    // Create tiles
    function createGrid() {
      const { cols, rows, total } = getGridSize();
      grid.innerHTML = '';
      grid.style.setProperty('--cols', cols);

      for (let i = 0; i < total; i++) {
        const tile = document.createElement('div');
        tile.className = 'tile';
        tile.dataset.index = i;
        tile.dataset.col = i % cols;
        tile.dataset.row = Math.floor(i / cols);

        const img = document.createElement('img');
        img.src = logoSrc;
        img.alt = 'Ralph';
        img.draggable = false;

        tile.appendChild(img);
        grid.appendChild(tile);
      }
    }

    // Wave animation
    let animationId;
    let time = 0;

    function animateWave() {
      const tiles = document.querySelectorAll('.tile');
      const { cols } = getGridSize();
      const centerX = cols / 2;
      const centerY = (tiles.length / cols) / 2;

      tiles.forEach(tile => {
        const col = parseInt(tile.dataset.col);
        const row = parseInt(tile.dataset.row);

        // Create wave pattern emanating from center
        const dx = col - centerX;
        const dy = row - centerY;
        const distance = Math.sqrt(dx * dx + dy * dy);

        // Multiple wave sources for more dynamic effect
        const wave1 = Math.sin(distance * 0.8 - time * 2) * 0.5 + 0.5;
        const wave2 = Math.sin(distance * 0.5 + time * 1.5 + Math.PI) * 0.3 + 0.5;
        const combined = (wave1 + wave2) / 2;

        tile.classList.remove('elevated', 'slight-elevated');

        if (combined > 0.75) {
          tile.classList.add('elevated');
        } else if (combined > 0.55) {
          tile.classList.add('slight-elevated');
        }
      });

      time += 0.03;
      animationId = requestAnimationFrame(animateWave);
    }

    // Initialize
    createGrid();
    animateWave();

    // Handle resize
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        cancelAnimationFrame(animationId);
        createGrid();
        animateWave();
      }, 200);
    });

    // Traversing Color Ralph
    const traversersContainer = document.getElementById('traversers');
    const colorLogoSrc = '/ralph-logo.png';
    const activeTraversers = [];
    const maxTraversers = 3;

    function createTraverser() {
      if (activeTraversers.length >= maxTraversers) return;

      const { cols } = getGridSize();
      const tileSize = window.innerWidth / cols;
      const size = tileSize * (0.8 + Math.random() * 0.4); // Random size variation

      const traverser = document.createElement('div');
      traverser.className = 'traverser bounce';
      traverser.style.width = size + 'px';
      traverser.style.height = size + 'px';

      // Random vertical position (avoid center where tagline is)
      const centerY = window.innerHeight / 2;
      const avoidZone = 150;
      let yPos;
      if (Math.random() > 0.5) {
        yPos = Math.random() * (centerY - avoidZone - size);
      } else {
        yPos = centerY + avoidZone + Math.random() * (window.innerHeight - centerY - avoidZone - size);
      }
      traverser.style.top = yPos + 'px';

      // Start from left or right
      const fromLeft = Math.random() > 0.5;
      const startX = fromLeft ? -size : window.innerWidth;
      const endX = fromLeft ? window.innerWidth : -size;
      traverser.style.left = startX + 'px';

      const img = document.createElement('img');
      img.src = colorLogoSrc;
      img.alt = 'Color Ralph';
      img.draggable = false;
      traverser.appendChild(img);

      traversersContainer.appendChild(traverser);
      activeTraversers.push(traverser);

      // Animate across screen
      const duration = 8000 + Math.random() * 6000; // 8-14 seconds
      const startTime = performance.now();

      function moveTraverser(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = elapsed / duration;

        if (progress >= 1) {
          traverser.remove();
          const idx = activeTraversers.indexOf(traverser);
          if (idx > -1) activeTraversers.splice(idx, 1);
          return;
        }

        // Easing for smooth movement
        const x = startX + (endX - startX) * progress;

        // Add subtle wave motion synced with grid
        const waveOffset = Math.sin(progress * Math.PI * 4 + time) * 20;

        traverser.style.left = x + 'px';
        traverser.style.top = (yPos + waveOffset) + 'px';

        requestAnimationFrame(moveTraverser);
      }

      requestAnimationFrame(moveTraverser);
    }

    // Spawn traversers at random intervals
    function scheduleNextTraverser() {
      const delay = 3000 + Math.random() * 5000; // 3-8 seconds
      setTimeout(() => {
        createTraverser();
        scheduleNextTraverser();
      }, delay);
    }

    // Start spawning after a short delay
    setTimeout(() => {
      createTraverser();
      scheduleNextTraverser();
    }, 2000);

    // Enter key shortcut to navigate to dashboard
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey && !e.ctrlKey && !e.metaKey && !e.altKey) {
        // Only trigger if not typing in an input field
        if (document.activeElement.tagName !== 'INPUT' &&
            document.activeElement.tagName !== 'TEXTAREA') {
          window.location.href = '/dashboard.html';
        }
      }
    });

    // Generate agent icons (2 rows of 8 = 16 agents)
    const agentsGrid = document.getElementById('agents-grid');
    const agentCount = 16;
    for (let i = 0; i < agentCount; i++) {
      const agent = document.createElement('img');
      agent.src = '/ralph-agent-bw.png';
      agent.alt = `Agent ${i + 1}`;
      agent.className = 'agent-icon';
      agent.style.setProperty('--agent-index', i);
      agent.draggable = false;
      agentsGrid.appendChild(agent);
    }
  </script>
</body>
</html>
