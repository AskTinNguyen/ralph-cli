<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ralph CLI - Streams</title>
  <link rel="stylesheet" href="/css/rams-ui.css">
  <script src="/js/htmx.min.js"></script>
  <style>
    /* Tab Navigation */
    .rams-tabs {
      display: flex;
      gap: var(--rams-space-1);
      border-bottom: 1px solid var(--rams-gray-200);
      margin-bottom: var(--rams-space-6);
    }

    .rams-tab {
      padding: var(--rams-space-3) var(--rams-space-5);
      background: none;
      border: none;
      border-bottom: 2px solid transparent;
      color: var(--rams-gray-600);
      font-size: var(--rams-text-base);
      font-weight: 500;
      cursor: pointer;
      transition: all var(--rams-transition-fast);
    }

    .rams-tab:hover {
      color: var(--rams-gray-900);
      background: var(--rams-gray-50);
    }

    .rams-tab.active {
      color: var(--rams-accent);
      border-bottom-color: var(--rams-accent);
      font-weight: 600;
    }

    .rams-tab-content {
      display: none;
    }

    .rams-tab-content.active {
      display: block;
    }

    /* Documentation styles within monitoring page */
    .docs-section {
      margin-bottom: var(--rams-space-8);
    }

    .docs-section h3 {
      font-size: var(--rams-text-xl);
      font-weight: 600;
      margin-bottom: var(--rams-space-3);
      color: var(--rams-gray-900);
    }

    .docs-section p {
      color: var(--rams-gray-700);
      line-height: 1.6;
      margin-bottom: var(--rams-space-3);
    }

    .docs-step-number {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: var(--rams-accent);
      color: var(--rams-white);
      font-weight: 600;
      margin-right: var(--rams-space-3);
    }

    .docs-code {
      background: var(--rams-gray-50);
      padding: var(--rams-space-4);
      border-radius: var(--rams-radius-md);
      font-family: 'SF Mono', 'Monaco', 'Inconsolata', monospace;
      font-size: 0.875rem;
      margin: var(--rams-space-3) 0;
      overflow-x: auto;
    }

    .docs-info-box {
      background: rgba(26, 77, 46, 0.04);
      border-left: 3px solid var(--rams-accent);
      padding: var(--rams-space-4);
      margin: var(--rams-space-4) 0;
      border-radius: var(--rams-radius-md);
    }

    .docs-info-box strong {
      font-weight: 600;
      color: var(--rams-gray-900);
    }
  </style>
</head>
<body class="rams-page">

  <!-- Persistent Sidebar -->
  <aside class="rams-sidebar">
    <div class="rams-sidebar-header">
      <div class="rams-logo">
        <div class="rams-logo-mark"></div>
        <span class="rams-logo-text">RALPH</span>
      </div>
    </div>

    <nav class="rams-nav">
      <div class="rams-nav-section">
        <div class="rams-nav-label">Main</div>
        <ul class="rams-nav-items">
          <li><a href="/" class="rams-nav-link">Dashboard</a></li>
          <li><a href="/streams.html" class="rams-nav-link active">Streams</a></li>
          <li><a href="/docs/" class="rams-nav-link">Documentation</a></li>
        </ul>
      </div>

      <div class="rams-nav-section">
        <div class="rams-nav-label">Monitoring</div>
        <ul class="rams-nav-items">
          <li><a href="/logs.html" class="rams-nav-link">Logs</a></li>
          <li><a href="/tokens.html" class="rams-nav-link">Tokens</a></li>
          <li><a href="/trends.html" class="rams-nav-link">Trends</a></li>
        </ul>
      </div>

      <div class="rams-nav-section">
        <div class="rams-nav-label">Tools</div>
        <ul class="rams-nav-items">
          <li><a href="/editor.html" class="rams-nav-link">Editor</a></li>
          <li><a href="/chat.html" class="rams-nav-link">Chat</a></li>
        </ul>
      </div>
    </nav>

    <div class="rams-sidebar-footer">
      <div class="rams-version">v1.0.0</div>
    </div>
  </aside>

  <!-- Main Content -->
  <main class="rams-main">

    <!-- Top Bar -->
    <div class="rams-topbar">
      <div class="rams-breadcrumb">
        <span class="rams-breadcrumb-current">Streams</span>
      </div>
      <div class="rams-topbar-actions">
        <button
          class="rams-btn rams-btn-primary"
          hx-post="/api/stream/new"
          hx-target="#streams-container"
          hx-swap="innerHTML"
          hx-on::after-request="handleNewStreamResponse(event)"
        >
          + New Stream
        </button>
      </div>
    </div>

    <!-- Content Area -->
    <article class="rams-content">

      <!-- Alert Container -->
      <div id="alert-container"></div>

      <!-- Tab Navigation -->
      <div class="rams-tabs">
        <button class="rams-tab active" onclick="switchTab('monitor')">
          Monitor
        </button>
        <button class="rams-tab" onclick="switchTab('documentation')">
          Documentation
        </button>
      </div>

      <!-- Monitor Tab Content -->
      <div id="monitor-tab" class="rams-tab-content active">

        <!-- Streams Overview Section -->
        <section class="rams-section">
          <div class="rams-section-header">
            <h2 class="rams-h2">
              Streams Overview
              <span class="htmx-indicator" id="summary-indicator">
                <span class="rams-spinner"></span>
              </span>
            </h2>
          </div>
          <div
            id="streams-summary"
            hx-get="/api/partials/streams-summary"
            hx-trigger="load, every 5s"
            hx-swap="innerHTML"
            hx-indicator="#summary-indicator"
          >
            <div class="rams-loading">
              <span class="rams-spinner"></span> Loading streams summary...
            </div>
          </div>
        </section>

        <!-- Streams List Section -->
        <section class="rams-section">
          <div class="rams-section-header">
            <h2 class="rams-h2">
              All Streams
              <span class="htmx-indicator" id="streams-indicator">
                <span class="rams-spinner"></span>
              </span>
            </h2>
          </div>
          <div
            id="streams-container"
            hx-get="/api/partials/streams"
            hx-trigger="load, every 5s, newStreamCreated from:body"
            hx-swap="innerHTML"
            hx-indicator="#streams-indicator"
          >
            <div class="rams-loading">
              <span class="rams-spinner"></span> Loading streams...
            </div>
          </div>
        </section>

        <!-- Stream Detail Section (shown when a stream is selected) -->
        <section id="stream-detail-section" class="rams-section rams-hidden">
          <div class="rams-section-header">
            <div style="display: flex; align-items: center; gap: var(--rams-space-3); margin-bottom: var(--rams-space-4);">
              <button
                type="button"
                onclick="hideStreamDetail()"
                class="rams-btn rams-btn-secondary"
                style="padding: var(--rams-space-2) var(--rams-space-3);"
              >
                ← Back to Streams
              </button>
              <h2 class="rams-h2" id="stream-detail-title" style="margin: 0;">Stream Detail</h2>
            </div>
          </div>
          <div id="stream-detail-container">
            <!-- Stream detail content loaded via HTMX -->
          </div>
        </section>

      </div>

      <!-- Documentation Tab Content -->
      <div id="documentation-tab" class="rams-tab-content">

        <!-- Introduction -->
        <section class="docs-section">
          <h3>What Are Streams?</h3>
          <p>
            Streams allow you to run multiple PRD builds in parallel, each in complete isolation.
            Think of it like having multiple workbenches in a workshop - each craftsperson can work
            on their own project simultaneously without interfering with others.
          </p>
          <div class="docs-info-box">
            <strong>Key Benefits:</strong>
            <ul style="margin: var(--rams-space-2) 0 0 var(--rams-space-5); color: var(--rams-gray-700);">
              <li><strong>Speed:</strong> Build multiple PRDs simultaneously (40-55% time savings)</li>
              <li><strong>Isolation:</strong> Each stream has its own working directory</li>
              <li><strong>Safety:</strong> Built-in locks and validation prevent conflicts</li>
            </ul>
          </div>
        </section>

        <!-- Quick Start -->
        <section class="docs-section">
          <h3><span class="docs-step-number">1</span> Quick Start Guide</h3>
          <p><strong>Step 1: Create Multiple PRDs</strong></p>
          <div class="docs-code">ralph prd  # Creates PRD-1
ralph prd  # Creates PRD-2
# Edit .ralph/PRD-N/prd.md for each</div>

          <p><strong>Step 2: Create Plans</strong></p>
          <div class="docs-code">ralph plan --prd=1
ralph plan --prd=2</div>

          <p><strong>Step 3: Initialize Worktrees</strong></p>
          <div class="docs-code">ralph stream init 1  # Creates branch ralph/PRD-1
ralph stream init 2  # Creates branch ralph/PRD-2</div>

          <p><strong>Step 4: Build in Parallel</strong></p>
          <div class="docs-code">ralph stream build 1 5 &  # Run in background
ralph stream build 2 5 &  # Run in background
ralph stream status      # Monitor progress</div>

          <p><strong>Step 5: Merge When Complete</strong></p>
          <div class="docs-code">ralph stream merge 1
ralph stream merge 2</div>
        </section>

        <!-- Architecture -->
        <section class="docs-section">
          <h3><span class="docs-step-number">2</span> Stream Architecture</h3>
          <p>Each stream operates in isolated layers:</p>

          <p><strong>Git Branches</strong></p>
          <div class="docs-code">ralph/PRD-1  - Feature branch for PRD 1
ralph/PRD-2  - Feature branch for PRD 2
ralph/PRD-3  - Feature branch for PRD 3</div>

          <p><strong>Worktrees (Isolated Directories)</strong></p>
          <div class="docs-code">.ralph/worktrees/PRD-1/  - Complete repo checkout on ralph/PRD-1
.ralph/worktrees/PRD-2/  - Complete repo checkout on ralph/PRD-2
.ralph/worktrees/PRD-3/  - Complete repo checkout on ralph/PRD-3</div>

          <p><strong>Safety Mechanisms</strong></p>
          <ul style="margin: var(--rams-space-2) 0 0 var(--rams-space-5); color: var(--rams-gray-700);">
            <li><strong>Lock Files:</strong> Prevent concurrent builds of same PRD</li>
            <li><strong>Status Validation:</strong> Git history is source of truth</li>
            <li><strong>Merge Queue:</strong> Only one merge to main at a time</li>
          </ul>
        </section>

        <!-- Understanding Worktrees -->
        <section class="docs-section">
          <h3><span class="docs-step-number">3</span> Understanding Worktrees</h3>
          <p>
            Worktrees are Git's feature for having multiple working directories from the same repository.
            Traditional Git requires switching branches, which changes all your files. With worktrees,
            you can have multiple branches checked out simultaneously in different directories.
          </p>

          <div class="docs-info-box">
            <strong>The Office Analogy:</strong><br>
            <strong>Traditional Git:</strong> One desk. To work on a different project, clear your desk and bring out new files.<br>
            <strong>With Worktrees:</strong> Multiple desks in different rooms. Walk between rooms and work on whichever project you want.
          </div>
        </section>

        <!-- Safety Features -->
        <section class="docs-section">
          <h3><span class="docs-step-number">4</span> Safety Features</h3>

          <p><strong>Lock Files</strong></p>
          <p>Each stream gets a lock file when a build starts, preventing duplicate runs:</p>
          <div class="docs-code">.ralph/locks/PRD-N.lock  # Contains process ID (PID)
- Created when build starts
- Validated before each build
- Stale locks auto-removed</div>

          <p><strong>Status Validation</strong></p>
          <p>Ralph cross-checks file markers against Git history:</p>
          <ul style="margin: var(--rams-space-2) 0 0 var(--rams-space-5); color: var(--rams-gray-700);">
            <li>Git is the source of truth, not file markers</li>
            <li>Auto-corrects missing .merged markers</li>
            <li>Detects and fixes stale status</li>
          </ul>

          <p><strong>Merge Queue</strong></p>
          <p>Only one stream can merge to main at a time:</p>
          <div class="docs-code"># Global lock prevents parallel merges
.ralph/locks/merge.lock
- Auto-cleanup if process dies
- 5-minute max wait timeout</div>
        </section>

        <!-- When to Use Streams -->
        <section class="docs-section">
          <h3><span class="docs-step-number">5</span> When to Use Streams</h3>

          <p><strong>✓ Use Streams When:</strong></p>
          <ul style="margin: var(--rams-space-2) 0 0 var(--rams-space-5); color: var(--rams-gray-700);">
            <li>Features touch different files (no overlap)</li>
            <li>Multiple features needed for same deadline</li>
            <li>Long-running builds (30+ minutes each)</li>
            <li>Team collaboration on separate features</li>
          </ul>

          <p><strong>✗ Avoid Streams When:</strong></p>
          <ul style="margin: var(--rams-space-2) 0 0 var(--rams-space-5); color: var(--rams-gray-700);">
            <li>Sequential dependencies (PRD-2 needs PRD-1 first)</li>
            <li>Multiple PRDs modifying same files</li>
            <li>Quick fixes (1-2 iterations only)</li>
            <li>Learning Ralph (master sequential builds first)</li>
          </ul>
        </section>

        <!-- Performance -->
        <section class="docs-section">
          <h3><span class="docs-step-number">6</span> Performance Tips</h3>

          <p><strong>Optimal Configuration</strong></p>
          <div class="docs-info-box">
            <strong>Recommended: 2-3 parallel streams</strong><br>
            Best speed vs complexity trade-off. Manageable on most laptops (4GB+ RAM).
            Low risk of rate limiting.
          </div>

          <p><strong>Time Savings</strong></p>
          <ul style="margin: var(--rams-space-2) 0 0 var(--rams-space-5); color: var(--rams-gray-700);">
            <li>2 medium PRDs: ~35 min sequential → ~20 min parallel (43% faster)</li>
            <li>3 small PRDs: ~30 min sequential → ~15 min parallel (50% faster)</li>
            <li>4 small PRDs: ~40 min sequential → ~18 min parallel (55% faster)</li>
          </ul>

          <p><strong>Optimization Tips</strong></p>
          <ul style="margin: var(--rams-space-2) 0 0 var(--rams-space-5); color: var(--rams-gray-700);">
            <li>Stagger starts 1-2 minutes apart to avoid API burst</li>
            <li>Group small PRDs together, large PRDs separately</li>
            <li>Monitor logs in .ralph/PRD-N/runs/</li>
            <li>Merge completed streams immediately to free resources</li>
          </ul>
        </section>

        <!-- Common Commands -->
        <section class="docs-section">
          <h3>Common Commands Reference</h3>

          <p><strong>Stream Management</strong></p>
          <div class="docs-code">ralph stream list          # List all streams
ralph stream status        # Show stream status
ralph stream init N        # Initialize worktree for PRD-N</div>

          <p><strong>Building</strong></p>
          <div class="docs-code">ralph stream build N 5     # Build PRD-N for 5 iterations
ralph stream build N 5 --no-worktree  # Build without worktree
ralph stream build N 5 --force        # Force build (ignore locks)</div>

          <p><strong>Merging</strong></p>
          <div class="docs-code">ralph stream merge N       # Merge PRD-N to main</div>

          <p><strong>Status Management</strong></p>
          <div class="docs-code">ralph stream mark-completed N    # Mark as completed
ralph stream verify-status       # Auto-fix stale status</div>
        </section>

      </div>

    </article>

  </main>

  <!-- Error Toast -->
  <div id="error-toast" class="rams-alert rams-alert-error rams-hidden" style="position: fixed; bottom: var(--rams-space-6); right: var(--rams-space-6); max-width: 400px; z-index: 1000; box-shadow: var(--rams-shadow-lg);">
    <div style="display: flex; justify-content: space-between; align-items: start; gap: var(--rams-space-4);">
      <div style="flex: 1;">
        <div style="font-weight: 600; margin-bottom: var(--rams-space-1);">Error</div>
        <div id="error-toast-message" class="rams-text-sm"></div>
      </div>
      <button onclick="dismissErrorToast()" style="background: none; border: none; color: inherit; cursor: pointer; font-size: 20px; line-height: 1;">&times;</button>
    </div>
  </div>

  <script>
    // Tab Switching
    function switchTab(tabName) {
      // Update tab buttons
      document.querySelectorAll('.rams-tab').forEach(tab => {
        tab.classList.remove('active');
      });
      event.target.classList.add('active');

      // Update tab content
      document.querySelectorAll('.rams-tab-content').forEach(content => {
        content.classList.remove('active');
      });
      document.getElementById(tabName + '-tab').classList.add('active');

      // Store active tab in localStorage
      localStorage.setItem('activeStreamsTab', tabName);
    }

    // Restore active tab on page load
    document.addEventListener('DOMContentLoaded', function() {
      const activeTab = localStorage.getItem('activeStreamsTab') || 'monitor';
      if (activeTab === 'documentation') {
        document.querySelector('.rams-tab[onclick*="documentation"]').click();
      }
    });

    // Show stream detail view
    function showStreamDetail(streamId, streamName) {
      document.getElementById("streams-overview").style.display = "none";
      document.getElementById("streams-list-section").style.display = "none";
      var detailSection = document.getElementById("stream-detail-section");
      detailSection.classList.remove("rams-hidden");
      detailSection.style.display = "block";
      document.getElementById("stream-detail-title").textContent = streamName;

      // Load stream detail content via HTMX
      htmx.ajax("GET", "/api/partials/stream-detail?id=" + streamId, "#stream-detail-container");
    }

    // Show stream detail view and switch to estimate tab
    function showStreamDetailAndEstimate(streamId, streamName) {
      showStreamDetail(streamId, streamName);

      // Wait for HTMX to load the content, then switch to estimate tab
      setTimeout(function() {
        var estimateTab = document.querySelector('.stream-tab[onclick*="estimate"]');
        if (estimateTab) {
          estimateTab.click();
        }
      }, 300);
    }

    // Hide stream detail view and show streams list
    function hideStreamDetail() {
      var overviewSection = document.getElementById("streams-overview");
      if (overviewSection) overviewSection.style.display = "block";

      var listSection = document.querySelector(".rams-section:nth-of-type(2)");
      if (listSection) listSection.style.display = "block";

      var detailSection = document.getElementById("stream-detail-section");
      detailSection.classList.add("rams-hidden");
      detailSection.style.display = "none";
    }

    // Show alert message
    function showAlert(type, message, duration) {
      var container = document.getElementById("alert-container");
      var alert = document.createElement("div");
      alert.className = "rams-alert rams-alert-" + type;
      alert.textContent = message;
      container.innerHTML = "";
      container.appendChild(alert);

      if (duration !== false) {
        setTimeout(function () {
          alert.remove();
        }, duration || 5000);
      }
    }

    // Handle new stream response
    function handleNewStreamResponse(event) {
      var xhr = event.detail.xhr;
      if (xhr && xhr.status === 200) {
        try {
          var response = JSON.parse(xhr.responseText);
          if (response.success) {
            showAlert("success", "Stream PRD-" + response.id + " created successfully!");
            // Trigger refresh of streams list
            htmx.trigger(document.body, "newStreamCreated");
            // Also refresh the summary
            htmx.ajax("GET", "/api/partials/streams-summary", "#streams-summary");
          }
        } catch (e) {
          // Response might be HTML partial, still refresh
          htmx.trigger(document.body, "newStreamCreated");
        }
      } else if (xhr) {
        try {
          var response = JSON.parse(xhr.responseText);
          showAlert("error", response.message || "Failed to create stream");
        } catch (e) {
          showAlert("error", "Failed to create stream");
        }
      }
    }

    // Initialize worktree for a stream
    function initStream(streamId, event) {
      if (event) event.stopPropagation();

      fetch("/api/stream/" + streamId + "/init", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
      })
        .then(function (response) {
          return response.json();
        })
        .then(function (data) {
          if (data.success) {
            showAlert("success", "Worktree initialized for PRD-" + streamId);
            htmx.trigger(document.body, "newStreamCreated");
          } else {
            showAlert("error", data.message || "Failed to initialize worktree");
          }
        })
        .catch(function (err) {
          showAlert("error", "Failed to initialize worktree: " + err.message);
        });
    }

    // Toggle build form visibility
    function toggleBuildForm(streamId, event) {
      if (event) event.stopPropagation();

      var formId = "build-form-" + streamId;
      var form = document.getElementById(formId);
      if (form) {
        form.style.display = form.style.display === "none" ? "flex" : "none";
      }
    }

    // Start build for a stream
    function startStreamBuild(streamId, event) {
      if (event) event.preventDefault();
      if (event) event.stopPropagation();

      var input = document.getElementById("iterations-" + streamId);
      var iterations = parseInt(input ? input.value : 1, 10);

      if (isNaN(iterations) || iterations < 1 || iterations > 100) {
        showAlert("error", "Iterations must be between 1 and 100");
        return;
      }

      fetch("/api/stream/" + streamId + "/build", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ iterations: iterations }),
      })
        .then(function (response) {
          return response.json();
        })
        .then(function (data) {
          if (data.success) {
            showAlert(
              "success",
              "Build started for PRD-" + streamId + " with " + iterations + " iterations"
            );
            // Hide the build form
            var form = document.getElementById("build-form-" + streamId);
            if (form) form.style.display = "none";
            // Refresh streams list
            htmx.trigger(document.body, "newStreamCreated");
          } else {
            showAlert("error", data.message || "Failed to start build");
          }
        })
        .catch(function (err) {
          showAlert("error", "Failed to start build: " + err.message);
        });
    }

    // Merge stream to main branch
    function mergeStream(streamId, streamName, event) {
      if (event) event.stopPropagation();

      // Show confirmation dialog
      var confirmed = confirm(
        "Are you sure you want to merge stream PRD-" +
          streamId +
          ' to main?\n\nThis will merge all changes from "' +
          streamName +
          '" into the main branch.'
      );

      if (!confirmed) {
        return;
      }

      fetch("/api/stream/" + streamId + "/merge", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
      })
        .then(function (response) {
          return response.json();
        })
        .then(function (data) {
          if (data.success) {
            showAlert("success", "PRD-" + streamId + " merged to main successfully!");
            htmx.trigger(document.body, "newStreamCreated");
          } else {
            showAlert("error", data.message || "Failed to merge stream");
          }
        })
        .catch(function (err) {
          showAlert("error", "Failed to merge stream: " + err.message);
        });
    }

    // Error Toast Management
    var lastFailedRequest = null;

    function showErrorToast(message, endpoint) {
      console.error("[Error]", message, endpoint ? "(Endpoint: " + endpoint + ")" : "");
      var toast = document.getElementById("error-toast");
      var messageEl = document.getElementById("error-toast-message");

      messageEl.textContent = message;
      toast.classList.remove("rams-hidden");

      setTimeout(function() {
        dismissErrorToast();
      }, 10000);
    }

    function dismissErrorToast() {
      var toast = document.getElementById("error-toast");
      toast.classList.add("rams-hidden");
    }

    // HTMX error handlers
    document.body.addEventListener("htmx:responseError", function (event) {
      var xhr = event.detail.xhr;
      var path = event.detail.pathInfo ? event.detail.pathInfo.requestPath : "unknown";

      var message = "Request failed";
      if (xhr && xhr.status) {
        if (xhr.status === 0) {
          message = "Unable to connect to server. Check if the server is running.";
        } else if (xhr.status === 404) {
          message = "Resource not found: " + path;
        } else if (xhr.status === 500) {
          message = "Server error occurred. Please try again.";
          try {
            var response = JSON.parse(xhr.responseText);
            if (response.message) {
              message = response.message;
            }
          } catch (e) {}
        } else {
          message = "Request failed with status " + xhr.status;
        }
      }

      lastFailedRequest = { element: event.target };
      showErrorToast(message, path);
    });

    document.body.addEventListener("htmx:sendError", function (event) {
      var path = event.detail.pathInfo ? event.detail.pathInfo.requestPath : "unknown";
      console.error("[HTMX Send Error] Failed to send request:", path, event.detail);
      lastFailedRequest = { element: event.target };
      showErrorToast("Network error: Unable to send request. Check your connection.", path);
    });

    document.body.addEventListener("htmx:timeout", function (event) {
      var path = event.detail.pathInfo ? event.detail.pathInfo.requestPath : "unknown";
      console.error("[HTMX Timeout] Request timed out:", path);
      lastFailedRequest = { element: event.target };
      showErrorToast("Request timed out. The server may be busy.", path);
    });
  </script>
</body>
</html>
