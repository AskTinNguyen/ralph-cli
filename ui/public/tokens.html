<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ralph CLI - Token Dashboard</title>
    <link rel="stylesheet" href="/css/styles.css" />
    <script src="/js/htmx.min.js"></script>
    <script src="/js/chart.min.js"></script>
  </head>
  <body>
    <!-- Error Toast Container -->
    <div id="error-toast" class="error-toast hidden">
      <div class="error-toast-header">
        <span class="error-toast-title">Error</span>
        <button class="error-toast-dismiss" onclick="dismissErrorToast()">&times;</button>
      </div>
      <div class="error-toast-message" id="error-toast-message"></div>
      <div class="error-toast-actions">
        <button class="retry-button" id="error-toast-retry" onclick="retryLastRequest()">
          <span class="retry-icon">&#8635;</span> Retry
        </button>
      </div>
    </div>

    <header>
      <div class="header-content">
        <h1>Ralph CLI</h1>
        <span class="subtitle">Autonomous Coding Loop</span>
      </div>
      <nav>
        <a href="/">Dashboard</a>
        <a href="/streams.html">Streams</a>
        <a href="/logs.html">Logs</a>
        <a href="/tokens.html" class="active">Tokens</a>
        <a href="/editor.html">Editor</a>
      </nav>
    </header>

    <main>
      <!-- Budget Tracking Section -->
      <section id="token-budget-section">
        <h2>
          Budget Tracking
          <span class="htmx-indicator" id="budget-indicator"
            ><span class="loading-spinner"></span
          ></span>
        </h2>
        <div
          id="token-budget-container"
          hx-get="/api/partials/token-budget"
          hx-trigger="load, every 10s"
          hx-swap="innerHTML"
          hx-indicator="#budget-indicator"
        >
          <div class="loading"><span class="loading-spinner"></span> Loading budget status...</div>
        </div>
      </section>

      <!-- Export Section -->
      <section id="token-export-section">
        <h2>Export Reports</h2>
        <div class="export-controls">
          <div class="export-options">
            <div class="control-group">
              <label for="export-format">Format:</label>
              <select id="export-format">
                <option value="csv" selected>CSV</option>
                <option value="json">JSON</option>
              </select>
            </div>
            <div class="control-group">
              <label for="export-from">From:</label>
              <input type="date" id="export-from" />
            </div>
            <div class="control-group">
              <label for="export-to">To:</label>
              <input type="date" id="export-to" />
            </div>
            <div class="control-group">
              <label for="export-stream">Stream:</label>
              <select id="export-stream">
                <option value="" selected>All Streams</option>
                <!-- Stream options populated dynamically -->
              </select>
            </div>
          </div>
          <div class="export-buttons">
            <button class="export-button" onclick="exportTokenReport()">
              <span class="export-icon">&#8615;</span> Export Report
            </button>
          </div>
        </div>
      </section>

      <!-- Token Summary Section -->
      <section id="token-summary-section">
        <h2>
          Token Consumption Overview
          <span class="htmx-indicator" id="summary-indicator"
            ><span class="loading-spinner"></span
          ></span>
        </h2>
        <div
          id="token-summary-container"
          hx-get="/api/partials/token-summary"
          hx-trigger="load, every 10s"
          hx-swap="innerHTML"
          hx-indicator="#summary-indicator"
        >
          <div class="loading"><span class="loading-spinner"></span> Loading token summary...</div>
        </div>
      </section>

      <!-- Token Timeline Chart Section -->
      <section id="token-chart-section">
        <div class="token-chart-header">
          <h2>Token Usage Timeline</h2>
          <div class="token-chart-controls">
            <div class="control-group">
              <label for="chart-period">Period:</label>
              <select id="chart-period" onchange="updateChart()">
                <option value="7d" selected>Last 7 days</option>
                <option value="30d">Last 30 days</option>
                <option value="90d">Last 90 days</option>
                <option value="all">All time</option>
              </select>
            </div>
            <div class="control-group">
              <label for="chart-stream">Stream:</label>
              <select id="chart-stream" onchange="updateChart()">
                <option value="" selected>All Streams (Aggregate)</option>
                <!-- Stream options populated dynamically -->
              </select>
            </div>
          </div>
        </div>
        <div class="token-chart-container">
          <canvas id="token-timeline-chart"></canvas>
        </div>
        <div class="token-chart-legend">
          <div class="legend-item">
            <span class="legend-color" style="background: #3b82f6"></span>
            <span>Input Tokens</span>
          </div>
          <div class="legend-item">
            <span class="legend-color" style="background: #10b981"></span>
            <span>Output Tokens</span>
          </div>
          <div class="legend-item">
            <span class="legend-color legend-dashed" style="background: #f59e0b"></span>
            <span>Cost (USD)</span>
          </div>
        </div>
      </section>

      <!-- Token by Stream Section -->
      <section id="token-streams-section">
        <h2>
          Token Usage by Stream
          <span class="htmx-indicator" id="streams-indicator"
            ><span class="loading-spinner"></span
          ></span>
        </h2>
        <div
          id="token-streams-container"
          hx-get="/api/partials/token-streams"
          hx-trigger="load, every 10s"
          hx-swap="innerHTML"
          hx-indicator="#streams-indicator"
        >
          <div class="loading">
            <span class="loading-spinner"></span> Loading stream token data...
          </div>
        </div>
      </section>

      <!-- Token by Model Section -->
      <section id="token-models-section">
        <h2>
          Token Usage by Model
          <span class="htmx-indicator" id="models-indicator"
            ><span class="loading-spinner"></span
          ></span>
        </h2>
        <div
          id="token-models-container"
          hx-get="/api/partials/token-models"
          hx-trigger="load, every 10s"
          hx-swap="innerHTML"
          hx-indicator="#models-indicator"
        >
          <div class="loading">
            <span class="loading-spinner"></span> Loading model token data...
          </div>
        </div>
      </section>

      <!-- Per-Story Token Detail Section (shown when a stream is selected) -->
      <section id="token-stories-section" style="display: none">
        <div class="token-stories-breadcrumb">
          <a
            href="#"
            onclick="
              hideTokenStories();
              return false;
            "
            >&larr; Back to Streams</a
          >
          <span class="token-stories-stream-title" id="token-stories-stream-title"
            >Stream Detail</span
          >
        </div>
        <h2>
          Per-Story Token Breakdown
          <span class="htmx-indicator" id="stories-indicator"
            ><span class="loading-spinner"></span
          ></span>
        </h2>
        <div id="token-stories-container">
          <!-- Story breakdown content loaded via HTMX -->
        </div>
      </section>
    </main>

    <footer>
      <p>
        Ralph CLI Web UI &mdash;
        <span
          id="status-indicator"
          hx-get="/api/partials/status-indicator"
          hx-trigger="load, every 5s"
          hx-swap="innerHTML"
          >checking...</span
        >
      </p>
    </footer>

    <script>
      // ============================================
      // Table Sorting
      // ============================================

      var currentSort = { column: null, direction: "asc" };

      // Sort table by column
      function sortTable(table, column, type, direction) {
        var tbody = table.querySelector("tbody");
        var rows = Array.from(tbody.querySelectorAll("tr"));

        rows.sort(function (a, b) {
          var aValue, bValue;

          if (column === "stream") {
            aValue = a.querySelector(".stream-name").textContent.toLowerCase();
            bValue = b.querySelector(".stream-name").textContent.toLowerCase();
          } else {
            aValue = parseFloat(a.dataset[column]) || 0;
            bValue = parseFloat(b.dataset[column]) || 0;
          }

          if (type === "string") {
            return direction === "asc"
              ? aValue.localeCompare(bValue)
              : bValue.localeCompare(aValue);
          } else {
            return direction === "asc" ? aValue - bValue : bValue - aValue;
          }
        });

        // Reorder rows in DOM
        rows.forEach(function (row) {
          tbody.appendChild(row);
        });
      }

      // Initialize sortable table headers
      function initSortableTable() {
        var table = document.getElementById("token-streams-table");
        if (!table) return;

        var headers = table.querySelectorAll("th.sortable");
        headers.forEach(function (header) {
          header.addEventListener("click", function () {
            var column = this.dataset.sort;
            var type = this.dataset.sortType;

            // Determine new direction
            var newDirection = "asc";
            if (currentSort.column === column && currentSort.direction === "asc") {
              newDirection = "desc";
            }

            // Update current sort state
            currentSort.column = column;
            currentSort.direction = newDirection;

            // Update header classes
            headers.forEach(function (h) {
              h.classList.remove("sort-asc", "sort-desc");
            });
            this.classList.add("sort-" + newDirection);

            // Sort the table
            sortTable(table, column, type, newDirection);
          });
        });
      }

      // Re-initialize sorting after HTMX swaps
      document.body.addEventListener("htmx:afterSwap", function (event) {
        if (event.detail.target.id === "token-streams-container") {
          initSortableTable();
        }
      });

      // Initialize on page load
      document.addEventListener("DOMContentLoaded", function () {
        // Will be initialized after HTMX loads content
      });

      // ============================================
      // Stream Detail Navigation
      // ============================================

      // Show token stories detail for a stream
      function showTokenStreamDetail(streamId, streamName) {
        // Show the stories section and hide the overview sections
        document.getElementById("token-summary-section").style.display = "none";
        document.getElementById("token-streams-section").style.display = "none";
        document.getElementById("token-models-section").style.display = "none";
        document.getElementById("token-stories-section").style.display = "block";

        // Update the stream title
        document.getElementById("token-stories-stream-title").textContent =
          "PRD-" + streamId + ": " + streamName;

        // Load the story breakdown via HTMX
        htmx.ajax(
          "GET",
          "/api/partials/token-stories/" + encodeURIComponent(streamId),
          "#token-stories-container"
        );
      }

      // Hide token stories and show the main view
      function hideTokenStories() {
        document.getElementById("token-summary-section").style.display = "block";
        document.getElementById("token-streams-section").style.display = "block";
        document.getElementById("token-models-section").style.display = "block";
        document.getElementById("token-stories-section").style.display = "none";

        // Clear the container
        document.getElementById("token-stories-container").innerHTML = "";
      }

      // Check URL params for initial stream selection
      document.addEventListener("DOMContentLoaded", function () {
        var urlParams = new URLSearchParams(window.location.search);
        var streamId = urlParams.get("stream");
        var streamName = urlParams.get("name") || "Stream " + streamId;

        if (streamId) {
          showTokenStreamDetail(streamId, streamName);
        }
      });

      // ============================================
      // Error Handling
      // ============================================

      var lastFailedRequest = null;

      // Show error toast
      function showErrorToast(message, endpoint) {
        console.error("[Error]", message, endpoint ? "(Endpoint: " + endpoint + ")" : "");
        var toast = document.getElementById("error-toast");
        var messageEl = document.getElementById("error-toast-message");
        var retryBtn = document.getElementById("error-toast-retry");

        messageEl.textContent = message;

        if (lastFailedRequest) {
          retryBtn.style.display = "inline-flex";
        } else {
          retryBtn.style.display = "none";
        }

        toast.classList.remove("hidden", "dismissing");
      }

      // Dismiss error toast
      function dismissErrorToast() {
        var toast = document.getElementById("error-toast");
        toast.classList.add("dismissing");
        setTimeout(function () {
          toast.classList.add("hidden");
          toast.classList.remove("dismissing");
        }, 300);
      }

      // Retry last failed request
      function retryLastRequest() {
        if (lastFailedRequest) {
          var retryBtn = document.getElementById("error-toast-retry");
          retryBtn.classList.add("loading");
          retryBtn.disabled = true;

          var element = lastFailedRequest.element;
          htmx.trigger(element, "load");

          setTimeout(function () {
            retryBtn.classList.remove("loading");
            retryBtn.disabled = false;
            lastFailedRequest = null;
            dismissErrorToast();
          }, 1000);
        }
      }

      // HTMX error handlers
      document.body.addEventListener("htmx:responseError", function (event) {
        var xhr = event.detail.xhr;
        var path = event.detail.pathInfo ? event.detail.pathInfo.requestPath : "unknown";

        var message = "Request failed";
        if (xhr && xhr.status) {
          if (xhr.status === 0) {
            message = "Unable to connect to server. Check if the server is running.";
          } else if (xhr.status === 404) {
            message = "Resource not found: " + path;
          } else if (xhr.status === 500) {
            message = "Server error occurred. Please try again.";
            try {
              var response = JSON.parse(xhr.responseText);
              if (response.message) {
                message = response.message;
              }
            } catch (e) {}
          } else {
            message = "Request failed with status " + xhr.status;
          }
        }

        lastFailedRequest = { element: event.target };
        showErrorToast(message, path);
      });

      document.body.addEventListener("htmx:sendError", function (event) {
        var path = event.detail.pathInfo ? event.detail.pathInfo.requestPath : "unknown";
        console.error("[HTMX Send Error] Failed to send request:", path, event.detail);
        lastFailedRequest = { element: event.target };
        showErrorToast("Network error: Unable to send request. Check your connection.", path);
      });

      document.body.addEventListener("htmx:timeout", function (event) {
        var path = event.detail.pathInfo ? event.detail.pathInfo.requestPath : "unknown";
        console.error("[HTMX Timeout] Request timed out:", path);
        lastFailedRequest = { element: event.target };
        showErrorToast("Request timed out. The server may be busy.", path);
      });

      // Auto-dismiss error toast after 10 seconds
      setInterval(function () {
        var toast = document.getElementById("error-toast");
        if (!toast.classList.contains("hidden") && !lastFailedRequest) {
          dismissErrorToast();
        }
      }, 10000);

      // ============================================
      // Token Timeline Chart
      // ============================================

      var tokenChart = null;
      var chartData = { dataPoints: [] };

      // Initialize the chart
      function initTokenChart() {
        var ctx = document.getElementById("token-timeline-chart");
        if (!ctx) return;

        // Detect dark mode
        var isDarkMode =
          document.body.classList.contains("dark-mode") ||
          window.matchMedia("(prefers-color-scheme: dark)").matches;

        var gridColor = isDarkMode ? "rgba(255, 255, 255, 0.1)" : "rgba(0, 0, 0, 0.1)";
        var textColor = isDarkMode ? "#e5e7eb" : "#374151";

        tokenChart = new Chart(ctx, {
          type: "line",
          data: {
            labels: [],
            datasets: [
              {
                label: "Input Tokens",
                data: [],
                borderColor: "#3b82f6",
                backgroundColor: "rgba(59, 130, 246, 0.1)",
                fill: true,
                tension: 0.3,
                yAxisID: "y",
                pointRadius: 4,
                pointHoverRadius: 6,
              },
              {
                label: "Output Tokens",
                data: [],
                borderColor: "#10b981",
                backgroundColor: "rgba(16, 185, 129, 0.1)",
                fill: true,
                tension: 0.3,
                yAxisID: "y",
                pointRadius: 4,
                pointHoverRadius: 6,
              },
              {
                label: "Cost (USD)",
                data: [],
                borderColor: "#f59e0b",
                backgroundColor: "transparent",
                borderDash: [5, 5],
                fill: false,
                tension: 0.3,
                yAxisID: "y1",
                pointRadius: 4,
                pointHoverRadius: 6,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
              mode: "index",
              intersect: false,
            },
            plugins: {
              legend: {
                display: false, // We use our custom legend
              },
              tooltip: {
                backgroundColor: isDarkMode ? "#1f2937" : "#ffffff",
                titleColor: textColor,
                bodyColor: textColor,
                borderColor: gridColor,
                borderWidth: 1,
                padding: 12,
                callbacks: {
                  label: function (context) {
                    var label = context.dataset.label || "";
                    var value = context.parsed.y;
                    if (label === "Cost (USD)") {
                      return label + ": $" + value.toFixed(4);
                    }
                    return label + ": " + value.toLocaleString();
                  },
                },
              },
            },
            scales: {
              x: {
                display: true,
                grid: {
                  color: gridColor,
                },
                ticks: {
                  color: textColor,
                  maxTicksLimit: 10,
                },
              },
              y: {
                type: "linear",
                display: true,
                position: "left",
                title: {
                  display: true,
                  text: "Tokens",
                  color: textColor,
                },
                grid: {
                  color: gridColor,
                },
                ticks: {
                  color: textColor,
                  callback: function (value) {
                    if (value >= 1000000) return (value / 1000000).toFixed(1) + "M";
                    if (value >= 1000) return (value / 1000).toFixed(1) + "K";
                    return value;
                  },
                },
              },
              y1: {
                type: "linear",
                display: true,
                position: "right",
                title: {
                  display: true,
                  text: "Cost (USD)",
                  color: textColor,
                },
                grid: {
                  drawOnChartArea: false,
                },
                ticks: {
                  color: "#f59e0b",
                  callback: function (value) {
                    return "$" + value.toFixed(2);
                  },
                },
              },
            },
          },
        });
      }

      // Fetch chart data and update
      function updateChart() {
        var period = document.getElementById("chart-period").value;
        var streamId = document.getElementById("chart-stream").value;

        var url = "/api/tokens/trends?period=" + encodeURIComponent(period);
        if (streamId) {
          url += "&streamId=" + encodeURIComponent(streamId);
        }

        fetch(url)
          .then(function (response) {
            if (!response.ok) throw new Error("Failed to fetch chart data");
            return response.json();
          })
          .then(function (data) {
            chartData = data;
            renderChart();
          })
          .catch(function (error) {
            console.error("Error fetching chart data:", error);
          });
      }

      // Render chart with current data
      function renderChart() {
        if (!tokenChart) return;

        var dataPoints = chartData.dataPoints || [];

        // Format dates for display
        var labels = dataPoints.map(function (dp) {
          var date = new Date(dp.date);
          return date.toLocaleDateString("en-US", { month: "short", day: "numeric" });
        });

        var inputTokens = dataPoints.map(function (dp) {
          return dp.inputTokens;
        });
        var outputTokens = dataPoints.map(function (dp) {
          return dp.outputTokens;
        });
        var costs = dataPoints.map(function (dp) {
          return dp.totalCost;
        });

        tokenChart.data.labels = labels;
        tokenChart.data.datasets[0].data = inputTokens;
        tokenChart.data.datasets[1].data = outputTokens;
        tokenChart.data.datasets[2].data = costs;

        tokenChart.update("active");
      }

      // Populate stream dropdown
      function populateStreamDropdown() {
        fetch("/api/tokens/summary")
          .then(function (response) {
            if (!response.ok) throw new Error("Failed to fetch streams");
            return response.json();
          })
          .then(function (data) {
            var select = document.getElementById("chart-stream");
            var streams = data.byStream || [];

            // Clear existing options except the first one
            while (select.options.length > 1) {
              select.remove(1);
            }

            // Add stream options
            streams.forEach(function (stream) {
              var option = document.createElement("option");
              option.value = stream.streamId;
              option.textContent = "PRD-" + stream.streamId + ": " + stream.streamName;
              select.appendChild(option);
            });
          })
          .catch(function (error) {
            console.error("Error fetching streams:", error);
          });
      }

      // Handle visibility changes for chart section
      function updateChartSectionVisibility(visible) {
        var chartSection = document.getElementById("token-chart-section");
        if (chartSection) {
          chartSection.style.display = visible ? "block" : "none";
        }
      }

      // Hide export section when viewing stream details
      function updateExportSectionVisibility(visible) {
        var exportSection = document.getElementById("token-export-section");
        if (exportSection) {
          exportSection.style.display = visible ? "block" : "none";
        }
      }

      // Update showTokenStreamDetail to hide chart section
      var originalShowTokenStreamDetail = showTokenStreamDetail;
      showTokenStreamDetail = function (streamId, streamName) {
        updateChartSectionVisibility(false);
        updateExportSectionVisibility(false);
        originalShowTokenStreamDetail(streamId, streamName);
      };

      // Update hideTokenStories to show chart section
      var originalHideTokenStories = hideTokenStories;
      hideTokenStories = function () {
        updateChartSectionVisibility(true);
        updateExportSectionVisibility(true);
        originalHideTokenStories();
      };

      // ============================================
      // Export Functionality
      // ============================================

      // Populate export stream dropdown
      function populateExportStreamDropdown() {
        fetch("/api/tokens/summary")
          .then(function (response) {
            if (!response.ok) throw new Error("Failed to fetch streams");
            return response.json();
          })
          .then(function (data) {
            var select = document.getElementById("export-stream");
            var streams = data.byStream || [];

            // Clear existing options except the first one
            while (select.options.length > 1) {
              select.remove(1);
            }

            // Add stream options
            streams.forEach(function (stream) {
              var option = document.createElement("option");
              option.value = stream.streamId;
              option.textContent = "PRD-" + stream.streamId + ": " + stream.streamName;
              select.appendChild(option);
            });
          })
          .catch(function (error) {
            console.error("Error fetching streams for export:", error);
          });
      }

      // Export token report
      function exportTokenReport() {
        var format = document.getElementById("export-format").value;
        var from = document.getElementById("export-from").value;
        var to = document.getElementById("export-to").value;
        var streamId = document.getElementById("export-stream").value;

        // Build URL with query params
        var url = "/api/tokens/export?format=" + encodeURIComponent(format);
        if (from) {
          url += "&from=" + encodeURIComponent(from);
        }
        if (to) {
          url += "&to=" + encodeURIComponent(to);
        }
        if (streamId) {
          url += "&streamId=" + encodeURIComponent(streamId);
        }

        // Trigger download via anchor element
        var link = document.createElement("a");
        link.href = url;
        link.download = "";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      // Initialize chart on page load
      document.addEventListener("DOMContentLoaded", function () {
        initTokenChart();
        populateStreamDropdown();
        populateExportStreamDropdown();
        updateChart();
      });

      // ============================================
      // Model Comparison (A/B Comparison)
      // ============================================

      // Update model comparison when selections change
      function updateModelComparison() {
        var selectA = document.getElementById("compare-model-a");
        var selectB = document.getElementById("compare-model-b");
        var resultContainer = document.getElementById("model-comparison-result");

        if (!selectA || !selectB || !resultContainer) return;

        var modelA = selectA.value;
        var modelB = selectB.value;

        if (modelA === modelB) {
          resultContainer.innerHTML =
            '<p class="comparison-hint">Select different models to compare their efficiency metrics.</p>';
          return;
        }

        resultContainer.innerHTML =
          '<div class="comparison-loading"><span class="loading-spinner"></span> Comparing models...</div>';

        var url =
          "/api/tokens/compare?modelA=" +
          encodeURIComponent(modelA) +
          "&modelB=" +
          encodeURIComponent(modelB);

        fetch(url)
          .then(function (response) {
            if (!response.ok) throw new Error("Failed to compare models");
            return response.json();
          })
          .then(function (data) {
            renderModelComparison(data, resultContainer);
          })
          .catch(function (error) {
            console.error("Error comparing models:", error);
            resultContainer.innerHTML =
              '<p class="comparison-hint">Error comparing models. Please try again.</p>';
          });
      }

      // Render the model comparison results
      function renderModelComparison(data, container) {
        if (!data.comparison || !data.comparison.valid) {
          container.innerHTML =
            '<p class="comparison-hint">' +
            (data.comparison?.reason ||
              "Unable to compare models. Ensure both models have run data.") +
            "</p>";
          return;
        }

        var comparison = data.comparison;
        var metricsHtml = "";

        // Format currency helper
        function formatCurrency(cost) {
          if (cost >= 1) return "$" + cost.toFixed(2);
          if (cost >= 0.01) return "$" + cost.toFixed(3);
          if (cost > 0) return "$" + cost.toFixed(4);
          return "$0.00";
        }

        // Format number helper
        function formatNumber(num) {
          if (num >= 1000000) return (num / 1000000).toFixed(1) + "M";
          if (num >= 1000) return (num / 1000).toFixed(1) + "K";
          return num.toString();
        }

        // Build metrics comparison
        if (comparison.metrics) {
          var metricItems = Object.keys(comparison.metrics)
            .map(function (key) {
              var metric = comparison.metrics[key];
              var valueA = key.includes("cost")
                ? formatCurrency(metric.modelA)
                : key.includes("Rate")
                  ? metric.modelA + "%"
                  : formatNumber(metric.modelA);
              var valueB = key.includes("cost")
                ? formatCurrency(metric.modelB)
                : key.includes("Rate")
                  ? metric.modelB + "%"
                  : formatNumber(metric.modelB);
              var winnerA = metric.winner === comparison.modelA;
              var winnerB = metric.winner === comparison.modelB;

              return (
                '<div class="comparison-metric">' +
                '<div class="comparison-metric-label">' +
                metric.label +
                "</div>" +
                '<div class="comparison-metric-values">' +
                '<span class="comparison-metric-value' +
                (winnerA ? " winner" : "") +
                '">' +
                valueA +
                "</span>" +
                '<span class="comparison-metric-diff">' +
                (metric.percentDiff > 0 ? metric.percentDiff + "% diff" : "-") +
                "</span>" +
                '<span class="comparison-metric-value' +
                (winnerB ? " winner" : "") +
                '">' +
                valueB +
                "</span>" +
                "</div>" +
                "</div>"
              );
            })
            .join("");

          metricsHtml = '<div class="comparison-metrics">' + metricItems + "</div>";
        }

        // Build recommendations
        var recsHtml = "";
        if (comparison.recommendations && comparison.recommendations.length > 0) {
          var recItems = comparison.recommendations
            .map(function (rec) {
              var icon =
                rec.type === "overall"
                  ? "&#9733;"
                  : rec.type === "cost"
                    ? "&#36;"
                    : rec.type === "reliability"
                      ? "&#10003;"
                      : "&#8226;";
              return (
                '<div class="comparison-recommendation">' +
                '<span class="comparison-recommendation-icon">' +
                icon +
                "</span>" +
                '<span class="comparison-recommendation-text">' +
                rec.message +
                "</span>" +
                "</div>"
              );
            })
            .join("");

          recsHtml =
            '<div class="comparison-recommendations">' +
            "<strong>Recommendations:</strong>" +
            recItems +
            "</div>";
        }

        container.innerHTML = metricsHtml + recsHtml;
      }

      // Re-initialize comparison controls after HTMX loads model section
      document.body.addEventListener("htmx:afterSwap", function (event) {
        if (event.detail.target.id === "token-models-container") {
          // Set different default selections for comparison
          var selectB = document.getElementById("compare-model-b");
          if (selectB && selectB.options.length > 1) {
            selectB.selectedIndex = 1;
          }
        }
      });
    </script>
  </body>
</html>
