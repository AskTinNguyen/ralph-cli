<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ralph CLI - Token Dashboard</title>
  <link rel="stylesheet" href="/css/styles.css">
  <script src="/js/htmx.min.js"></script>
  <script src="/js/chart.min.js"></script>
</head>
<body>
  <!-- Error Toast Container -->
  <div id="error-toast" class="error-toast hidden">
    <div class="error-toast-header">
      <span class="error-toast-title">Error</span>
      <button class="error-toast-dismiss" onclick="dismissErrorToast()">&times;</button>
    </div>
    <div class="error-toast-message" id="error-toast-message"></div>
    <div class="error-toast-actions">
      <button class="retry-button" id="error-toast-retry" onclick="retryLastRequest()">
        <span class="retry-icon">&#8635;</span> Retry
      </button>
    </div>
  </div>

  <header>
    <div class="header-content">
      <h1>Ralph CLI</h1>
      <span class="subtitle">Autonomous Coding Loop</span>
    </div>
    <nav>
      <a href="/">Dashboard</a>
      <a href="/streams.html">Streams</a>
      <a href="/logs.html">Logs</a>
      <a href="/tokens.html" class="active">Tokens</a>
      <a href="/editor.html">Editor</a>
    </nav>
  </header>

  <main>
    <!-- Budget Tracking Section -->
    <section id="token-budget-section">
      <h2>Budget Tracking <span class="htmx-indicator" id="budget-indicator"><span class="loading-spinner"></span></span></h2>
      <div id="token-budget-container"
           hx-get="/api/partials/token-budget"
           hx-trigger="load, every 10s"
           hx-swap="innerHTML"
           hx-indicator="#budget-indicator">
        <div class="loading"><span class="loading-spinner"></span> Loading budget status...</div>
      </div>
    </section>

    <!-- Token Summary Section -->
    <section id="token-summary-section">
      <h2>Token Consumption Overview <span class="htmx-indicator" id="summary-indicator"><span class="loading-spinner"></span></span></h2>
      <div id="token-summary-container"
           hx-get="/api/partials/token-summary"
           hx-trigger="load, every 10s"
           hx-swap="innerHTML"
           hx-indicator="#summary-indicator">
        <div class="loading"><span class="loading-spinner"></span> Loading token summary...</div>
      </div>
    </section>

    <!-- Token Timeline Chart Section -->
    <section id="token-chart-section">
      <div class="token-chart-header">
        <h2>Token Usage Timeline</h2>
        <div class="token-chart-controls">
          <div class="control-group">
            <label for="chart-period">Period:</label>
            <select id="chart-period" onchange="updateChart()">
              <option value="7d" selected>Last 7 days</option>
              <option value="30d">Last 30 days</option>
              <option value="90d">Last 90 days</option>
              <option value="all">All time</option>
            </select>
          </div>
          <div class="control-group">
            <label for="chart-stream">Stream:</label>
            <select id="chart-stream" onchange="updateChart()">
              <option value="" selected>All Streams (Aggregate)</option>
              <!-- Stream options populated dynamically -->
            </select>
          </div>
        </div>
      </div>
      <div class="token-chart-container">
        <canvas id="token-timeline-chart"></canvas>
      </div>
      <div class="token-chart-legend">
        <div class="legend-item">
          <span class="legend-color" style="background: #3b82f6;"></span>
          <span>Input Tokens</span>
        </div>
        <div class="legend-item">
          <span class="legend-color" style="background: #10b981;"></span>
          <span>Output Tokens</span>
        </div>
        <div class="legend-item">
          <span class="legend-color legend-dashed" style="background: #f59e0b;"></span>
          <span>Cost (USD)</span>
        </div>
      </div>
    </section>

    <!-- Token by Stream Section -->
    <section id="token-streams-section">
      <h2>Token Usage by Stream <span class="htmx-indicator" id="streams-indicator"><span class="loading-spinner"></span></span></h2>
      <div id="token-streams-container"
           hx-get="/api/partials/token-streams"
           hx-trigger="load, every 10s"
           hx-swap="innerHTML"
           hx-indicator="#streams-indicator">
        <div class="loading"><span class="loading-spinner"></span> Loading stream token data...</div>
      </div>
    </section>

    <!-- Token by Model Section -->
    <section id="token-models-section">
      <h2>Token Usage by Model <span class="htmx-indicator" id="models-indicator"><span class="loading-spinner"></span></span></h2>
      <div id="token-models-container"
           hx-get="/api/partials/token-models"
           hx-trigger="load, every 10s"
           hx-swap="innerHTML"
           hx-indicator="#models-indicator">
        <div class="loading"><span class="loading-spinner"></span> Loading model token data...</div>
      </div>
    </section>

    <!-- Per-Story Token Detail Section (shown when a stream is selected) -->
    <section id="token-stories-section" style="display: none;">
      <div class="token-stories-breadcrumb">
        <a href="#" onclick="hideTokenStories(); return false;">&larr; Back to Streams</a>
        <span class="token-stories-stream-title" id="token-stories-stream-title">Stream Detail</span>
      </div>
      <h2>Per-Story Token Breakdown <span class="htmx-indicator" id="stories-indicator"><span class="loading-spinner"></span></span></h2>
      <div id="token-stories-container">
        <!-- Story breakdown content loaded via HTMX -->
      </div>
    </section>
  </main>

  <footer>
    <p>Ralph CLI Web UI &mdash; <span id="status-indicator" hx-get="/api/partials/status-indicator" hx-trigger="load, every 5s" hx-swap="innerHTML">checking...</span></p>
  </footer>

  <script>
    // ============================================
    // Table Sorting
    // ============================================

    var currentSort = { column: null, direction: 'asc' };

    // Sort table by column
    function sortTable(table, column, type, direction) {
      var tbody = table.querySelector('tbody');
      var rows = Array.from(tbody.querySelectorAll('tr'));

      rows.sort(function(a, b) {
        var aValue, bValue;

        if (column === 'stream') {
          aValue = a.querySelector('.stream-name').textContent.toLowerCase();
          bValue = b.querySelector('.stream-name').textContent.toLowerCase();
        } else {
          aValue = parseFloat(a.dataset[column]) || 0;
          bValue = parseFloat(b.dataset[column]) || 0;
        }

        if (type === 'string') {
          return direction === 'asc'
            ? aValue.localeCompare(bValue)
            : bValue.localeCompare(aValue);
        } else {
          return direction === 'asc'
            ? aValue - bValue
            : bValue - aValue;
        }
      });

      // Reorder rows in DOM
      rows.forEach(function(row) {
        tbody.appendChild(row);
      });
    }

    // Initialize sortable table headers
    function initSortableTable() {
      var table = document.getElementById('token-streams-table');
      if (!table) return;

      var headers = table.querySelectorAll('th.sortable');
      headers.forEach(function(header) {
        header.addEventListener('click', function() {
          var column = this.dataset.sort;
          var type = this.dataset.sortType;

          // Determine new direction
          var newDirection = 'asc';
          if (currentSort.column === column && currentSort.direction === 'asc') {
            newDirection = 'desc';
          }

          // Update current sort state
          currentSort.column = column;
          currentSort.direction = newDirection;

          // Update header classes
          headers.forEach(function(h) {
            h.classList.remove('sort-asc', 'sort-desc');
          });
          this.classList.add('sort-' + newDirection);

          // Sort the table
          sortTable(table, column, type, newDirection);
        });
      });
    }

    // Re-initialize sorting after HTMX swaps
    document.body.addEventListener('htmx:afterSwap', function(event) {
      if (event.detail.target.id === 'token-streams-container') {
        initSortableTable();
      }
    });

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', function() {
      // Will be initialized after HTMX loads content
    });

    // ============================================
    // Stream Detail Navigation
    // ============================================

    // Show token stories detail for a stream
    function showTokenStreamDetail(streamId, streamName) {
      // Show the stories section and hide the overview sections
      document.getElementById('token-summary-section').style.display = 'none';
      document.getElementById('token-streams-section').style.display = 'none';
      document.getElementById('token-models-section').style.display = 'none';
      document.getElementById('token-stories-section').style.display = 'block';

      // Update the stream title
      document.getElementById('token-stories-stream-title').textContent = 'PRD-' + streamId + ': ' + streamName;

      // Load the story breakdown via HTMX
      htmx.ajax('GET', '/api/partials/token-stories/' + encodeURIComponent(streamId), '#token-stories-container');
    }

    // Hide token stories and show the main view
    function hideTokenStories() {
      document.getElementById('token-summary-section').style.display = 'block';
      document.getElementById('token-streams-section').style.display = 'block';
      document.getElementById('token-models-section').style.display = 'block';
      document.getElementById('token-stories-section').style.display = 'none';

      // Clear the container
      document.getElementById('token-stories-container').innerHTML = '';
    }

    // Check URL params for initial stream selection
    document.addEventListener('DOMContentLoaded', function() {
      var urlParams = new URLSearchParams(window.location.search);
      var streamId = urlParams.get('stream');
      var streamName = urlParams.get('name') || 'Stream ' + streamId;

      if (streamId) {
        showTokenStreamDetail(streamId, streamName);
      }
    });

    // ============================================
    // Error Handling
    // ============================================

    var lastFailedRequest = null;

    // Show error toast
    function showErrorToast(message, endpoint) {
      console.error('[Error]', message, endpoint ? '(Endpoint: ' + endpoint + ')' : '');
      var toast = document.getElementById('error-toast');
      var messageEl = document.getElementById('error-toast-message');
      var retryBtn = document.getElementById('error-toast-retry');

      messageEl.textContent = message;

      if (lastFailedRequest) {
        retryBtn.style.display = 'inline-flex';
      } else {
        retryBtn.style.display = 'none';
      }

      toast.classList.remove('hidden', 'dismissing');
    }

    // Dismiss error toast
    function dismissErrorToast() {
      var toast = document.getElementById('error-toast');
      toast.classList.add('dismissing');
      setTimeout(function() {
        toast.classList.add('hidden');
        toast.classList.remove('dismissing');
      }, 300);
    }

    // Retry last failed request
    function retryLastRequest() {
      if (lastFailedRequest) {
        var retryBtn = document.getElementById('error-toast-retry');
        retryBtn.classList.add('loading');
        retryBtn.disabled = true;

        var element = lastFailedRequest.element;
        htmx.trigger(element, 'load');

        setTimeout(function() {
          retryBtn.classList.remove('loading');
          retryBtn.disabled = false;
          lastFailedRequest = null;
          dismissErrorToast();
        }, 1000);
      }
    }

    // HTMX error handlers
    document.body.addEventListener('htmx:responseError', function(event) {
      var xhr = event.detail.xhr;
      var path = event.detail.pathInfo ? event.detail.pathInfo.requestPath : 'unknown';

      var message = 'Request failed';
      if (xhr && xhr.status) {
        if (xhr.status === 0) {
          message = 'Unable to connect to server. Check if the server is running.';
        } else if (xhr.status === 404) {
          message = 'Resource not found: ' + path;
        } else if (xhr.status === 500) {
          message = 'Server error occurred. Please try again.';
          try {
            var response = JSON.parse(xhr.responseText);
            if (response.message) {
              message = response.message;
            }
          } catch (e) {}
        } else {
          message = 'Request failed with status ' + xhr.status;
        }
      }

      lastFailedRequest = { element: event.target };
      showErrorToast(message, path);
    });

    document.body.addEventListener('htmx:sendError', function(event) {
      var path = event.detail.pathInfo ? event.detail.pathInfo.requestPath : 'unknown';
      console.error('[HTMX Send Error] Failed to send request:', path, event.detail);
      lastFailedRequest = { element: event.target };
      showErrorToast('Network error: Unable to send request. Check your connection.', path);
    });

    document.body.addEventListener('htmx:timeout', function(event) {
      var path = event.detail.pathInfo ? event.detail.pathInfo.requestPath : 'unknown';
      console.error('[HTMX Timeout] Request timed out:', path);
      lastFailedRequest = { element: event.target };
      showErrorToast('Request timed out. The server may be busy.', path);
    });

    // Auto-dismiss error toast after 10 seconds
    setInterval(function() {
      var toast = document.getElementById('error-toast');
      if (!toast.classList.contains('hidden') && !lastFailedRequest) {
        dismissErrorToast();
      }
    }, 10000);

    // ============================================
    // Token Timeline Chart
    // ============================================

    var tokenChart = null;
    var chartData = { dataPoints: [] };

    // Initialize the chart
    function initTokenChart() {
      var ctx = document.getElementById('token-timeline-chart');
      if (!ctx) return;

      // Detect dark mode
      var isDarkMode = document.body.classList.contains('dark-mode') ||
                       window.matchMedia('(prefers-color-scheme: dark)').matches;

      var gridColor = isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
      var textColor = isDarkMode ? '#e5e7eb' : '#374151';

      tokenChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: [],
          datasets: [
            {
              label: 'Input Tokens',
              data: [],
              borderColor: '#3b82f6',
              backgroundColor: 'rgba(59, 130, 246, 0.1)',
              fill: true,
              tension: 0.3,
              yAxisID: 'y',
              pointRadius: 4,
              pointHoverRadius: 6,
            },
            {
              label: 'Output Tokens',
              data: [],
              borderColor: '#10b981',
              backgroundColor: 'rgba(16, 185, 129, 0.1)',
              fill: true,
              tension: 0.3,
              yAxisID: 'y',
              pointRadius: 4,
              pointHoverRadius: 6,
            },
            {
              label: 'Cost (USD)',
              data: [],
              borderColor: '#f59e0b',
              backgroundColor: 'transparent',
              borderDash: [5, 5],
              fill: false,
              tension: 0.3,
              yAxisID: 'y1',
              pointRadius: 4,
              pointHoverRadius: 6,
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            mode: 'index',
            intersect: false,
          },
          plugins: {
            legend: {
              display: false, // We use our custom legend
            },
            tooltip: {
              backgroundColor: isDarkMode ? '#1f2937' : '#ffffff',
              titleColor: textColor,
              bodyColor: textColor,
              borderColor: gridColor,
              borderWidth: 1,
              padding: 12,
              callbacks: {
                label: function(context) {
                  var label = context.dataset.label || '';
                  var value = context.parsed.y;
                  if (label === 'Cost (USD)') {
                    return label + ': $' + value.toFixed(4);
                  }
                  return label + ': ' + value.toLocaleString();
                }
              }
            }
          },
          scales: {
            x: {
              display: true,
              grid: {
                color: gridColor,
              },
              ticks: {
                color: textColor,
                maxTicksLimit: 10,
              }
            },
            y: {
              type: 'linear',
              display: true,
              position: 'left',
              title: {
                display: true,
                text: 'Tokens',
                color: textColor,
              },
              grid: {
                color: gridColor,
              },
              ticks: {
                color: textColor,
                callback: function(value) {
                  if (value >= 1000000) return (value / 1000000).toFixed(1) + 'M';
                  if (value >= 1000) return (value / 1000).toFixed(1) + 'K';
                  return value;
                }
              }
            },
            y1: {
              type: 'linear',
              display: true,
              position: 'right',
              title: {
                display: true,
                text: 'Cost (USD)',
                color: textColor,
              },
              grid: {
                drawOnChartArea: false,
              },
              ticks: {
                color: '#f59e0b',
                callback: function(value) {
                  return '$' + value.toFixed(2);
                }
              }
            }
          }
        }
      });
    }

    // Fetch chart data and update
    function updateChart() {
      var period = document.getElementById('chart-period').value;
      var streamId = document.getElementById('chart-stream').value;

      var url = '/api/tokens/trends?period=' + encodeURIComponent(period);
      if (streamId) {
        url += '&streamId=' + encodeURIComponent(streamId);
      }

      fetch(url)
        .then(function(response) {
          if (!response.ok) throw new Error('Failed to fetch chart data');
          return response.json();
        })
        .then(function(data) {
          chartData = data;
          renderChart();
        })
        .catch(function(error) {
          console.error('Error fetching chart data:', error);
        });
    }

    // Render chart with current data
    function renderChart() {
      if (!tokenChart) return;

      var dataPoints = chartData.dataPoints || [];

      // Format dates for display
      var labels = dataPoints.map(function(dp) {
        var date = new Date(dp.date);
        return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
      });

      var inputTokens = dataPoints.map(function(dp) { return dp.inputTokens; });
      var outputTokens = dataPoints.map(function(dp) { return dp.outputTokens; });
      var costs = dataPoints.map(function(dp) { return dp.totalCost; });

      tokenChart.data.labels = labels;
      tokenChart.data.datasets[0].data = inputTokens;
      tokenChart.data.datasets[1].data = outputTokens;
      tokenChart.data.datasets[2].data = costs;

      tokenChart.update('active');
    }

    // Populate stream dropdown
    function populateStreamDropdown() {
      fetch('/api/tokens/summary')
        .then(function(response) {
          if (!response.ok) throw new Error('Failed to fetch streams');
          return response.json();
        })
        .then(function(data) {
          var select = document.getElementById('chart-stream');
          var streams = data.byStream || [];

          // Clear existing options except the first one
          while (select.options.length > 1) {
            select.remove(1);
          }

          // Add stream options
          streams.forEach(function(stream) {
            var option = document.createElement('option');
            option.value = stream.streamId;
            option.textContent = 'PRD-' + stream.streamId + ': ' + stream.streamName;
            select.appendChild(option);
          });
        })
        .catch(function(error) {
          console.error('Error fetching streams:', error);
        });
    }

    // Handle visibility changes for chart section
    function updateChartSectionVisibility(visible) {
      var chartSection = document.getElementById('token-chart-section');
      if (chartSection) {
        chartSection.style.display = visible ? 'block' : 'none';
      }
    }

    // Update showTokenStreamDetail to hide chart section
    var originalShowTokenStreamDetail = showTokenStreamDetail;
    showTokenStreamDetail = function(streamId, streamName) {
      updateChartSectionVisibility(false);
      originalShowTokenStreamDetail(streamId, streamName);
    };

    // Update hideTokenStories to show chart section
    var originalHideTokenStories = hideTokenStories;
    hideTokenStories = function() {
      updateChartSectionVisibility(true);
      originalHideTokenStories();
    };

    // Initialize chart on page load
    document.addEventListener('DOMContentLoaded', function() {
      initTokenChart();
      populateStreamDropdown();
      updateChart();
    });
  </script>
</body>
</html>
